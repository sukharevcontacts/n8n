{"updatedAt":"2026-02-15T07:36:24.081Z","createdAt":"2026-01-03T11:38:42.863Z","id":"poTupu2jfIU7WPUA","name":"My workflow","description":null,"active":false,"isArchived":false,"nodes":[{"parameters":{},"type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[2496,1936],"id":"f10f9c59-ed30-4501-a101-8643792bf745","name":"When clicking ‘Execute workflow’"},{"parameters":{"documentId":{"__rl":true,"mode":"id","value":"1FyEGxa6JYTJxDrowfgzAzroTM8L3CWCSY1rgI2DK9KQ"},"sheetName":{"__rl":true,"value":"POST","mode":"name"},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[2816,2064],"id":"8fce66ca-b2a7-4814-9ab5-961f616e6a0f","name":"Get row(s) in sheet","credentials":{"googleSheetsOAuth2Api":{"id":"b5DluHDjTyDAsQWd","name":"Google Sheets account"}}},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"id":"7ba9d3b4-0e56-48ca-bb39-4bd86db3fa75","leftValue":"={{ $json.status }}","rightValue":1,"operator":{"type":"number","operation":"equals"}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.filter","typeVersion":2.3,"position":[3024,2064],"id":"3803c035-3d76-4acf-a6e7-fbddcd8210e1","name":"Filter"},{"parameters":{"jsCode":"return items.map(item => {\n  const d = item.json;\n\n  const num = (v) => {\n    if (v === null || v === undefined || v === '') return null;\n    const n = Number(v);\n    return Number.isFinite(n) ? n : null;\n  };\n\n  const bool1 = (v) => num(v) === 1;\n\n  const strOrNull = (v) => {\n    const s = (v ?? '').toString().trim();\n    return s ? s : null;\n  };\n\n  const titleStr = (d.title ?? '').toString();\n  const titleNorm = titleStr.trim().toUpperCase();\n\n  // NEW: marker for \"GOODMORNING\" posts (text will be taken from COOP_FACT later in Expand per store)\n  const isGoodMorning = titleNorm === 'GOODMORNING';\n\n  return {\n    json: {\n      id: num(d.id),\n      status: num(d.status),\n      region: num(d.region),\n      post_type: num(d.post_type),\n\n      send_tg: bool1(d.send_tg),\n      send_vk: bool1(d.send_vk),\n      send_site: bool1(d.send_site),\n\n      // debug flag for telegram routing (1 = send to test channel)\n      tg_debug: num(d.tg_debug),\n\n      title: titleStr,\n      text: d.text ?? '',\n      parse_mode: num(d.parse_mode) ?? 0,\n\n      media_raw: d.media_url ?? '',\n\n      // старая логика: ссылка на бота (формат \"197_КУПИТЬ\")\n      old_post: strOrNull(d.old_post),\n\n      all_region: bool1(d.all_region),\n      points_note_mode:\n        d.points_note_mode === '' || d.points_note_mode === null || d.points_note_mode === undefined\n          ? null\n          : (num(d.points_note_mode) ?? null),\n\n      schedule: strOrNull(d.schedule),\n      publish_at: strOrNull(d.publish_at),\n\n      // service fields\n      last_run_at_utc: strOrNull(d.last_run_at_utc),\n      last_run_at: strOrNull(d.last_run_at),\n      last_run_key: strOrNull(d.last_run_key),\n\n      error: strOrNull(d.error),\n\n      // NEW: flag for downstream logic\n      _goodmorning: isGoodMorning,\n\n      // исходная строка целиком (включая колонки точек)\n      _raw: d,\n    },\n  };\n});\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[3232,2064],"id":"a378a9e4-e949-481c-af89-26a3ed9c656f","name":"Code in JavaScript"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"id":"a642aa85-b884-4c19-a91b-7222a19570d1","leftValue":"={{ $json._due }}","rightValue":true,"operator":{"type":"boolean","operation":"equals"}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.filter","typeVersion":2.3,"position":[3616,2064],"id":"18768023-7135-4945-b759-0882d3342d5a","name":"Filter1"},{"parameters":{"jsCode":"// === НАСТРОЙКИ ===\nconst TG_TEST_CHAT_ID = '-1003640743827';\n\n// !!! Поставьте реальные имена узлов:\nconst FILTER_NODE_NAME = 'Filter1';\nconst POSTGRES_NODE_NAME = 'Postgre_store_extract';\nconst COOP_FACT_NODE_NAME = 'GS_CoopFact_GetRows'; // NEW\n\n// Telegram deep-link base\nconst TG_OLD_BOT_BASE = 'https://t.me/kooptorg3_start_bot?start=';\n\nfunction regionToStoreTz(region) {\n  if (Number(region) === 54) return 7;\n  if (Number(region) === 82) return 3;\n  return null;\n}\n\nfunction regionToTzName(region) {\n  if (Number(region) === 54) return 'Asia/Novosibirsk';\n  if (Number(region) === 82) return 'Europe/Simferopol';\n  return 'Europe/Moscow';\n}\n\nfunction escapeHtml(s) {\n  return String(s ?? '')\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;');\n}\n\n// минимально достаточное экранирование MarkdownV2\nfunction escapeMarkdownV2(s) {\n  // Telegram MarkdownV2 special chars: _ * [ ] ( ) ~ ` > # + - = | { } . !\n  return String(s ?? '').replace(/[_*[\\]()~`>#+\\-=|{}.!]/g, '\\\\$&');\n}\n\nfunction buildTgTextAndMode(post) {\n  let text = (post.text ?? '').toString();\n  let parseMode = 'HTML';\n\n  if (Number(post.parse_mode) === 1) {\n    parseMode = 'HTML';\n  } else if (Number(post.parse_mode) === 2) {\n    parseMode = 'MarkdownV2';\n  } else {\n    text = escapeHtml(text);\n    parseMode = 'HTML';\n  }\n\n  return { text, parse_mode: parseMode };\n}\n\n// old_post format: \"197_КУПИТЬ\"\nfunction parseOldPost(oldPostValue) {\n  const raw = (oldPostValue ?? '').toString().trim();\n  if (!raw) return null;\n\n  const m = raw.match(/^(\\d{3})_(.+)$/);\n  if (!m) return null;\n\n  const oldId = m[1];\n  const label = (m[2] ?? '').toString().trim();\n  if (!label) return null;\n\n  return { old_id: oldId, label: label.toUpperCase() };\n}\n\nfunction formatDDMMYYYYInTz(dateUtc, tzName) {\n  const parts = new Intl.DateTimeFormat('en-GB', {\n    timeZone: tzName,\n    day: '2-digit',\n    month: '2-digit',\n    year: 'numeric',\n  }).formatToParts(dateUtc);\n\n  const map = {};\n  for (const p of parts) if (p.type !== 'literal') map[p.type] = p.value;\n\n  return `${map.day}${map.month}${map.year}`;\n}\n\n// YYYY-MM-DD in TZ from UTC date\nfunction formatYYYYMMDDInTz(dateUtc, tzName) {\n  const parts = new Intl.DateTimeFormat('en-CA', {\n    timeZone: tzName,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n  }).formatToParts(dateUtc);\n\n  const map = {};\n  for (const p of parts) if (p.type !== 'literal') map[p.type] = p.value;\n\n  return `${map.year}-${map.month}-${map.day}`;\n}\n\nfunction buildOldLink({ old_id, label }, storeId, datePart, parseMode) {\n  const sid = String(storeId ?? '').trim();\n  if (!sid) return null;\n\n  // шаблон как в твоём примере: webapp_<oldId><DDMMYYYY><storeId>_<storeId>\n  const startParam = `webapp_${old_id}${datePart}${sid}_${sid}`;\n  const url = `${TG_OLD_BOT_BASE}${startParam}`;\n\n  if (parseMode === 'MarkdownV2') {\n    const textMd = escapeMarkdownV2(label);\n    // URL в MarkdownV2 лучше тоже экранировать минимум (скобки и т.п.)\n    const urlMd = url.replace(/\\)/g, '\\\\)').replace(/\\(/g, '\\\\(');\n    return `[${textMd}](${urlMd})`;\n  }\n\n  // HTML\n  const textHtml = escapeHtml(label);\n  const urlHtml = escapeHtml(url);\n  return `<a href=\"${urlHtml}\">${textHtml}</a>`;\n}\n\nfunction appendOldLinkToText(text, oldLink) {\n  const base = (text ?? '').toString();\n  if (!oldLink) return base;\n  if (!base.trim()) return oldLink;\n  return `${base}\\n\\n${oldLink}`;\n}\n\n// Ваш формат: store_195_Большевистская\nfunction pickStoreIdsFromRaw(raw) {\n  const ids = [];\n  for (const [k, v] of Object.entries(raw || {})) {\n    const key = String(k ?? '').trim();\n    const m = key.match(/^store_(\\d+)_/); // строго ваш формат\n    if (!m) continue;\n\n    const storeId = Number(m[1]);\n    if (!Number.isFinite(storeId)) continue;\n\n    const vv = (v ?? '').toString().trim();\n    if (vv === '1') ids.push(storeId);\n  }\n  return ids;\n}\n\nfunction cleanLine(s) {\n  return String(s ?? '')\n    .replace(/[\\uFEFF\\u200B\\u200C\\u200D\\u2060\\u00AD]/g, '')\n    .trim();\n}\n\n/**\n * media_raw format (each line):\n *   ф|https://...\n *   в|https://...\n * returns [{type:'photo'|'video', media:'url'}]\n */\nfunction parseMediaLines(mediaRaw) {\n  const raw = (mediaRaw ?? '').toString();\n  const lines = raw.split(/\\r\\n|\\n|\\r/g).map(cleanLine).filter(Boolean);\n\n  const out = [];\n  for (const line of lines) {\n    const m = line.match(/^([фв])\\|(.*)$/i);\n    if (!m) continue;\n\n    const kind = m[1].toLowerCase();\n    const url = cleanLine(m[2] || '');\n    if (!url) continue;\n\n    out.push({\n      type: kind === 'ф' ? 'photo' : 'video',\n      media: url,\n    });\n  }\n  return out;\n}\n\nfunction isCaptionOk(text) {\n  const t = (text ?? '').toString();\n  // caption limit ~1024; keep margin\n  return t.length > 0 && t.length <= 950;\n}\n\n// NEW: normalize COOP_FACT date to YYYY-MM-DD (supports 04/01/2026)\nfunction normalizeFactDate(v) {\n  const s = cleanLine(v);\n  if (!s) return null;\n\n  // YYYY-MM-DD\n  let m = s.match(/^(\\d{4})-(\\d{2})-(\\d{2})$/);\n  if (m) return `${m[1]}-${m[2]}-${m[3]}`;\n\n  // DD.MM.YYYY\n  m = s.match(/^(\\d{2})\\.(\\d{2})\\.(\\d{4})$/);\n  if (m) return `${m[3]}-${m[2]}-${m[1]}`;\n\n  // DD/MM/YYYY  (your format: 04/01/2026)\n  m = s.match(/^(\\d{2})\\/(\\d{2})\\/(\\d{4})$/);\n  if (m) {\n    const dd = Number(m[1]);\n    const mm = Number(m[2]);\n    const yyyy = Number(m[3]);\n    if (dd >= 1 && dd <= 31 && mm >= 1 && mm <= 12) {\n      const dds = String(dd).padStart(2, '0');\n      const mms = String(mm).padStart(2, '0');\n      return `${yyyy}-${mms}-${dds}`;\n    }\n  }\n\n  // Try Date.parse for ISO-ish values (not reliable for 04/01/2026, but ok for other strings)\n  const t = Date.parse(s);\n  if (!Number.isNaN(t)) {\n    const d = new Date(t);\n    const y = d.getUTCFullYear();\n    const mo = String(d.getUTCMonth() + 1).padStart(2, '0');\n    const da = String(d.getUTCDate()).padStart(2, '0');\n    return `${y}-${mo}-${da}`;\n  }\n\n  return null;\n}\n\n// get publish date (YYYY-MM-DD) in region TZ for GOODMORNING\nfunction getGoodMorningDateKey(post, tzName) {\n  // Prefer _occurrence_utc (for recurring). For one-time it will also be present in your Determine due.\n  const occIso = cleanLine(post._occurrence_utc);\n  if (occIso) {\n    const d = new Date(occIso);\n    if (!Number.isNaN(d.getTime())) return formatYYYYMMDDInTz(d, tzName);\n  }\n\n  // Fallback: parse from _occurrence_local / _publish_at_parsed (strings like \"YYYY-MM-DD ... (TZ)\")\n  const s1 = cleanLine(post._occurrence_local);\n  if (s1) {\n    const m = s1.match(/^(\\d{4}-\\d{2}-\\d{2})\\b/);\n    if (m) return m[1];\n  }\n\n  const s2 = cleanLine(post._publish_at_parsed);\n  if (s2) {\n    const m = s2.match(/^(\\d{4}-\\d{2}-\\d{2})\\b/);\n    if (m) return m[1];\n  }\n\n  // Last resort: if publish_at exists as \"YYYY-MM-DD ...\" without TZ\n  const s3 = cleanLine(post.publish_at);\n  if (s3) {\n    const m = s3.match(/^(\\d{4}-\\d{2}-\\d{2})\\b/);\n    if (m) return m[1];\n  }\n\n  return null;\n}\n\n// --- Забираем данные по имени узлов ---\nconst postsInput = $items(FILTER_NODE_NAME).map(x => x.json);\nconst storesInput = $items(POSTGRES_NODE_NAME).map(x => x.json);\nconst factsInput = $items(COOP_FACT_NODE_NAME).map(x => x.json);\n\n// Build facts map: YYYY-MM-DD -> fact\nconst factMap = new Map();\nfor (const row of factsInput) {\n  const dk = normalizeFactDate(row?.date);\n  const fact = cleanLine(row?.fact);\n  if (!dk || !fact) continue;\n  factMap.set(dk, row.fact); // keep last\n}\n\n// Диагностика stores\nconst tzSet = new Set();\nfor (const s of storesInput) {\n  if (s && s.time_zone !== undefined && s.time_zone !== null && s.time_zone !== '') {\n    tzSet.add(String(s.time_zone));\n  }\n}\nconst storesDebug = {\n  stores_count: storesInput.length,\n  stores_time_zones: Array.from(tzSet).sort(),\n  stores_first_keys: storesInput[0] ? Object.keys(storesInput[0]) : [],\n  facts_count: factsInput.length,\n  facts_keys_sample: Array.from(factMap.keys()).slice(0, 10),\n};\n\n// Если stores не пришли — вернём ошибку на каждый пост\nif (storesInput.length === 0) {\n  return postsInput.map(post => ({\n    json: {\n      ...post,\n      _tg_targets_empty: true,\n      _tg_targets_reason: `stores input is empty: $items(\"${POSTGRES_NODE_NAME}\") returned 0 rows`,\n      _stores_debug: storesDebug,\n\n      // важные служебные поля для дальнейшего апдейта Sheets\n      row_number: post?._raw?.row_number ?? null,\n      _now: post._now ?? null,\n      _now_utc: post._now_utc ?? null,\n      _run_key: post._run_key ?? null,\n    },\n  }));\n}\n\n// Map store_id -> storeRow\nconst storeMap = new Map();\nfor (const s of storesInput) {\n  const storeId = Number(s.store_id);\n  if (!Number.isFinite(storeId)) continue;\n  if (!storeMap.has(storeId)) storeMap.set(storeId, s);\n}\n\nconst out = [];\n\nfor (const post of postsInput) {\n  // Раньше тут было: if (!post.send_tg) continue;\n  // Теперь: пропускаем VK/SITE посты дальше одним item, а TG-развёртку делаем только когда send_tg=true\n\n  const hasAnyChannel = Boolean(post.send_tg || post.send_vk || post.send_site);\n  if (!hasAnyChannel) continue;\n\n  // --- протаскиваем row_number (для Update в Sheets) ---\n  const rowNumber = post?._raw?.row_number ?? null;\n\n  // --- протаскиваем служебные поля запуска (для last_run_*) ---\n  const nowLocal = post._now ?? null;      // локальное время региона (строка)\n  const nowUtcIso = post._now_utc ?? null; // ISO UTC\n  const runKey = post._run_key ?? null;\n\n  // --- GOODMORNING text override from COOP_FACT (общий, меняем post.text) ---\n  const tzName = regionToTzName(post.region);\n  let postForText = post;\n\n  if (post._goodmorning === true) {\n    const dateKey = getGoodMorningDateKey(post, tzName);\n    const fact = dateKey ? factMap.get(dateKey) : null;\n\n    if (!dateKey) {\n      out.push({\n        json: {\n          ...post,\n          row_number: rowNumber,\n          _now: nowLocal,\n          _now_utc: nowUtcIso,\n          _run_key: runKey,\n\n          _prepare_error: `GOODMORNING: cannot determine date key from occurrence/publish fields`,\n          _goodmorning_date_key: null,\n          _stores_debug: storesDebug,\n        },\n      });\n      continue;\n    }\n\n    if (!fact || !cleanLine(fact)) {\n      out.push({\n        json: {\n          ...post,\n          row_number: rowNumber,\n          _now: nowLocal,\n          _now_utc: nowUtcIso,\n          _run_key: runKey,\n\n          _prepare_error: `GOODMORNING: no fact found for date=${dateKey} in COOP_FACT`,\n          _goodmorning_date_key: dateKey,\n          _stores_debug: storesDebug,\n        },\n      });\n      continue;\n    }\n\n    postForText = {\n      ...post,\n      text: `${fact}\\n!!Навигация`,\n      _goodmorning_date_key: dateKey,\n    };\n  }\n  // --- /GOODMORNING ---\n\n  // === Если TG не нужен — просто пробрасываем item дальше (для VK/SITE) ===\n  if (!postForText.send_tg) {\n    out.push({\n      json: {\n        ...postForText,\n        row_number: rowNumber,\n        _now: nowLocal,\n        _now_utc: nowUtcIso,\n        _run_key: runKey,\n        _stores_debug: storesDebug,\n      },\n    });\n    continue;\n  }\n\n  // === TG часть (как было) ===\n  const tzNeed = regionToStoreTz(postForText.region);\n  if (tzNeed === null) {\n    out.push({\n      json: {\n        ...postForText,\n        row_number: rowNumber,\n        _now: nowLocal,\n        _now_utc: nowUtcIso,\n        _run_key: runKey,\n\n        _tg_targets_empty: true,\n        _tg_targets_reason: `unknown region=${postForText.region}`,\n        _stores_debug: storesDebug,\n      },\n    });\n    continue;\n  }\n\n  // store_id цели\n  let targetStoreIds = [];\n  if (postForText.all_region) {\n    for (const s of storesInput) {\n      if (Number(s.time_zone) === tzNeed) {\n        const id = Number(s.store_id);\n        if (Number.isFinite(id)) targetStoreIds.push(id);\n      }\n    }\n  } else {\n    targetStoreIds = pickStoreIdsFromRaw(postForText._raw);\n  }\n\n  targetStoreIds = Array.from(new Set(targetStoreIds));\n\n  if (targetStoreIds.length === 0) {\n    out.push({\n      json: {\n        ...postForText,\n        row_number: rowNumber,\n        _now: nowLocal,\n        _now_utc: nowUtcIso,\n        _run_key: runKey,\n\n        _tg_targets_empty: true,\n        _tg_targets_reason: postForText.all_region\n          ? `no stores found for time_zone=${tzNeed} (stores_count=${storesInput.length}, tzs=${storesDebug.stores_time_zones.join(',')})`\n          : 'no store columns selected in sheet row (no store_* = 1)',\n        _stores_debug: storesDebug,\n      },\n    });\n    continue;\n  }\n\n  const tgBase = buildTgTextAndMode(postForText);\n  const debugMode = Number(postForText.tg_debug) === 1;\n\n  // ---- parse media ----\n  const mediaRaw = (postForText.media_raw ?? postForText.media_url ?? postForText._raw?.media_raw ?? postForText._raw?.media_url ?? '').toString();\n  const mediaArr = parseMediaLines(mediaRaw);\n\n  // old_post parsing (only if present)\n  const oldParsed = parseOldPost(postForText.old_post ?? postForText._raw?.old_post);\n\n  // date part for old_link in region tz\n  const nowUtcObj = nowUtcIso ? new Date(nowUtcIso) : new Date();\n  const datePart = formatDDMMYYYYInTz(nowUtcObj, tzName);\n\n  // базовое решение по типу отправки (без учета caption длины — это сделаем per-store)\n  let baseOp = 'message'; // message | photo | video | media_group\n  let baseMedia = null;\n\n  if (mediaArr.length === 0) {\n    baseOp = 'message';\n  } else if (mediaArr.length === 1) {\n    baseOp = mediaArr[0].type === 'photo' ? 'photo' : 'video';\n    baseMedia = mediaArr[0].media;\n  } else {\n    baseOp = 'media_group';\n  }\n\n  const seenChat = new Set();\n  let produced = 0;\n\n  for (const storeId of targetStoreIds) {\n    const s = storeMap.get(storeId);\n    if (!s) continue;\n    if (Number(s.time_zone) !== tzNeed) continue;\n\n    const chatId = debugMode ? TG_TEST_CHAT_ID : s.channel_chat_id;\n    const chatKey = String(chatId);\n    if (seenChat.has(chatKey)) continue;\n    seenChat.add(chatKey);\n\n    // --- old link for this store (depends on storeId) ---\n    const oldLink = oldParsed ? buildOldLink(oldParsed, storeId, datePart, tgBase.parse_mode) : null;\n    const tgTextFinal = appendOldLinkToText(tgBase.text, oldLink);\n\n    // --- per-store media decision for albums: caption may be too long ---\n    let tgOp = baseOp;\n    let tgMedia = baseMedia;\n    let tgMediaGroup = null;\n    let needExtraTextMessage = false;\n\n    if (baseOp === 'media_group') {\n      tgMediaGroup = mediaArr;\n\n      if (isCaptionOk(tgTextFinal)) {\n        tgMediaGroup = tgMediaGroup.map((m, idx) => {\n          if (idx === 0) {\n            return {\n              ...m,\n              caption: tgTextFinal,\n              parse_mode: tgBase.parse_mode,\n            };\n          }\n          return m;\n        });\n      } else if (tgTextFinal.trim()) {\n        // caption слишком длинный — альбом без caption, а текст отдельным сообщением\n        needExtraTextMessage = true;\n      }\n    }\n\n    // 1) основной item\n    out.push({\n      json: {\n        ...postForText,\n\n        // служебные поля для апдейта Sheets\n        row_number: rowNumber,\n        _now: nowLocal,\n        _now_utc: nowUtcIso,\n        _run_key: runKey,\n\n        // данные цели\n        store_id: storeId,\n        store_description: s.store_description ?? null,\n\n        // routing for telegram\n        tg_op: tgOp,\n        tg_media: tgMedia,\n        tg_media_group: tgMediaGroup,\n\n        // old link debug\n        _old_post_parsed: oldParsed,\n        _old_post_date_ddmmyyyy: datePart,\n        _old_post_link: oldLink,\n\n        tg: {\n          chat_id: chatId,\n          text: tgTextFinal,\n          parse_mode: tgBase.parse_mode,\n          debug: debugMode,\n        },\n\n        _run_key_channel: runKey ? `${runKey}|store:${storeId}` : null,\n        _stores_debug: storesDebug,\n      },\n    });\n\n    produced++;\n\n    // 2) если альбом и текст длинный — отдельное сообщение текстом после альбома\n    if (tgOp === 'media_group' && needExtraTextMessage) {\n      out.push({\n        json: {\n          ...postForText,\n\n          row_number: rowNumber,\n          _now: nowLocal,\n          _now_utc: nowUtcIso,\n          _run_key: runKey,\n\n          store_id: storeId,\n          store_description: s.store_description ?? null,\n\n          tg_op: 'message',\n          tg_media: null,\n          tg_media_group: null,\n\n          // old link debug\n          _old_post_parsed: oldParsed,\n          _old_post_date_ddmmyyyy: datePart,\n          _old_post_link: oldLink,\n\n          tg: {\n            chat_id: chatId,\n            text: tgTextFinal,\n            parse_mode: tgBase.parse_mode,\n            debug: debugMode,\n          },\n\n          _run_key_channel: runKey ? `${runKey}|store:${storeId}|text_after_album` : null,\n          _stores_debug: storesDebug,\n        },\n      });\n    }\n  }\n\n  if (produced === 0) {\n    out.push({\n      json: {\n        ...postForText,\n        row_number: rowNumber,\n        _now: nowLocal,\n        _now_utc: nowUtcIso,\n        _run_key: runKey,\n\n        _tg_targets_empty: true,\n        _tg_targets_reason: `stores selected but none matched mapping for time_zone=${tzNeed} (stores_count=${storesInput.length}, tzs=${storesDebug.stores_time_zones.join(',')})`,\n        _stores_debug: storesDebug,\n      },\n    });\n  }\n}\n\nreturn out;\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[4176,2160],"id":"617eb794-ad1d-44d7-8378-e3e1f0985222","name":"Code in JavaScript2","onError":"continueRegularOutput"},{"parameters":{"chatId":"={{ $json.tg_chat_id }}","text":"={{ $json.tg_text }}","additionalFields":{"appendAttribution":false,"parse_mode":"={{ $json.tg_parse_mode }}"}},"type":"n8n-nodes-base.telegram","typeVersion":1.2,"position":[5120,1952],"id":"614c7d54-f62f-4c3a-b8b2-3dff1afb89ba","name":"Send a text message","webhookId":"3d5fc0f2-7e10-4bcb-9f24-3baaed55981d","alwaysOutputData":true,"credentials":{"telegramApi":{"id":"PvtTCKhw5iSNTNjL","name":"Telegram account"}},"onError":"continueRegularOutput"},{"parameters":{"operation":"executeQuery","query":"SELECT\n  s.store_id,\n  s.store_description,\n  s.time_zone,\n  MAX(sc.channel_chat_id) AS channel_chat_id,\n  MAX(sc.discussion_chat_id) AS discussion_chat_id\nFROM coop.order_store s\nJOIN coop.store_channel sc ON sc.store_id = s.store_id\nWHERE sc.channel_chat_id IS NOT NULL\n  AND s.time_zone IN (3, 7)\n  AND s.store_close_date IS NULL\nGROUP BY s.store_id, s.store_description, s.time_zone\nORDER BY s.time_zone, s.store_id;","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[3792,2304],"id":"81a440af-3bda-4a0e-89ba-dbd8d8f5ad5a","name":"Postgre_store_extract","executeOnce":true,"credentials":{"postgres":{"id":"Nn7xJ9wkuFYHFyvT","name":"Postgres account"}}},{"parameters":{"jsCode":"/**\n * Collect TG results per post_id (after Merge Combine/Position)\n * Supports:\n *  - Telegram nodes (they often return { ok:true, result:... } or set p.error on continueRegularOutput)\n *  - HTTP Request node (sendMediaGroup) which may return:\n *      - { statusCode: 200, body: { ok:true, result:[...] } }  (when JSON)\n *      - { statusCode: 200, body: \"...\" }                      (when string)\n *      - errors in p.error / p.message / p.response / p.body\n *\n * Output: one item per post_id with aggregation + Sheets update fields\n */\n\nconst items = $input.all();\n\nfunction safeStr(v) {\n  if (v === null || v === undefined) return '';\n  return String(v);\n}\n\nfunction toNumOrNull(v) {\n  if (v === null || v === undefined || v === '') return null;\n  const n = Number(v);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction appendLog(existing, line) {\n  const base = (existing ?? '').toString().trim();\n  if (!base) return line;\n  return base + '\\n' + line;\n}\n\nfunction tryJsonParse(s) {\n  try {\n    return JSON.parse(s);\n  } catch (e) {\n    return null;\n  }\n}\n\n// --- Detect ok for both Telegram node and HTTP Request node ---\nfunction detectOk(p) {\n  if (!p) return false;\n\n  // Telegram node common\n  if (p.ok === true || p.success === true) return true;\n\n  // HTTP Request node common shapes\n  // 1) response object\n  if (p.response && (p.response.ok === true || p.response.success === true)) return true;\n\n  // 2) body may be object or stringified json\n  const body = p.body ?? p.response?.body ?? null;\n  if (body && typeof body === 'object') {\n    if (body.ok === true) return true;\n    // sometimes nested\n    if (body.data?.ok === true) return true;\n  }\n  if (typeof body === 'string') {\n    const j = tryJsonParse(body);\n    if (j && j.ok === true) return true;\n  }\n\n  // 3) n8n httpRequest often exposes statusCode\n  const sc = p.statusCode ?? p.status ?? p.response?.statusCode ?? null;\n  if (typeof sc === 'number' && sc >= 200 && sc < 300) {\n    // If Telegram returns non-ok with 200, we'd have body.ok=false.\n    // But if we can't see body, treat 2xx as ok to avoid false FAIL logs.\n    return true;\n  }\n\n  return false;\n}\n\nfunction extractErrorText(p) {\n  if (!p) return 'unknown error';\n\n  // Telegram node error object\n  if (typeof p.error === 'string') return p.error;\n  if (p.error?.message) return safeStr(p.error.message);\n\n  // httpRequest node sometimes exposes errorMessage / message\n  if (p.errorMessage) return safeStr(p.errorMessage);\n  if (p.message) return safeStr(p.message);\n  if (p.description) return safeStr(p.description);\n  if (p.cause) return safeStr(p.cause);\n\n  // response/body shapes\n  const body = p.body ?? p.response?.body ?? p.responseBody ?? null;\n\n  if (body && typeof body === 'object') {\n    if (body.description) return safeStr(body.description);\n    if (body.error) return safeStr(body.error);\n    if (body.message) return safeStr(body.message);\n    if (body.ok === false && body.description) return safeStr(body.description);\n    try {\n      return JSON.stringify(body);\n    } catch (e) {\n      return 'unstringifiable body';\n    }\n  }\n\n  if (typeof body === 'string') {\n    const j = tryJsonParse(body);\n    if (j) {\n      if (j.description) return safeStr(j.description);\n      if (j.error) return safeStr(j.error);\n      if (j.message) return safeStr(j.message);\n      if (j.ok === false && j.description) return safeStr(j.description);\n      try {\n        return JSON.stringify(j);\n      } catch (e) {}\n    }\n    // raw string body\n    const s = body.trim();\n    if (s) return s.slice(0, 500);\n  }\n\n  // fallback stringify whole p.error if exists\n  if (p.error) {\n    try {\n      return JSON.stringify(p.error);\n    } catch (e) {\n      return 'unstringifiable error';\n    }\n  }\n\n  return 'unknown error';\n}\n\n// group per post_id\nconst byPost = new Map();\n\nfor (const item of items) {\n  const p = item.json || {};\n\n  const postId = p.post_id ?? p.id ?? null;\n  if (!postId) continue;\n\n  if (!byPost.has(postId)) {\n    byPost.set(postId, {\n      post_id: postId,\n      row_number: toNumOrNull(p.row_number),\n\n      last_run_key: p._run_key ?? null,\n      now_utc: p._now_utc ?? new Date().toISOString(),\n      now_local: p._now ?? null,\n\n      plan_run_at: p._plan_run_at ?? null,\n      prev_error: p.error_prev ?? null,\n\n      total: 0,\n      ok: 0,\n      fail: 0,\n      fails: [],\n    });\n  }\n\n  const agg = byPost.get(postId);\n\n  if (!agg.plan_run_at && p._plan_run_at) agg.plan_run_at = p._plan_run_at;\n\n  agg.total += 1;\n\n  const ok = detectOk(p);\n\n  const storeId = p.store_id ?? null;\n  const chatId = p.tg_chat_id ?? p.chat_id ?? null;\n\n  if (ok) {\n    agg.ok += 1;\n  } else {\n    agg.fail += 1;\n    const desc = extractErrorText(p);\n    agg.fails.push({\n      store_id: storeId,\n      chat_id: chatId,\n      desc: safeStr(desc),\n    });\n  }\n}\n\nconst out = [];\n\nfor (const agg of byPost.values()) {\n  // success only if at least one ok and no fails\n  const allOk = agg.fail === 0 && agg.ok > 0;\n\n  let newError = agg.prev_error;\n\n  if (allOk) {\n    newError = appendLog(\n      newError,\n      `[OK TG] ${agg.now_utc} key=${safeStr(agg.last_run_key)} sent=${agg.ok}/${agg.total}`\n    );\n  } else {\n    const failLines = agg.fails\n      .slice(0, 20)\n      .map(f => `store=${safeStr(f.store_id)} chat=${safeStr(f.chat_id)} err=${safeStr(f.desc)}`)\n      .join(' | ');\n\n    newError = appendLog(\n      newError,\n      `[FAIL TG] ${agg.now_utc} key=${safeStr(agg.last_run_key)} ok=${agg.ok}/${agg.total} fails=${agg.fail}` +\n        (failLines ? ` :: ${failLines}` : '')\n    );\n  }\n\n  out.push({\n    json: {\n      post_id: agg.post_id,\n      row_number: agg.row_number,\n\n      _all_ok: allOk,\n      _sent_ok: agg.ok,\n      _sent_fail: agg.fail,\n      _sent_total: agg.total,\n\n      update_last_run_at_utc: allOk ? agg.now_utc : null,\n      update_last_run_at: allOk ? agg.now_local : null,\n      update_last_run_key: allOk ? agg.last_run_key : null,\n\n      // write plan_run_at only on success\n      update_plan_run_at: allOk ? (agg.plan_run_at ?? null) : null,\n\n      update_error: newError,\n    },\n  });\n}\n\nreturn out;\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[5760,2032],"id":"98d40e8b-1228-40b7-b8b6-e9554671a83b","name":"Collect TG results"},{"parameters":{"assignments":{"assignments":[{"id":"1f3d5cad-548c-48bd-a374-ccdde7c4314f","name":"row_number","value":"={{$json.row_number}}","type":"number"},{"id":"254b0c02-3d0b-49ad-a8ca-7458f17209c3","name":"=post_id","value":"={{$json.id}}","type":"number"},{"id":"9afe30be-bf19-4af9-80fa-87e2353d83cc","name":"=_run_key","value":"={{$json._run_key}}","type":"string"},{"id":"1af1f314-8f5a-4a78-a072-f8d807c68e4d","name":"_now","value":"={{$json._now}}","type":"string"},{"id":"0aa65ec9-dd1e-4222-be13-933718236ee1","name":"_now_utc","value":"={{$json._now_utc}}","type":"string"},{"id":"640a3f9b-df58-45a7-8fbe-f29fa198bf8a","name":"store_id","value":"={{$json.store_id}}","type":"number"},{"id":"c02060fc-02fd-43b4-9c21-5b2a0a1f439b","name":"tg_chat_id","value":"={{$json.tg.chat_id}}","type":"string"},{"id":"6ab1367a-f53c-46cc-a263-d88103dbcc96","name":"tg_text","value":"={{$json.tg.text}}","type":"string"},{"id":"2b04009d-0cf0-47df-83fe-3209c35bf1ee","name":"tg_parse_mode","value":"={{$json.tg.parse_mode}}","type":"string"},{"id":"b9c1c913-0000-4295-88b0-9f32cd8d6d6b","name":"error_prev","value":"={{$json.error}}","type":"string"},{"id":"077dde57-5614-483b-afbe-504eec04fb67","name":"tg_op","value":"={{$json.tg_op}}","type":"string"},{"id":"2e21132e-99ed-4797-b9a9-373ab5b8ec2b","name":"tg_media","value":"={{$json.tg_media}}","type":"string"},{"id":"4fe678fe-b144-40d8-89d9-7037ede12a83","name":"tg_media_group_json","value":"={{ JSON.stringify($json.tg_media_group) }}","type":"string"},{"id":"f3930a07-f3c3-4722-a6e6-0bbb3ecddb35","name":"_old_post_link","value":"={{$json._old_post_link}}","type":"string"},{"id":"e0106ac8-b2bf-455d-81e8-ee4bfe5cd40a","name":"_plan_run_at","value":"={{$json._plan_run_at}}","type":"string"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[4480,2192],"id":"3fd86191-ec11-4da6-8192-1db3f790edfb","name":"Edit Fields"},{"parameters":{"mode":"combine","combineBy":"combineByPosition","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5280,1968],"id":"3266d860-5900-47bb-bbe2-84a9e5a691c0","name":"Merge"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"loose","version":3},"conditions":[{"id":"1de16de6-60be-47d0-85bb-be106d58e7e2","leftValue":"={{$json._all_ok}}","rightValue":"true","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"looseTypeValidation":true,"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.3,"position":[6672,2032],"id":"52ed79ce-4188-442b-9ec8-1db69e538f30","name":"If"},{"parameters":{"operation":"update","documentId":{"__rl":true,"value":"1FyEGxa6JYTJxDrowfgzAzroTM8L3CWCSY1rgI2DK9KQ","mode":"id"},"sheetName":{"__rl":true,"value":"POST","mode":"name"},"columns":{"mappingMode":"defineBelow","value":{"row_number":"={{$json.row_number}}","last_run_at_utc":"={{$json.update_last_run_at_utc}}","last_run_at":"={{$json.update_last_run_at}}","last_run_key":"={{$json.update_last_run_key}}","error":"={{$json.update_error}}","plan_run_at":"={{$json.update_plan_run_at}}"},"matchingColumns":["row_number"],"schema":[{"id":"id","displayName":"id","required":false,"defaultMatch":true,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"status","displayName":"status","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"region","displayName":"region","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"post_type","displayName":"post_type","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"tg_debug","displayName":"tg_debug","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"send_tg","displayName":"send_tg","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"send_vk","displayName":"send_vk","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"send_site","displayName":"send_site","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"old_post","displayName":"old_post","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"title","displayName":"title","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"media_url","displayName":"media_url","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"parse_mode","displayName":"parse_mode","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"text","displayName":"text","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"points_note_mode","displayName":"points_note_mode","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"all_region","displayName":"all_region","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_195_Большевистская","displayName":"store_195_Большевистская","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_191_Рябиновая","displayName":"store_191_Рябиновая","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_190_Золотодолинская","displayName":"store_190_Золотодолинская","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_174_Онега","displayName":"store_174_Онега","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_166_Станиславского","displayName":"store_166_Станиславского","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_186_Краснообск","displayName":"store_186_Краснообск","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_193_БердскВокзальная","displayName":"store_193_БердскВокзальная","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_160_Декабристов41","displayName":"store_160_Декабристов41","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_189_Ялта","displayName":"store_189_Ялта","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_211_Симферополь","displayName":"store_211_Симферополь","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"schedule","displayName":"schedule","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"publish_at","displayName":"publish_at","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"last_run_at_utc","displayName":"last_run_at_utc","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":false},{"id":"last_run_at","displayName":"last_run_at","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":false},{"id":"last_run_key","displayName":"last_run_key","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":false},{"id":"plan_run_at","displayName":"plan_run_at","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":false},{"id":"error","displayName":"error","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":false},{"id":"row_number","displayName":"row_number","required":false,"defaultMatch":false,"display":true,"type":"number","canBeUsedToMatch":true,"readOnly":true,"removed":false}],"attemptToConvertTypes":false,"convertFieldsToString":false},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[6944,1792],"id":"004c762c-9b70-46cd-a66e-13e8c0ca5690","name":"Update row in sheet","credentials":{"googleSheetsOAuth2Api":{"id":"b5DluHDjTyDAsQWd","name":"Google Sheets account"}}},{"parameters":{"operation":"update","documentId":{"__rl":true,"value":"1FyEGxa6JYTJxDrowfgzAzroTM8L3CWCSY1rgI2DK9KQ","mode":"id"},"sheetName":{"__rl":true,"value":"POST","mode":"name"},"columns":{"mappingMode":"defineBelow","value":{"row_number":"={{$json.row_number}}","error":"={{$json.update_error}}"},"matchingColumns":["row_number"],"schema":[{"id":"id","displayName":"id","required":false,"defaultMatch":true,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"status","displayName":"status","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"region","displayName":"region","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"post_type","displayName":"post_type","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"tg_debug","displayName":"tg_debug","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"send_tg","displayName":"send_tg","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"send_vk","displayName":"send_vk","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"send_site","displayName":"send_site","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"title","displayName":"title","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"media_url","displayName":"media_url","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"parse_mode","displayName":"parse_mode","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"text","displayName":"text","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"points_note_mode","displayName":"points_note_mode","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"all_region","displayName":"all_region","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_195_Большевистская","displayName":"store_195_Большевистская","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_191_Рябиновая","displayName":"store_191_Рябиновая","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_190_Золотодолинская","displayName":"store_190_Золотодолинская","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_174_Онега","displayName":"store_174_Онега","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_166_Станиславского","displayName":"store_166_Станиславского","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_186_Краснообск","displayName":"store_186_Краснообск","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_193_БердскВокзальная","displayName":"store_193_БердскВокзальная","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_160_Декабристов41","displayName":"store_160_Декабристов41","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_189_Ялта","displayName":"store_189_Ялта","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_211_Симферополь","displayName":"store_211_Симферополь","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"schedule","displayName":"schedule","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"last_run_at_utc","displayName":"last_run_at_utc","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"last_run_at","displayName":"last_run_at","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"last_run_key","displayName":"last_run_key","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"error","displayName":"error","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":false},{"id":"publish_at","displayName":"publish_at","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"row_number","displayName":"row_number","required":false,"defaultMatch":false,"display":true,"type":"number","canBeUsedToMatch":true,"readOnly":true,"removed":false}],"attemptToConvertTypes":false,"convertFieldsToString":false},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[6944,2224],"id":"4f393853-6ac9-436d-b2fe-6b8c5bf7277d","name":"Update row in sheet1","credentials":{"googleSheetsOAuth2Api":{"id":"b5DluHDjTyDAsQWd","name":"Google Sheets account"}}},{"parameters":{},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[3920,2080],"id":"9e196fa1-8e18-4929-b100-244ea48ed062","name":"Merge1"},{"parameters":{"rules":{"values":[{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"leftValue":"={{$json.tg_op}}","rightValue":"message","operator":{"type":"string","operation":"equals"},"id":"a889ad03-e512-413d-afc6-cb13b4d06e20"}],"combinator":"and"},"renameOutput":true,"outputKey":"Output 1"},{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"id":"3b373903-657f-4d1c-b292-d7e347a05ecb","leftValue":"={{$json.tg_op}}","rightValue":"photo","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"renameOutput":true,"outputKey":"Output 2"},{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"id":"ec2bd0f8-d963-46e1-b215-dac61c822773","leftValue":"={{$json.tg_op}}","rightValue":"video","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"renameOutput":true,"outputKey":"Output 3"},{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"id":"b0a65edb-b26b-43f5-a746-8ef43cc19e0c","leftValue":"={{$json.tg_op}}","rightValue":"media_group","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"renameOutput":true,"outputKey":"Output 4"}]},"options":{}},"type":"n8n-nodes-base.switch","typeVersion":3.4,"position":[4800,2176],"id":"0cd08b6e-7afe-4a0f-bd00-892229bc070c","name":"Switch"},{"parameters":{"operation":"sendPhoto","chatId":"={{$json.tg_chat_id}}","file":"={{$json.tg_media}}","additionalFields":{"caption":"={{$json.tg_text}}","parse_mode":"={{$json.tg_parse_mode}}"}},"type":"n8n-nodes-base.telegram","typeVersion":1.2,"position":[5136,2224],"id":"0e4f3a69-ada7-42df-a2cb-323936a8d4e0","name":"Send a photo message","webhookId":"34492d88-1440-48ed-a829-05e172507a26","alwaysOutputData":true,"notesInFlow":false,"credentials":{"telegramApi":{"id":"PvtTCKhw5iSNTNjL","name":"Telegram account"}},"onError":"continueRegularOutput"},{"parameters":{"mode":"combine","combineBy":"combineByPosition","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5296,2240],"id":"9c92626d-c533-4c5f-bb84-aa79165573fe","name":"Merge2"},{"parameters":{"operation":"sendVideo","chatId":"={{$json.tg_chat_id}}","file":"={{$json.tg_media}}","additionalFields":{"caption":"={{$json.tg_text}}","parse_mode":"={{$json.tg_parse_mode}}"}},"type":"n8n-nodes-base.telegram","typeVersion":1.2,"position":[5152,2432],"id":"ab32457d-188d-4f3c-bb27-e59a0ff616d5","name":"Send a video","webhookId":"e91b41a6-2e07-48f5-ad91-fdd4872f2b71","credentials":{"telegramApi":{"id":"PvtTCKhw5iSNTNjL","name":"Telegram account"}},"onError":"continueRegularOutput"},{"parameters":{"mode":"combine","combineBy":"combineByPosition","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5312,2448],"id":"06297003-0ed5-4028-9cab-070c1e22b659","name":"Merge3"},{"parameters":{"method":"POST","url":"https://api.telegram.org/bot8207832455:AAGzn7aGpClD91WdqE5Mcx6nhVw8R5tLXCk/sendMediaGroup","sendBody":true,"bodyParameters":{"parameters":[{"name":"chat_id","value":"={{$json.tg_chat_id}}"},{"name":"media","value":"={{$json.tg_media_group_json}}"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[5152,2784],"id":"671ca97a-6937-434f-b197-ba32d2691ecb","name":"HTTP Request","onError":"continueRegularOutput"},{"parameters":{"mode":"combine","combineBy":"combineByPosition","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5296,2784],"id":"8b5fe576-4ad6-4ef1-9534-5701145e20e9","name":"Merge4"},{"parameters":{"numberInputs":4},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5536,2048],"id":"7f0144ff-dffb-42e3-837f-5a7e54eaf3bf","name":"Merge5"},{"parameters":{"documentId":{"__rl":true,"value":"1FyEGxa6JYTJxDrowfgzAzroTM8L3CWCSY1rgI2DK9KQ","mode":"id"},"sheetName":{"__rl":true,"value":"COOP_FACT","mode":"name"},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[3792,1776],"id":"c1abfdda-a464-4648-a18a-20e7c6d4e1b9","name":"GS_CoopFact_GetRows","executeOnce":true,"credentials":{"googleSheetsOAuth2Api":{"id":"b5DluHDjTyDAsQWd","name":"Google Sheets account"}}},{"parameters":{},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[4048,1904],"id":"1113f9ed-5b68-4b8e-b34f-a836ef68ca15","name":"Merge_Facts_Barrier"},{"parameters":{"jsCode":"function regionToTz(region) {\n  if (region === 54) return 'Asia/Novosibirsk';\n  if (region === 82) return 'Europe/Simferopol';\n  return 'Europe/Moscow';\n}\n\nfunction cleanLine(s) {\n  return String(s ?? '')\n    .replace(/[\\uFEFF\\u200B\\u200C\\u200D\\u2060\\u00AD]/g, '')\n    .trim();\n}\n\nfunction formatLocalHuman(utcDate, tz) {\n  const dtf = new Intl.DateTimeFormat('en-CA', {\n    timeZone: tz,\n    hour12: false,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n  });\n\n  const parts = dtf.formatToParts(utcDate);\n  const map = {};\n  for (const p of parts) if (p.type !== 'literal') map[p.type] = p.value;\n\n  // пробел вместо T — людям проще\n  return `${map.year}-${map.month}-${map.day} ${map.hour}:${map.minute}:${map.second} (${tz})`;\n}\n\n// FIX: принимаем 1-2 цифры для часа (и для minutes/seconds тоже позволим 1-2 на всякий случай)\nfunction parseLocal(value) {\n  const s = cleanLine(value);\n  if (!s) return null;\n\n  // 0) YYYYMMDDTHHMMSS или YYYYMMDDTHHMM\n  let m = s.match(/^(\\d{4})(\\d{2})(\\d{2})T(\\d{1,2})(\\d{1,2})(\\d{1,2})?$/);\n  if (m) {\n    const [_, Y, M, D, h, min, sec] = m;\n    const hh = Number(h);\n    const mm = Number(min);\n    const ss = sec ? Number(sec) : 0;\n    if (!Number.isFinite(hh) || !Number.isFinite(mm) || !Number.isFinite(ss)) return null;\n    if (hh < 0 || hh > 23 || mm < 0 || mm > 59 || ss < 0 || ss > 59) return null;\n    return { Y: +Y, M: +M, D: +D, h: hh, min: mm, s: ss };\n  }\n\n  // 1) YYYY-MM-DD HH:mm(:ss)\n  m = s.match(/^(\\d{4})-(\\d{2})-(\\d{2})[ T](\\d{1,2}):(\\d{1,2})(?::(\\d{1,2}))?$/);\n  if (m) {\n    const [_, Y, M, D, h, min, sec] = m;\n    const hh = Number(h);\n    const mm = Number(min);\n    const ss = sec ? Number(sec) : 0;\n    if (!Number.isFinite(hh) || !Number.isFinite(mm) || !Number.isFinite(ss)) return null;\n    if (hh < 0 || hh > 23 || mm < 0 || mm > 59 || ss < 0 || ss > 59) return null;\n    return { Y: +Y, M: +M, D: +D, h: hh, min: mm, s: ss };\n  }\n\n  // 2) DD.MM.YYYY HH:mm(:ss)\n  m = s.match(/^(\\d{2})\\.(\\d{2})\\.(\\d{4})[ T](\\d{1,2}):(\\d{1,2})(?::(\\d{1,2}))?$/);\n  if (m) {\n    const [_, D, M, Y, h, min, sec] = m;\n    const hh = Number(h);\n    const mm = Number(min);\n    const ss = sec ? Number(sec) : 0;\n    if (!Number.isFinite(hh) || !Number.isFinite(mm) || !Number.isFinite(ss)) return null;\n    if (hh < 0 || hh > 23 || mm < 0 || mm > 59 || ss < 0 || ss > 59) return null;\n    return { Y: +Y, M: +M, D: +D, h: hh, min: mm, s: ss };\n  }\n\n  return null;\n}\n\nfunction isIsoLike(value) {\n  const s = cleanLine(value);\n  return /T/.test(s) || /Z$/.test(s) || /[+-]\\d{2}:\\d{2}$/.test(s);\n}\n\nfunction tzOffsetMinutesAt(utcDate, timeZone) {\n  const dtf = new Intl.DateTimeFormat('en-US', {\n    timeZone,\n    hour12: false,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n  });\n\n  const parts = dtf.formatToParts(utcDate);\n  const map = {};\n  for (const p of parts) if (p.type !== 'literal') map[p.type] = p.value;\n\n  const asIfUtc = Date.UTC(\n    Number(map.year),\n    Number(map.month) - 1,\n    Number(map.day),\n    Number(map.hour),\n    Number(map.minute),\n    Number(map.second),\n  );\n\n  const offsetMs = asIfUtc - utcDate.getTime();\n  return Math.round(offsetMs / 60000);\n}\n\nfunction dateFromLocalInTz(local, timeZone) {\n  const approxUtc = new Date(Date.UTC(local.Y, local.M - 1, local.D, local.h, local.min, local.s, 0));\n\n  const offsetMin1 = tzOffsetMinutesAt(approxUtc, timeZone);\n\n  let utcMs = approxUtc.getTime() - offsetMin1 * 60000;\n  let utcDate = new Date(utcMs);\n\n  const offsetMin2 = tzOffsetMinutesAt(utcDate, timeZone);\n  if (offsetMin2 !== offsetMin1) {\n    utcMs = approxUtc.getTime() - offsetMin2 * 60000;\n    utcDate = new Date(utcMs);\n  }\n\n  return utcDate;\n}\n\nfunction parseDateTimeByTz(value, timeZone) {\n  const v = cleanLine(value);\n  if (!v) return null;\n\n  // ISO со смещением/UTC — парсим напрямую\n  if (isIsoLike(v)) {\n    const iso = Date.parse(v);\n    return Number.isNaN(iso) ? null : new Date(iso);\n  }\n\n  // Иначе — локальное время TZ\n  const local = parseLocal(v);\n  if (!local) return null;\n\n  return dateFromLocalInTz(local, timeZone);\n}\n\nfunction parseDateTimeByRegion(value, region) {\n  const tz = regionToTz(region);\n  return parseDateTimeByTz(value, tz);\n}\n\n// ---------------- schedule mini DSL ----------------\n\n/**\n * IMPORTANT FIX:\n * Раньше мы \"расщепляли\" весь schedule по ';', из-за чего RRULE разваливался,\n * и BYDAY часто терялся (становился null).\n *\n * Теперь:\n * - НИКОГДА не делим весь текст по ';'\n * - Ищем строки DTSTART / RRULE / TZ / UNTIL по всему тексту\n * - ';' используем только внутри rruleRaw (rruleRaw.split(';'))\n */\nfunction parseSchedule(scheduleText) {\n  const raw0 = (scheduleText ?? '').toString();\n  const raw = raw0.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n  if (!cleanLine(raw)) return { ok: false, error: 'schedule empty' };\n\n  const findVal = (key) => {\n    const re = new RegExp(`(?:^|\\\\n)\\\\s*${key}(?:;[^:=]*)?\\\\s*[:=]\\\\s*(.+?)\\\\s*(?=\\\\n|$)`, 'i');\n    const m = raw.match(re);\n    return m ? cleanLine(m[1]) : null;\n  };\n\n  const tz = findVal('TZ');\n  const dtstartRaw = findVal('DTSTART');\n  const rruleRaw = findVal('RRULE');\n  const untilRaw = findVal('UNTIL');\n\n  if (!dtstartRaw) return { ok: false, error: 'DTSTART missing' };\n  if (!rruleRaw) return { ok: false, error: 'RRULE missing' };\n\n  const props = {};\n  for (const part0 of rruleRaw.split(';')) {\n    const part = cleanLine(part0);\n    if (!part) continue;\n\n    const eq = part.indexOf('=');\n    if (eq <= 0) continue;\n\n    const k = cleanLine(part.slice(0, eq)).toUpperCase();\n    const v = cleanLine(part.slice(eq + 1));\n    if (!k || v == null) continue;\n\n    props[k] = v;\n  }\n\n  const freq = (props.FREQ || '').toUpperCase();\n  if (!['DAILY', 'WEEKLY', 'MONTHLY'].includes(freq)) {\n    return { ok: false, error: `Unsupported FREQ=${props.FREQ || ''}` };\n  }\n\n  const interval = props.INTERVAL ? Math.max(1, Number(props.INTERVAL)) : 1;\n  const count = props.COUNT ? Math.max(1, Number(props.COUNT)) : null;\n  const untilStr = props.UNTIL || untilRaw || null;\n\n  const byday = props.BYDAY\n    ? props.BYDAY.split(',').map(s => cleanLine(s).toUpperCase()).filter(Boolean)\n    : null;\n\n  const byhour = props.BYHOUR != null\n    ? props.BYHOUR.split(',').map(x => Number(cleanLine(x)))\n    : null;\n\n  const byminute = props.BYMINUTE != null\n    ? props.BYMINUTE.split(',').map(x => Number(cleanLine(x)))\n    : null;\n\n  return { ok: true, tz, dtstartRaw, freq, interval, count, untilStr, byday, byhour, byminute, raw: { rruleRaw, scheduleRaw: raw } };\n}\n\nfunction formatPartsYMDInTz(utcDate, tz) {\n  const parts = new Intl.DateTimeFormat('en-US', {\n    timeZone: tz,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n  }).formatToParts(utcDate);\n\n  const map = {};\n  for (const p of parts) if (p.type !== 'literal') map[p.type] = p.value;\n\n  return { y: Number(map.year), m: Number(map.month), d: Number(map.day) };\n}\n\nfunction localYmdHmsToUtc(y, m, d, hh, mm, ss, tz) {\n  return dateFromLocalInTz({ Y: y, M: m, D: d, h: hh, min: mm, s: ss }, tz);\n}\n\nfunction addDaysUtc(date, days) {\n  return new Date(date.getTime() + days * 86400000);\n}\n\nfunction addWeeksUtc(date, weeks) {\n  return addDaysUtc(date, weeks * 7);\n}\n\nfunction addMonthsUtc(date, months) {\n  const y = date.getUTCFullYear();\n  const m = date.getUTCMonth();\n  const d = date.getUTCDate();\n  const hh = date.getUTCHours();\n  const mm = date.getUTCMinutes();\n  const ss = date.getUTCSeconds();\n\n  const targetMonthIndex = m + months;\n  const targetY = y + Math.floor(targetMonthIndex / 12);\n  const targetM = ((targetMonthIndex % 12) + 12) % 12;\n\n  const lastDay = new Date(Date.UTC(targetY, targetM + 1, 0)).getUTCDate();\n  const clampedD = Math.min(d, lastDay);\n\n  return new Date(Date.UTC(targetY, targetM, clampedD, hh, mm, ss));\n}\n\nfunction makeRunKeyLocal(postId, tz, occurrenceUtc) {\n  const id = (postId ?? 'unknown').toString();\n  const local = new Intl.DateTimeFormat('en-CA', {\n    timeZone: tz,\n    hour12: false,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n  }).format(occurrenceUtc).replace(', ', ' ');\n  return `post:${id}|${tz}|${local}`;\n}\n\n/**\n * Stable weekday for a LOCAL date (y,m,d) in timezone tz.\n * We convert local noon to UTC and then format weekday in tz.\n * Noon avoids boundary issues around midnight and DST.\n * Returns two-letter codes: MO,TU,WE,TH,FR,SA,SU.\n */\nfunction weekdayFromLocalYmd(y, m, d, tz) {\n  const probeUtc = localYmdHmsToUtc(y, m, d, 12, 0, 0, tz);\n  const w = new Intl.DateTimeFormat('en-US', { timeZone: tz, weekday: 'short' })\n    .format(probeUtc)\n    .slice(0, 2)\n    .toUpperCase();\n  return w;\n}\n\nfunction findLastOccurrenceUtc({ tz, dtstartUtc, dtstartLocalParts, rule, untilUtc, nowUtc }) {\n  let windowStartUtc;\n  if (rule.freq === 'DAILY') windowStartUtc = new Date(nowUtc.getTime() - 40 * 86400000);\n  else if (rule.freq === 'WEEKLY') windowStartUtc = new Date(nowUtc.getTime() - 26 * 7 * 86400000);\n  else windowStartUtc = new Date(nowUtc.getTime() - 24 * 31 * 86400000);\n\n  if (windowStartUtc < dtstartUtc) windowStartUtc = dtstartUtc;\n  const windowEndUtc = nowUtc;\n\n  const defaultH = dtstartLocalParts.h;\n  const defaultM = dtstartLocalParts.min;\n  const defaultS = dtstartLocalParts.s;\n\n  const hours = rule.byhour && rule.byhour.length ? rule.byhour : [defaultH];\n  const minutes = rule.byminute && rule.byminute.length ? rule.byminute : [defaultM];\n\n  let last = null;\n  let produced = 0;\n  const maxProduced = 5000;\n\n  if (rule.freq === 'DAILY') {\n    let cursor = new Date(Date.UTC(\n      windowStartUtc.getUTCFullYear(),\n      windowStartUtc.getUTCMonth(),\n      windowStartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    const dt0 = new Date(Date.UTC(\n      dtstartUtc.getUTCFullYear(),\n      dtstartUtc.getUTCMonth(),\n      dtstartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    let diffDays = Math.floor((cursor.getTime() - dt0.getTime()) / 86400000);\n    if (diffDays < 0) diffDays = 0;\n    const mod = diffDays % rule.interval;\n    if (mod !== 0) cursor = addDaysUtc(cursor, rule.interval - mod);\n\n    while (cursor <= windowEndUtc && produced < maxProduced) {\n      const ymd = formatPartsYMDInTz(cursor, tz);\n\n      if (rule.byday && rule.byday.length) {\n        const localWday = weekdayFromLocalYmd(ymd.y, ymd.m, ymd.d, tz);\n        if (!rule.byday.includes(localWday)) {\n          cursor = addDaysUtc(cursor, rule.interval);\n          continue;\n        }\n      }\n\n      for (const hh of hours) {\n        for (const mm of minutes) {\n          const occUtc = localYmdHmsToUtc(ymd.y, ymd.m, ymd.d, hh, mm, defaultS, tz);\n          if (occUtc < dtstartUtc) continue;\n          if (untilUtc && occUtc > untilUtc) continue;\n          if (occUtc < windowStartUtc || occUtc > windowEndUtc) continue;\n\n          produced++;\n          if (rule.count && produced > rule.count) return last;\n\n          if (!last || occUtc > last) last = occUtc;\n          if (produced >= maxProduced) break;\n        }\n        if (produced >= maxProduced) break;\n      }\n\n      cursor = addDaysUtc(cursor, rule.interval);\n    }\n  }\n\n  if (rule.freq === 'WEEKLY') {\n    const dtLocalWday = weekdayFromLocalYmd(dtstartLocalParts.Y, dtstartLocalParts.M, dtstartLocalParts.D, tz);\n    const days = (rule.byday && rule.byday.length) ? rule.byday : [dtLocalWday];\n\n    let cursorWeekStart = new Date(Date.UTC(\n      windowStartUtc.getUTCFullYear(),\n      windowStartUtc.getUTCMonth(),\n      windowStartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    const dt0 = new Date(Date.UTC(\n      dtstartUtc.getUTCFullYear(),\n      dtstartUtc.getUTCMonth(),\n      dtstartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    let diffDays = Math.floor((cursorWeekStart.getTime() - dt0.getTime()) / 86400000);\n    if (diffDays < 0) diffDays = 0;\n    const diffWeeks = Math.floor(diffDays / 7);\n    const mod = diffWeeks % rule.interval;\n    if (mod !== 0) cursorWeekStart = addWeeksUtc(cursorWeekStart, rule.interval - mod);\n\n    while (cursorWeekStart <= windowEndUtc && produced < maxProduced) {\n      for (let i = 0; i < 7; i++) {\n        const dayUtc = addDaysUtc(cursorWeekStart, i);\n        const ymd = formatPartsYMDInTz(dayUtc, tz);\n        const localWday = weekdayFromLocalYmd(ymd.y, ymd.m, ymd.d, tz);\n\n        if (!days.includes(localWday)) continue;\n\n        for (const hh of hours) {\n          for (const mm of minutes) {\n            const occUtc = localYmdHmsToUtc(ymd.y, ymd.m, ymd.d, hh, mm, defaultS, tz);\n            if (occUtc < dtstartUtc) continue;\n            if (untilUtc && occUtc > untilUtc) continue;\n            if (occUtc < windowStartUtc || occUtc > windowEndUtc) continue;\n\n            produced++;\n            if (rule.count && produced > rule.count) return last;\n\n            if (!last || occUtc > last) last = occUtc;\n            if (produced >= maxProduced) break;\n          }\n          if (produced >= maxProduced) break;\n        }\n      }\n\n      cursorWeekStart = addWeeksUtc(cursorWeekStart, rule.interval);\n    }\n  }\n\n  if (rule.freq === 'MONTHLY') {\n    let cursor = dtstartUtc;\n    let iterations = 0;\n    const maxIter = 300;\n\n    while (cursor < windowStartUtc && iterations < maxIter) {\n      cursor = addMonthsUtc(cursor, rule.interval);\n      iterations++;\n    }\n\n    while (cursor <= windowEndUtc && iterations < maxIter && produced < maxProduced) {\n      const ymd = formatPartsYMDInTz(cursor, tz);\n\n      for (const hh of hours) {\n        for (const mm of minutes) {\n          const occUtc = localYmdHmsToUtc(ymd.y, ymd.m, ymd.d, hh, mm, defaultS, tz);\n          if (occUtc < dtstartUtc) continue;\n          if (untilUtc && occUtc > untilUtc) continue;\n          if (occUtc < windowStartUtc || occUtc > windowEndUtc) continue;\n\n          produced++;\n          if (rule.count && produced > rule.count) return last;\n\n          if (!last || occUtc > last) last = occUtc;\n          if (produced >= maxProduced) break;\n        }\n        if (produced >= maxProduced) break;\n      }\n\n      cursor = addMonthsUtc(cursor, rule.interval);\n      iterations++;\n    }\n  }\n\n  return last;\n}\n\n// NEW: find next occurrence strictly after nowUtc\nfunction findNextOccurrenceUtc({ tz, dtstartUtc, dtstartLocalParts, rule, untilUtc, nowUtc }) {\n  const windowStartUtc = nowUtc;\n  let windowEndUtc;\n  if (rule.freq === 'DAILY') windowEndUtc = new Date(nowUtc.getTime() + 60 * 86400000);\n  else if (rule.freq === 'WEEKLY') windowEndUtc = new Date(nowUtc.getTime() + 60 * 7 * 86400000);\n  else windowEndUtc = new Date(nowUtc.getTime() + 24 * 31 * 86400000);\n\n  if (untilUtc && untilUtc < windowEndUtc) windowEndUtc = untilUtc;\n\n  const defaultH = dtstartLocalParts.h;\n  const defaultM = dtstartLocalParts.min;\n  const defaultS = dtstartLocalParts.s;\n\n  const hours = rule.byhour && rule.byhour.length ? rule.byhour : [defaultH];\n  const minutes = rule.byminute && rule.byminute.length ? rule.byminute : [defaultM];\n\n  let best = null;\n  let produced = 0;\n  const maxProduced = 5000;\n\n  if (rule.freq === 'DAILY') {\n    let cursor = new Date(Date.UTC(\n      windowStartUtc.getUTCFullYear(),\n      windowStartUtc.getUTCMonth(),\n      windowStartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    const dt0 = new Date(Date.UTC(\n      dtstartUtc.getUTCFullYear(),\n      dtstartUtc.getUTCMonth(),\n      dtstartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    let diffDays = Math.floor((cursor.getTime() - dt0.getTime()) / 86400000);\n    if (diffDays < 0) diffDays = 0;\n    const mod = diffDays % rule.interval;\n    if (mod !== 0) cursor = addDaysUtc(cursor, rule.interval - mod);\n\n    while (cursor <= windowEndUtc && produced < maxProduced) {\n      const ymd = formatPartsYMDInTz(cursor, tz);\n\n      if (rule.byday && rule.byday.length) {\n        const localWday = weekdayFromLocalYmd(ymd.y, ymd.m, ymd.d, tz);\n        if (!rule.byday.includes(localWday)) {\n          cursor = addDaysUtc(cursor, rule.interval);\n          continue;\n        }\n      }\n\n      for (const hh of hours) {\n        for (const mm of minutes) {\n          const occUtc = localYmdHmsToUtc(ymd.y, ymd.m, ymd.d, hh, mm, defaultS, tz);\n          if (occUtc < dtstartUtc) continue;\n          if (untilUtc && occUtc > untilUtc) continue;\n          if (occUtc <= windowStartUtc) continue;\n          if (occUtc > windowEndUtc) continue;\n\n          produced++;\n          if (rule.count && produced > rule.count) return best;\n\n          if (!best || occUtc < best) best = occUtc;\n          if (best) return best;\n        }\n      }\n\n      cursor = addDaysUtc(cursor, rule.interval);\n    }\n  }\n\n  if (rule.freq === 'WEEKLY') {\n    const dtLocalWday = weekdayFromLocalYmd(dtstartLocalParts.Y, dtstartLocalParts.M, dtstartLocalParts.D, tz);\n    const days = (rule.byday && rule.byday.length) ? rule.byday : [dtLocalWday];\n\n    let cursorWeekStart = new Date(Date.UTC(\n      windowStartUtc.getUTCFullYear(),\n      windowStartUtc.getUTCMonth(),\n      windowStartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    const dt0 = new Date(Date.UTC(\n      dtstartUtc.getUTCFullYear(),\n      dtstartUtc.getUTCMonth(),\n      dtstartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    let diffDays = Math.floor((cursorWeekStart.getTime() - dt0.getTime()) / 86400000);\n    if (diffDays < 0) diffDays = 0;\n    const diffWeeks = Math.floor(diffDays / 7);\n    const mod = diffWeeks % rule.interval;\n    if (mod !== 0) cursorWeekStart = addWeeksUtc(cursorWeekStart, rule.interval - mod);\n\n    while (cursorWeekStart <= windowEndUtc && produced < maxProduced) {\n      for (let i = 0; i < 7; i++) {\n        const dayUtc = addDaysUtc(cursorWeekStart, i);\n        const ymd = formatPartsYMDInTz(dayUtc, tz);\n        const localWday = weekdayFromLocalYmd(ymd.y, ymd.m, ymd.d, tz);\n\n        if (!days.includes(localWday)) continue;\n\n        for (const hh of hours) {\n          for (const mm of minutes) {\n            const occUtc = localYmdHmsToUtc(ymd.y, ymd.m, ymd.d, hh, mm, defaultS, tz);\n            if (occUtc < dtstartUtc) continue;\n            if (untilUtc && occUtc > untilUtc) continue;\n            if (occUtc <= windowStartUtc) continue;\n            if (occUtc > windowEndUtc) continue;\n\n            produced++;\n            if (rule.count && produced > rule.count) return best;\n\n            if (!best || occUtc < best) best = occUtc;\n            if (best) return best;\n          }\n        }\n      }\n\n      cursorWeekStart = addWeeksUtc(cursorWeekStart, rule.interval);\n    }\n  }\n\n  if (rule.freq === 'MONTHLY') {\n    let cursor = dtstartUtc;\n    let iterations = 0;\n    const maxIter = 300;\n\n    while (cursor <= windowStartUtc && iterations < maxIter) {\n      cursor = addMonthsUtc(cursor, rule.interval);\n      iterations++;\n    }\n\n    while (cursor <= windowEndUtc && iterations < maxIter && produced < maxProduced) {\n      const ymd = formatPartsYMDInTz(cursor, tz);\n\n      for (const hh of hours) {\n        for (const mm of minutes) {\n          const occUtc = localYmdHmsToUtc(ymd.y, ymd.m, ymd.d, hh, mm, defaultS, tz);\n          if (occUtc < dtstartUtc) continue;\n          if (untilUtc && occUtc > untilUtc) continue;\n          if (occUtc <= windowStartUtc) continue;\n          if (occUtc > windowEndUtc) continue;\n\n          produced++;\n          if (rule.count && produced > rule.count) return best;\n\n          if (!best || occUtc < best) best = occUtc;\n          if (best) return best;\n        }\n      }\n\n      cursor = addMonthsUtc(cursor, rule.interval);\n      iterations++;\n    }\n  }\n\n  return best;\n}\n\n// ---------------- main ----------------\n\nconst items = $input.all();\nconst nowUtc = new Date();\n\nreturn items.map(item => {\n  const p = item.json;\n\n  const tzRegion = regionToTz(p.region);\n\n  let due = false;\n  let reason = null;\n\n  // наружные поля\n  const nowLocal = formatLocalHuman(nowUtc, tzRegion);\n\n  let publishUtc = null;\n  let publishLocal = null;\n\n  let occurrenceUtc = null;\n  let occurrenceLocal = null;\n\n  let runKey = null;\n  let scheduleParsed = null;\n\n  // NEW plan\n  let planRunUtc = null;\n  let planRunLocal = null;\n\n  if (p.post_type === 2) {\n    publishUtc = parseDateTimeByRegion(p.publish_at, p.region);\n    publishLocal = publishUtc ? formatLocalHuman(publishUtc, tzRegion) : null;\n\n    if (!publishUtc) {\n      reason = 'one-time post without valid publish_at';\n    } else {\n      // для разового поста occurrence = publish_at\n      occurrenceUtc = publishUtc;\n      occurrenceLocal = formatLocalHuman(occurrenceUtc, tzRegion);\n\n      // формируем ключ заранее (антидубль как у регулярных)\n      runKey = makeRunKeyLocal(p.id, tzRegion, occurrenceUtc);\n\n      const alreadyKey = (p.last_run_key ?? '').toString().trim();\n      if (alreadyKey === runKey) {\n        due = false;\n        reason = 'one-time: already executed (last_run_key match)';\n      } else {\n        // запасной стопор по last_run_at_utc (если ключ почему-то не писался)\n        const lastRunAtUtc = p.last_run_at_utc ? new Date(p.last_run_at_utc) : null;\n        if (lastRunAtUtc && !isNaN(lastRunAtUtc.getTime())) {\n          if (lastRunAtUtc.getTime() >= occurrenceUtc.getTime() - 30 * 1000) {\n            due = false;\n            reason = 'one-time: already executed (last_run_at_utc >= publish_at)';\n          } else if (publishUtc <= nowUtc) {\n            due = true;\n            reason = 'due now (publish_at <= now) in region tz';\n          } else {\n            due = false;\n            reason = 'not yet (publish_at in future) in region tz';\n          }\n        } else {\n          if (publishUtc <= nowUtc) {\n            due = true;\n            reason = 'due now (publish_at <= now) in region tz';\n          } else {\n            due = false;\n            reason = 'not yet (publish_at in future) in region tz';\n          }\n        }\n      }\n    }\n  } else if (p.post_type === 1) {\n    if (!p.schedule) {\n      reason = 'regular post without schedule';\n    } else {\n      const parsed = parseSchedule(p.schedule);\n      if (!parsed.ok) {\n        reason = `schedule parse error: ${parsed.error}`;\n      } else {\n        const tz = parsed.tz || tzRegion;\n\n        const dtstartLocal = parseLocal(parsed.dtstartRaw);\n        if (!dtstartLocal) {\n          reason = 'DTSTART parse error';\n        } else {\n          const dtstartUtc = dateFromLocalInTz(dtstartLocal, tz);\n\n          let untilUtc = null;\n          if (parsed.untilStr) {\n            const u = parseDateTimeByTz(parsed.untilStr, tz);\n            if (!u) reason = 'UNTIL parse error';\n            else untilUtc = u;\n          }\n\n          if (!reason) {\n            const rule = {\n              freq: parsed.freq,\n              interval: parsed.interval,\n              count: parsed.count,\n              byday: parsed.byday,\n              byhour: parsed.byhour,\n              byminute: parsed.byminute,\n            };\n\n            scheduleParsed = {\n              tz,\n              dtstart_local: parsed.dtstartRaw,\n              dtstart_utc: dtstartUtc.toISOString(),\n              rule,\n              until_utc: untilUtc ? untilUtc.toISOString() : null,\n              raw: parsed.raw, // чтобы видеть rruleRaw/scheduleRaw в дебаге\n            };\n\n            const lastOcc = findLastOccurrenceUtc({\n              tz,\n              dtstartUtc,\n              dtstartLocalParts: dtstartLocal,\n              rule,\n              untilUtc,\n              nowUtc,\n            });\n\n            const nextOcc = findNextOccurrenceUtc({\n              tz,\n              dtstartUtc,\n              dtstartLocalParts: dtstartLocal,\n              rule,\n              untilUtc,\n              nowUtc,\n            });\n\n            if (nextOcc) {\n              planRunUtc = nextOcc;\n              planRunLocal = formatLocalHuman(nextOcc, tz);\n            } else {\n              planRunUtc = null;\n              planRunLocal = null;\n            }\n\n            if (!lastOcc) {\n              // FIX: корректная причина, когда DTSTART ещё не наступил (в будущем)\n              if (dtstartUtc > nowUtc) {\n                due = false;\n                reason = 'recurring: not yet started (DTSTART in future)';\n              } else {\n                // если DTSTART уже был в прошлом, но в lookback ничего не нашли\n                due = false;\n                reason = 'recurring: no occurrence found in lookback window';\n              }\n            } else {\n              occurrenceUtc = lastOcc;\n              occurrenceLocal = formatLocalHuman(occurrenceUtc, tz);\n              runKey = makeRunKeyLocal(p.id, tz, occurrenceUtc);\n\n              const alreadyKey = (p.last_run_key ?? '').toString().trim();\n              if (alreadyKey === runKey) {\n                due = false;\n                reason = 'recurring: already executed (last_run_key match)';\n              } else {\n                // secondary: last_run_at_utc (надежно парсится)\n                const lastRunAtUtc = p.last_run_at_utc ? new Date(p.last_run_at_utc) : null;\n                if (lastRunAtUtc && !isNaN(lastRunAtUtc.getTime())) {\n                  if (lastRunAtUtc.getTime() >= occurrenceUtc.getTime() - 30 * 1000) {\n                    due = false;\n                    reason = 'recurring: already executed (last_run_at_utc >= occurrence)';\n                  } else {\n                    due = true;\n                    reason = 'recurring: occurrence <= now and not executed';\n                  }\n                } else {\n                  due = true;\n                  reason = 'recurring: occurrence <= now and not executed';\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } else {\n    reason = 'unknown post_type';\n  }\n\n  return {\n    json: {\n      ...p,\n      _due: due,\n      _due_reason: reason,\n\n      // локальное отображение\n      _now: nowLocal,\n      _publish_at_parsed: publishLocal,\n      _occurrence_local: occurrenceLocal,\n\n      // UTC техничка (для записи)\n      _now_utc: nowUtc.toISOString(),\n      _occurrence_utc: occurrenceUtc ? occurrenceUtc.toISOString() : null,\n\n      _run_key: runKey,\n      _schedule_parsed: scheduleParsed,\n\n      // NEW: next planned run (for regular posts)\n      _plan_run_at: planRunLocal,\n      _plan_run_at_utc: planRunUtc ? planRunUtc.toISOString() : null,\n    },\n  };\n});\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[3440,2064],"id":"da9dc91f-4454-4b2c-abae-e8081ffea5dd","name":"Determine due"},{"parameters":{"rule":{"interval":[{"field":"minutes"}]}},"type":"n8n-nodes-base.scheduleTrigger","typeVersion":1.3,"position":[2480,2288],"id":"54277a7a-f068-4c15-8955-a83466390e99","name":"Schedule Trigger"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"loose","version":3},"conditions":[{"id":"d7859595-c40c-40cf-9885-a94c7a7296ba","leftValue":"={{$json.send_vk}}","rightValue":"true","operator":{"type":"boolean","operation":"true","singleValue":true}}],"combinator":"and"},"looseTypeValidation":true,"options":{}},"type":"n8n-nodes-base.filter","typeVersion":2.3,"position":[4448,1504],"id":"48ae628c-a97f-4dbf-905f-c17f7c0d4022","name":"Filter VK"},{"parameters":{"method":"POST","url":"https://api.vk.com/method/wall.post","sendBody":true,"contentType":"form-urlencoded","bodyParameters":{"parameters":[{"name":"owner_id","value":"=-114286850"},{"name":"from_group","value":"1"},{"name":"message","value":"={{$json.vk_message}}"},{"name":"access_token","value":"vk1.a.9nMQFYamjyb6V0wTTCDK_pi4ehFyFKa5c3ZLsizknn-4Vl0blAibzoQIy04vhvKoUmbOhVu7sKox2btvhT0ltZFsd5k97BjMGmlxSqb5YZnHc-_S6HN-o2XlkZQcM5lh5jmYRLupjGqKo2KfrO0EGLxgdEJrK6OeEp4NRcN0wDqVlWuAfUCGFZnBPUNbbbDq7kWuvJ4BmoLzbP8ZRzEHYQ"},{"name":"v","value":"5.131"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[5008,1392],"id":"23327244-ec97-41ef-b383-e2e0bb6349fd","name":"VK wall.post","onError":"continueRegularOutput"},{"parameters":{"jsCode":"/**\n * Collect VK results per post_id (after Merge Combine/Position)\n *\n * Supports VK API responses from HTTP Request node (wall.post), which typically return:\n *  - Success: { response: { post_id: 123, ... } }\n *  - Error:   { error: { error_code: 214, error_msg: \"...\", error_text: \"...\", request_params: [...] } }\n *\n * But n8n can wrap HTTP responses as:\n *  - { statusCode: 200, body: { response:{...} } }  (when Response Format = JSON)\n *  - { statusCode: 200, body: \"...\" }              (string)\n *  - errors in p.error / p.message / p.response / p.body\n *\n * Output: one item per post_id with aggregation + Sheets update-like fields\n * (Note: do NOT write last_run_* here if you plan to require TG+VK together;\n *        you can still output vk_ok/vk_fail counts and update_error here.)\n */\n\nconst items = $input.all();\n\nfunction safeStr(v) {\n  if (v === null || v === undefined) return '';\n  return String(v);\n}\n\nfunction toNumOrNull(v) {\n  if (v === null || v === undefined || v === '') return null;\n  const n = Number(v);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction appendLog(existing, line) {\n  const base = (existing ?? '').toString().trim();\n  if (!base) return line;\n  return base + '\\n' + line;\n}\n\nfunction tryJsonParse(s) {\n  try {\n    return JSON.parse(s);\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction unwrapBody(p) {\n  // n8n HTTP Request may expose body at top-level or nested\n  const body = p?.body ?? p?.response?.body ?? p?.responseBody ?? null;\n\n  if (body && typeof body === 'object') return body;\n\n  if (typeof body === 'string') {\n    const j = tryJsonParse(body);\n    if (j && typeof j === 'object') return j;\n  }\n\n  // Sometimes response itself is the VK json\n  if (p && typeof p === 'object') {\n    if (p.response && typeof p.response === 'object') return p.response;\n    // if p has response/error at top-level, return p itself\n    if (p.response || p.error) return p;\n  }\n\n  return null;\n}\n\nfunction detectOk(p) {\n  if (!p) return false;\n\n  // Direct VK shape\n  if (p.response && typeof p.response === 'object' && (p.response.post_id || p.response.post_id === 0)) {\n    return true;\n  }\n\n  const b = unwrapBody(p);\n  if (b) {\n    if (b.response && typeof b.response === 'object' && (b.response.post_id || b.response.post_id === 0)) {\n      return true;\n    }\n    // VK sometimes returns \"response\": 1 for some methods, but wall.post should return object\n    if (typeof b.response === 'number' && b.response > 0) return true;\n  }\n\n  // Fallback: if statusCode is 2xx but VK error not visible, treat as ok (avoid false FAIL)\n  const sc = p.statusCode ?? p.status ?? p.response?.statusCode ?? null;\n  if (typeof sc === 'number' && sc >= 200 && sc < 300) {\n    const bb = b;\n    if (bb && bb.error) return false;\n    return true;\n  }\n\n  return false;\n}\n\nfunction extractErrorText(p) {\n  if (!p) return 'unknown error';\n\n  // n8n error object\n  if (typeof p.error === 'string') return p.error;\n  if (p.error?.message) return safeStr(p.error.message);\n  if (p.errorMessage) return safeStr(p.errorMessage);\n  if (p.message) return safeStr(p.message);\n  if (p.description) return safeStr(p.description);\n  if (p.cause) return safeStr(p.cause);\n\n  // VK error shape\n  const b = unwrapBody(p);\n  const errObj = b?.error ?? p?.error ?? null;\n\n  if (errObj && typeof errObj === 'object') {\n    const code = errObj.error_code ?? errObj.code ?? null;\n    const msg = errObj.error_msg ?? errObj.message ?? errObj.error_text ?? null;\n    if (code !== null || msg) {\n      return `vk_error${code !== null ? `#${safeStr(code)}` : ''}: ${safeStr(msg || 'unknown')}`.trim();\n    }\n    try {\n      return JSON.stringify(errObj);\n    } catch (e) {\n      return 'unstringifiable vk error';\n    }\n  }\n\n  // Raw body as string\n  const rawBody = p.body ?? p.response?.body ?? p.responseBody ?? null;\n  if (typeof rawBody === 'string') {\n    const s = rawBody.trim();\n    if (s) return s.slice(0, 500);\n  }\n\n  // Last resort\n  try {\n    return JSON.stringify(p).slice(0, 500);\n  } catch (e) {\n    return 'unknown error';\n  }\n}\n\nfunction extractVkPostId(p) {\n  const b = unwrapBody(p);\n  const direct = p?.response?.post_id ?? null;\n  if (direct !== null && direct !== undefined) return direct;\n\n  const pid = b?.response?.post_id ?? null;\n  if (pid !== null && pid !== undefined) return pid;\n\n  return null;\n}\n\n// group per post_id\nconst byPost = new Map();\n\nfor (const item of items) {\n  const p = item.json || {};\n\n  const postId = p.post_id ?? p.id ?? null;\n  if (!postId) continue;\n\n  if (!byPost.has(postId)) {\n    byPost.set(postId, {\n      post_id: postId,\n      row_number: toNumOrNull(p.row_number),\n\n      last_run_key: p._run_key ?? null,\n      now_utc: p._now_utc ?? new Date().toISOString(),\n      now_local: p._now ?? null,\n\n      plan_run_at: p._plan_run_at ?? null,\n      prev_error: p.error_prev ?? null,\n\n      total: 0,\n      ok: 0,\n      fail: 0,\n      fails: [],\n      vk_post_ids: [],\n    });\n  }\n\n  const agg = byPost.get(postId);\n\n  if (!agg.plan_run_at && p._plan_run_at) agg.plan_run_at = p._plan_run_at;\n\n  agg.total += 1;\n\n  const ok = detectOk(p);\n\n  if (ok) {\n    agg.ok += 1;\n    const vkPid = extractVkPostId(p);\n    if (vkPid !== null && vkPid !== undefined) agg.vk_post_ids.push(vkPid);\n  } else {\n    agg.fail += 1;\n    const desc = extractErrorText(p);\n    agg.fails.push({ desc: safeStr(desc) });\n  }\n}\n\nconst out = [];\n\nfor (const agg of byPost.values()) {\n  // success only if at least one ok and no fails\n  const allOk = agg.fail === 0 && agg.ok > 0;\n\n  let newError = agg.prev_error;\n\n  if (allOk) {\n    const vkInfo = agg.vk_post_ids.length ? ` vk_post_id=${safeStr(agg.vk_post_ids[0])}` : '';\n    newError = appendLog(\n      newError,\n      `[OK VK] ${agg.now_utc} key=${safeStr(agg.last_run_key)} sent=${agg.ok}/${agg.total}${vkInfo}`\n    );\n  } else {\n    const failLines = agg.fails\n      .slice(0, 20)\n      .map(f => `err=${safeStr(f.desc)}`)\n      .join(' | ');\n\n    newError = appendLog(\n      newError,\n      `[FAIL VK] ${agg.now_utc} key=${safeStr(agg.last_run_key)} ok=${agg.ok}/${agg.total} fails=${agg.fail}` +\n        (failLines ? ` :: ${failLines}` : '')\n    );\n  }\n\n  out.push({\n    json: {\n      post_id: agg.post_id,\n      row_number: agg.row_number,\n\n      _vk_all_ok: allOk,\n      _vk_sent_ok: agg.ok,\n      _vk_sent_fail: agg.fail,\n      _vk_sent_total: agg.total,\n\n      // Keep these in case you want final aggregator to decide.\n      update_last_run_at_utc: allOk ? agg.now_utc : null,\n      update_last_run_at: allOk ? agg.now_local : null,\n      update_last_run_key: allOk ? agg.last_run_key : null,\n\n      // write plan_run_at only on success\n      update_plan_run_at: allOk ? (agg.plan_run_at ?? null) : null,\n\n      update_error: newError,\n\n      // optional: useful for debugging\n      vk_post_ids: agg.vk_post_ids,\n    },\n  });\n}\n\nreturn out;\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[5712,1584],"id":"e635290b-7068-4a59-b45f-a1ae9afad1a4","name":"Collect VK results"},{"parameters":{"assignments":{"assignments":[{"id":"40cb9769-3d4e-4419-ba2d-1f2a143fc134","name":"row_number","value":"={{$json.row_number}}","type":"number"},{"id":"4a693b1b-a451-4be0-804e-dcea42cce4f1","name":"_run_key","value":"={{$json._run_key}}","type":"string"},{"id":"263354fa-7b27-48e5-b64f-e9782fe9f1c1","name":"_now","value":"{{$json._now}}","type":"string"},{"id":"800fee7f-bd57-43da-a970-c201ffd9f0d8","name":"error_prev","value":"={{$json.error}}","type":"string"},{"id":"d11608cf-910a-411d-86a7-b8de74c810b0","name":"vk_message","value":"={{$json.text}}","type":"string"},{"id":"a07aa251-a83a-4292-a9f6-c2791dcb2e72","name":"vk_owner_id","value":-114286850,"type":"number"},{"id":"c1320c28-2609-4d0a-81aa-a8913fd7433e","name":"_now_utc","value":"={{$json._now_utc}}","type":"string"},{"id":"e0226193-b507-45ff-8837-b96011bef7fb","name":"send_vk","value":"={{$json.send_vk}}","type":"boolean"},{"id":"6d495acc-0a1d-46cc-ba04-7a4b2f9b0cc6","name":"post_id","value":"={{$json.id}}","type":"number"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[4672,1360],"id":"70ba86bf-5bf0-44eb-a4c4-f8af42a5190c","name":"VK Edit Fields","onError":"continueRegularOutput"},{"parameters":{"mode":"combine","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5216,1568],"id":"4658838c-f52a-4b8a-868d-abe51f008109","name":"Merge VK"},{"parameters":{"jsCode":"// Loop over input items and add a new field called 'myNewField' to the JSON of each one\nfor (const item of $input.all()) {\n  item.json.myNewField = 1;\n}\n\nreturn $input.all();"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[5920,1584],"id":"359afbd4-caa0-4521-8727-d75a3c856528","name":"Code in JavaScript1"},{"parameters":{},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[6144,1872],"id":"095c68bc-584b-455a-a3c3-116cbf9c7865","name":"Merge6"},{"parameters":{"jsCode":"/**\n * Final Collect (TG + VK) per post_id\n *\n * Input: mixed items from:\n *  - Collect TG results (your existing code)\n *  - Collect VK results (code we added)\n *\n * Goal:\n *  - decide final _all_ok ONLY when all enabled channels succeeded\n *  - build one aggregated update_error log per post\n *  - output ONE item per post_id with fields for Google Sheets update:\n *      - update_last_run_at_utc / update_last_run_at / update_last_run_key / update_plan_run_at (ONLY if _all_ok)\n *      - update_error (always)\n *\n * IMPORTANT:\n *  - This node expects send_tg / send_vk to be present on at least one of incoming items.\n *    If they are missing, it will infer requirements from presence of TG/VK collector items.\n *    (Recommended: add send_tg and send_vk to both TG Edit Fields and VK Edit Fields so they survive to collectors.)\n */\n\nconst items = $input.all();\n\nfunction safeStr(v) {\n  if (v === null || v === undefined) return '';\n  return String(v);\n}\n\nfunction toBoolOrNull(v) {\n  if (v === null || v === undefined) return null;\n  if (typeof v === 'boolean') return v;\n  if (typeof v === 'number') return v !== 0;\n  const s = String(v).trim().toLowerCase();\n  if (s === '') return null;\n  if (s === '1' || s === 'true' || s === 'yes' || s === 'y') return true;\n  if (s === '0' || s === 'false' || s === 'no' || s === 'n') return false;\n  return null;\n}\n\nfunction toNumOrNull(v) {\n  if (v === null || v === undefined || v === '') return null;\n  const n = Number(v);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction appendLog(existing, line) {\n  const base = (existing ?? '').toString().trim();\n  if (!base) return line;\n  return base + '\\n' + line;\n}\n\nfunction isTgCollectorItem(p) {\n  // Your TG collector outputs: _sent_ok/_sent_fail/_sent_total and _all_ok\n  return p && (p._sent_total !== undefined || p._sent_ok !== undefined || p._sent_fail !== undefined);\n}\n\nfunction isVkCollectorItem(p) {\n  // VK collector outputs: _vk_sent_total/_vk_sent_ok/_vk_sent_fail and _vk_all_ok\n  return p && (p._vk_sent_total !== undefined || p._vk_sent_ok !== undefined || p._vk_sent_fail !== undefined);\n}\n\nfunction pickFirstNonEmpty(...vals) {\n  for (const v of vals) {\n    if (v === null || v === undefined) continue;\n    if (typeof v === 'string' && v.trim() === '') continue;\n    return v;\n  }\n  return null;\n}\n\n// Group per post_id\nconst byPost = new Map();\n\nfor (const item of items) {\n  const p = item.json || {};\n  const postId = p.post_id ?? p.id ?? null;\n  if (!postId) continue;\n\n  if (!byPost.has(postId)) {\n    byPost.set(postId, {\n      post_id: postId,\n\n      // common context\n      row_number: toNumOrNull(p.row_number),\n      now_utc: p.update_last_run_at_utc ?? p._now_utc ?? null,\n      now_local: p.update_last_run_at ?? p._now ?? null,\n      last_run_key: p.update_last_run_key ?? p._run_key ?? null,\n      plan_run_at: p.update_plan_run_at ?? p._plan_run_at ?? null,\n\n      // flags\n      send_tg: toBoolOrNull(p.send_tg),\n      send_vk: toBoolOrNull(p.send_vk),\n\n      // collector results\n      tg_seen: false,\n      tg_ok: null,\n      tg_ok_count: null,\n      tg_fail_count: null,\n      tg_total: null,\n\n      vk_seen: false,\n      vk_ok: null,\n      vk_ok_count: null,\n      vk_fail_count: null,\n      vk_total: null,\n\n      // logs\n      prev_error: p.error_prev ?? null,\n      tg_update_error: null,\n      vk_update_error: null,\n\n      // final error assembled later\n      final_error: null,\n    });\n  }\n\n  const agg = byPost.get(postId);\n\n  // keep row_number if missing\n  if (agg.row_number === null || agg.row_number === undefined) {\n    agg.row_number = toNumOrNull(p.row_number);\n  }\n\n  // keep best timestamps/keys/plan\n  agg.now_utc = pickFirstNonEmpty(agg.now_utc, p.update_last_run_at_utc, p._now_utc);\n  agg.now_local = pickFirstNonEmpty(agg.now_local, p.update_last_run_at, p._now);\n  agg.last_run_key = pickFirstNonEmpty(agg.last_run_key, p.update_last_run_key, p._run_key);\n  agg.plan_run_at = pickFirstNonEmpty(agg.plan_run_at, p.update_plan_run_at, p._plan_run_at);\n\n  // capture send flags if present anywhere\n  const st = toBoolOrNull(p.send_tg);\n  const sv = toBoolOrNull(p.send_vk);\n  if (st !== null) agg.send_tg = st;\n  if (sv !== null) agg.send_vk = sv;\n\n  // capture prev_error if present\n  if (p.error_prev !== undefined && p.error_prev !== null) agg.prev_error = p.error_prev;\n\n  // Determine if this is TG or VK collector item\n  if (isTgCollectorItem(p) || p._all_ok !== undefined) {\n    agg.tg_seen = true;\n    if (typeof p._all_ok === 'boolean') agg.tg_ok = p._all_ok;\n    agg.tg_ok_count = toNumOrNull(p._sent_ok);\n    agg.tg_fail_count = toNumOrNull(p._sent_fail);\n    agg.tg_total = toNumOrNull(p._sent_total);\n\n    // Collect TG log line from update_error (it includes prev + appended line)\n    // We'll extract the *new* TG line by taking the last line, but safest is to just keep update_error and\n    // later build final by appending BOTH TG and VK last lines if we can.\n    if (p.update_error) agg.tg_update_error = safeStr(p.update_error);\n  }\n\n  if (isVkCollectorItem(p) || p._vk_all_ok !== undefined) {\n    agg.vk_seen = true;\n    if (typeof p._vk_all_ok === 'boolean') agg.vk_ok = p._vk_all_ok;\n    agg.vk_ok_count = toNumOrNull(p._vk_sent_ok);\n    agg.vk_fail_count = toNumOrNull(p._vk_sent_fail);\n    agg.vk_total = toNumOrNull(p._vk_sent_total);\n\n    if (p.update_error) agg.vk_update_error = safeStr(p.update_error);\n  }\n\n  // If item isn't clearly TG/VK collector, but has update_error, still keep it as prev_error fallback\n  if (!agg.tg_update_error && !agg.vk_update_error && p.update_error) {\n    // Could be a prior step; treat as base log\n    agg.prev_error = p.update_error;\n  }\n}\n\n// Helper to get last line of a log string\nfunction lastLine(s) {\n  if (!s) return '';\n  const lines = String(s).split('\\n').map(x => x.trim()).filter(Boolean);\n  return lines.length ? lines[lines.length - 1] : '';\n}\n\nconst out = [];\n\nfor (const agg of byPost.values()) {\n  // Decide requirements:\n  // If send_tg/send_vk are unknown, infer from presence of collector items.\n  const reqTg = (agg.send_tg === null || agg.send_tg === undefined) ? agg.tg_seen : agg.send_tg;\n  const reqVk = (agg.send_vk === null || agg.send_vk === undefined) ? agg.vk_seen : agg.send_vk;\n\n  // Determine per-channel ok:\n  // If required but no collector result -> fail.\n  const tgOk = reqTg ? (agg.tg_ok === true) : true;\n  const vkOk = reqVk ? (agg.vk_ok === true) : true;\n\n  const allOk = tgOk && vkOk;\n\n  // Build final error:\n  // Start with prev_error, then append last TG line and last VK line if present.\n  // We use lastLine(...) because collector update_error already includes previous history.\n  let newError = agg.prev_error;\n\n  const tgLine = lastLine(agg.tg_update_error);\n  const vkLine = lastLine(agg.vk_update_error);\n\n  if (tgLine) newError = appendLog(newError, tgLine);\n  if (vkLine) newError = appendLog(newError, vkLine);\n\n  // If no prev_error and collectors didn't provide anything, still provide a minimal diagnostic.\n  if (!newError) {\n    newError = `[INFO] ${safeStr(agg.now_utc || new Date().toISOString())} no logs from collectors`;\n  }\n\n  out.push({\n    json: {\n      post_id: agg.post_id,\n      row_number: agg.row_number,\n\n      // final success only if all required channels succeeded\n      _all_ok: allOk,\n\n      // expose channel statuses for debugging\n      _req_tg: reqTg,\n      _req_vk: reqVk,\n      _tg_ok: agg.tg_ok,\n      _vk_ok: agg.vk_ok,\n\n      // optionally counts (may be null if not present)\n      _tg_sent_ok: agg.tg_ok_count,\n      _tg_sent_fail: agg.tg_fail_count,\n      _tg_sent_total: agg.tg_total,\n      _vk_sent_ok: agg.vk_ok_count,\n      _vk_sent_fail: agg.vk_fail_count,\n      _vk_sent_total: agg.vk_total,\n\n      // Sheets update fields (write only on final success)\n      update_last_run_at_utc: allOk ? (agg.now_utc ?? null) : null,\n      update_last_run_at: allOk ? (agg.now_local ?? null) : null,\n      update_last_run_key: allOk ? (agg.last_run_key ?? null) : null,\n      update_plan_run_at: allOk ? (agg.plan_run_at ?? null) : null,\n\n      update_error: newError,\n    },\n  });\n}\n\nreturn out;\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[6336,1872],"id":"92e91ea2-c9a7-4213-a4d6-707d50e1c0bd","name":"Final Collect"}],"connections":{"When clicking ‘Execute workflow’":{"main":[[{"node":"Get row(s) in sheet","type":"main","index":0}]]},"Get row(s) in sheet":{"main":[[{"node":"Filter","type":"main","index":0}]]},"Filter":{"main":[[{"node":"Code in JavaScript","type":"main","index":0}]]},"Code in JavaScript":{"main":[[{"node":"Determine due","type":"main","index":0}]]},"Filter1":{"main":[[{"node":"Postgre_store_extract","type":"main","index":0},{"node":"Merge1","type":"main","index":0},{"node":"GS_CoopFact_GetRows","type":"main","index":0}]]},"Code in JavaScript2":{"main":[[{"node":"Edit Fields","type":"main","index":0},{"node":"Filter VK","type":"main","index":0}]]},"Postgre_store_extract":{"main":[[{"node":"Merge1","type":"main","index":1}]]},"Send a text message":{"main":[[{"node":"Merge","type":"main","index":1}]]},"Edit Fields":{"main":[[{"node":"Switch","type":"main","index":0}]]},"Collect TG results":{"main":[[{"node":"Merge6","type":"main","index":1}]]},"Merge":{"main":[[{"node":"Merge5","type":"main","index":0}]]},"If":{"main":[[{"node":"Update row in sheet","type":"main","index":0}],[{"node":"Update row in sheet1","type":"main","index":0}]]},"Merge1":{"main":[[{"node":"Merge_Facts_Barrier","type":"main","index":1}]]},"Switch":{"main":[[{"node":"Send a text message","type":"main","index":0},{"node":"Merge","type":"main","index":0}],[{"node":"Send a photo message","type":"main","index":0},{"node":"Merge2","type":"main","index":0}],[{"node":"Send a video","type":"main","index":0},{"node":"Merge3","type":"main","index":0}],[{"node":"HTTP Request","type":"main","index":0},{"node":"Merge4","type":"main","index":0}]]},"Send a photo message":{"main":[[{"node":"Merge2","type":"main","index":1}]]},"Merge2":{"main":[[{"node":"Merge5","type":"main","index":1}]]},"Send a video":{"main":[[{"node":"Merge3","type":"main","index":1}]]},"Merge3":{"main":[[{"node":"Merge5","type":"main","index":2}]]},"HTTP Request":{"main":[[{"node":"Merge4","type":"main","index":1}]]},"Merge4":{"main":[[{"node":"Merge5","type":"main","index":3}]]},"Merge5":{"main":[[{"node":"Collect TG results","type":"main","index":0}]]},"GS_CoopFact_GetRows":{"main":[[{"node":"Merge_Facts_Barrier","type":"main","index":0}]]},"Merge_Facts_Barrier":{"main":[[{"node":"Code in JavaScript2","type":"main","index":0}]]},"Determine due":{"main":[[{"node":"Filter1","type":"main","index":0}]]},"Schedule Trigger":{"main":[[{"node":"Get row(s) in sheet","type":"main","index":0}]]},"Filter VK":{"main":[[{"node":"VK Edit Fields","type":"main","index":0}]]},"VK wall.post":{"main":[[{"node":"Merge VK","type":"main","index":0}]]},"VK Edit Fields":{"main":[[{"node":"VK wall.post","type":"main","index":0},{"node":"Merge VK","type":"main","index":1}]]},"Merge VK":{"main":[[{"node":"Collect VK results","type":"main","index":0}]]},"Collect VK results":{"main":[[{"node":"Code in JavaScript1","type":"main","index":0}]]},"Code in JavaScript1":{"main":[[{"node":"Merge6","type":"main","index":0}]]},"Merge6":{"main":[[{"node":"Final Collect","type":"main","index":0}]]},"Final Collect":{"main":[[{"node":"If","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","availableInMCP":false,"timeSavedMode":"fixed","callerPolicy":"workflowsFromSameOwner"},"staticData":{"node:Schedule Trigger":{"recurrenceRules":[]}},"meta":{"templateCredsSetupCompleted":true},"pinData":{},"versionId":"23debf83-4e68-4b56-86ff-0899eceacef7","activeVersionId":null,"versionCounter":109,"triggerCount":1,"tags":[],"shared":[{"updatedAt":"2026-01-03T11:38:42.869Z","createdAt":"2026-01-03T11:38:42.869Z","role":"workflow:owner","workflowId":"poTupu2jfIU7WPUA","projectId":"pN1dQC2QTiUB8OxN","project":{"updatedAt":"2026-01-03T09:50:23.589Z","createdAt":"2026-01-02T11:57:57.457Z","id":"pN1dQC2QTiUB8OxN","name":"Ilya Sukharev <retail.sukharev@yandex.ru>","type":"personal","icon":null,"description":null,"creatorId":"a8327288-747a-47c3-9f5f-b2070eff6d8c"}}]}