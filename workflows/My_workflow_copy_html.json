{"updatedAt":"2026-02-21T04:42:05.970Z","createdAt":"2026-02-15T06:39:42.542Z","id":"uIvq2iDo93iByPmt","name":"My workflow copy html","description":null,"active":false,"isArchived":false,"nodes":[{"parameters":{},"type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[1280,1856],"id":"c26b5c19-1759-42aa-94e7-d616499ac43a","name":"When clicking ‚ÄòExecute workflow‚Äô"},{"parameters":{"documentId":{"__rl":true,"mode":"id","value":"1FyEGxa6JYTJxDrowfgzAzroTM8L3CWCSY1rgI2DK9KQ"},"sheetName":{"__rl":true,"value":"POST","mode":"name"},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[2160,1936],"id":"8a2b5fb7-bfe0-425d-9475-9fd72ee5dc21","name":"Get row(s) in sheet","credentials":{"googleSheetsOAuth2Api":{"id":"b5DluHDjTyDAsQWd","name":"Google Sheets account"}}},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"id":"7ba9d3b4-0e56-48ca-bb39-4bd86db3fa75","leftValue":"={{ $json.status }}","rightValue":1,"operator":{"type":"number","operation":"equals"}},{"id":"7dec0f65-d16a-4c29-af5a-2e7bc76eb1a4","leftValue":"={{ $json.tg_debug }}","rightValue":1,"operator":{"type":"number","operation":"equals"}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.filter","typeVersion":2.3,"position":[2720,2048],"id":"34da2253-7a86-4911-bcaa-f0221f45a185","name":"Filter"},{"parameters":{"jsCode":"return items.map(item => {\n  const d = item.json;\n\n  const num = (v) => {\n    if (v === null || v === undefined || v === '') return null;\n    const n = Number(v);\n    return Number.isFinite(n) ? n : null;\n  };\n\n  const bool1 = (v) => num(v) === 1;\n\n  const strOrNull = (v) => {\n    const s = (v ?? '').toString().trim();\n    return s ? s : null;\n  };\n\n  const titleStr = (d.title ?? '').toString();\n  const titleNorm = titleStr.trim().toUpperCase();\n\n  // marker for \"GOODMORNING\" posts (text will be taken from COOP_FACT later in Expand per store)\n  const isGoodMorning = titleNorm === 'GOODMORNING';\n\n  return {\n    json: {\n      id: num(d.id),\n      status: num(d.status),\n      region: num(d.region),\n      post_type: num(d.post_type),\n\n      send_tg: bool1(d.send_tg),\n      send_max: bool1(d.send_max),\n      send_vk: bool1(d.send_vk),\n      send_site: bool1(d.send_site),\n\n      // debug flag for telegram routing (1 = send to test channel)\n      tg_debug: num(d.tg_debug),\n\n      title: titleStr,\n\n      // plain text (fallback)\n      text: d.text ?? '',\n\n      // ‚úÖ formatted HTML from Google Sheets (after merge)\n      text_html: strOrNull(d.text_html),\n\n      // 1 = HTML, 2 = MarkdownV2, else = fallback safe HTML later\n      parse_mode: num(d.parse_mode) ?? 0,\n\n      media_raw: d.media_url ?? '',\n\n      // NEW: raw order link (format \"Button title|https://...\")\n      order_link: strOrNull(d.order_link),\n\n      // NEW: TG invite experiment flag (if empty -> add invite footer later)\n      tg_inv_expt: strOrNull(d.tg_inv_expt),\n\n      // —Å—Ç–∞—Ä–∞—è –ª–æ–≥–∏–∫–∞: —Å—Å—ã–ª–∫–∞ –Ω–∞ –±–æ—Ç–∞ (—Ñ–æ—Ä–º–∞—Ç \"197_–ö–£–ü–ò–¢–¨\")\n      old_post: strOrNull(d.old_post),\n\n      all_region: bool1(d.all_region),\n      points_note_mode:\n        d.points_note_mode === '' || d.points_note_mode === null || d.points_note_mode === undefined\n          ? null\n          : (num(d.points_note_mode) ?? null),\n\n      schedule: strOrNull(d.schedule),\n      publish_at: strOrNull(d.publish_at),\n\n      // service fields\n      last_run_at_utc: strOrNull(d.last_run_at_utc),\n      last_run_at: strOrNull(d.last_run_at),\n      last_run_key: strOrNull(d.last_run_key),\n\n      error: strOrNull(d.error),\n\n      // flag for downstream logic\n      _goodmorning: isGoodMorning,\n\n      // –∏—Å—Ö–æ–¥–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ —Ü–µ–ª–∏–∫–æ–º (–≤–∫–ª—é—á–∞—è –∫–æ–ª–æ–Ω–∫–∏ —Ç–æ—á–µ–∫)\n      _raw: d,\n    },\n  };\n});"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[2896,2048],"id":"31c25f3a-a2ce-42cf-bc91-232059887789","name":"Code in JavaScript"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"id":"a642aa85-b884-4c19-a91b-7222a19570d1","leftValue":"={{ $json._due }}","rightValue":true,"operator":{"type":"boolean","operation":"equals"}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.filter","typeVersion":2.3,"position":[3280,2048],"id":"a9e92170-0fc5-428f-9d33-652efcd5f615","name":"Filter1"},{"parameters":{"jsCode":"// === –ù–ê–°–¢–†–û–ô–ö–ò ===\nconst TG_TEST_CHAT_ID = '-1003640743827';\nconst TG_TEST_FORCE_AUTH_TYPE_1 = true; // true => order_link, false => old_post\n\n// !!! –ü–æ—Å—Ç–∞–≤—å—Ç–µ —Ä–µ–∞–ª—å–Ω—ã–µ –∏–º–µ–Ω–∞ —É–∑–ª–æ–≤:\nconst FILTER_NODE_NAME = 'Filter1';\nconst POSTGRES_NODE_NAME = 'Postgre_store_extract';\nconst COOP_FACT_NODE_NAME = 'GS_CoopFact_GetRows'; // NEW\n\n// Telegram deep-link base\nconst TG_OLD_BOT_BASE = 'https://t.me/kooptorg3_start_bot?start=';\n\nfunction regionToStoreTz(region) {\n  if (Number(region) === 54) return 7;\n  if (Number(region) === 82) return 3;\n  return null;\n}\n\nfunction regionToTzName(region) {\n  if (Number(region) === 54) return 'Asia/Novosibirsk';\n  if (Number(region) === 82) return 'Europe/Simferopol';\n  return 'Europe/Moscow';\n}\n\nfunction escapeHtml(s) {\n  return String(s ?? '')\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;');\n}\n\n// –º–∏–Ω–∏–º–∞–ª—å–Ω–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–µ —ç–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ MarkdownV2\nfunction escapeMarkdownV2(s) {\n  // Telegram MarkdownV2 special chars: _ * [ ] ( ) ~ ` > # + - = | { } . !\n  return String(s ?? '').replace(/[_*[\\]()~`>#+\\-=|{}.!]/g, '\\\\$&');\n}\n// Telegram HTML supports a limited subset and DOES NOT support <br>. Convert it to newlines.\nfunction normalizeTelegramHtml(html) {\n  if (html === null || html === undefined) return '';\n\n  let s = String(html);\n\n  // <br> / <br/> / <br /> -> newline\n  s = s.replace(/<br\\s*\\/?>/gi, '\\n');\n\n  // Convert common block tags to newlines (open tags removed, close tags -> newline)\n  s = s.replace(/<\\/(p|div|h\\d|blockquote)>/gi, '\\n');\n  s = s.replace(/<(p|div|h\\d|blockquote)(\\s[^>]*)?>/gi, '');\n\n  // Optionally strip spans (sometimes produced by HTML converters)\n  s = s.replace(/<\\/?span(\\s[^>]*)?>/gi, '');\n\n  // Minimal entity cleanup\n  s = s.replace(/&nbsp;/gi, ' ');\n\n  // Cleanup excessive newlines\n  s = s.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n  s = s.replace(/\\n{3,}/g, '\\n\\n').trim();\n\n  return s;\n}\n\n\nfunction buildTgTextAndMode(post) {\n  const pm = Number(post.parse_mode);\n\n  // Plain text from sheet (fallback)\n  const textPlain = (post.text ?? '').toString();\n\n  // Formatted HTML from sheet (after Merge text_html into rows)\n  const textHtml = (post.text_html ?? '').toString();\n\n  if (pm === 2) {\n    // MarkdownV2: use plain text\n    return { text: textPlain, parse_mode: 'MarkdownV2' };\n  }\n\n  if (pm === 1) {\n    // HTML: prefer formatted text_html if present, but normalize for Telegram (no <br>, limited tags)\n    const tRaw = (textHtml && textHtml.trim()) ? textHtml : textPlain;\n    const t = normalizeTelegramHtml(tRaw);\n    return { text: t, parse_mode: 'HTML' };\n  }\n\n  // Fallback: safe HTML (escape)\n  return { text: escapeHtml(textPlain), parse_mode: 'HTML' };\n}\n\n// old_post format: \"197_–ö–£–ü–ò–¢–¨\"\nfunction parseOldPost(oldPostValue) {\n  const raw = (oldPostValue ?? '').toString().trim();\n  if (!raw) return null;\n\n  const m = raw.match(/^(\\d{3})_(.+)$/);\n  if (!m) return null;\n\n  const oldId = m[1];\n  const label = (m[2] ?? '').toString().trim();\n  if (!label) return null;\n\n  return { old_id: oldId, label: label.toUpperCase() };\n}\n\nfunction formatDDMMYYYYInTz(dateUtc, tzName) {\n  const parts = new Intl.DateTimeFormat('en-GB', {\n    timeZone: tzName,\n    day: '2-digit',\n    month: '2-digit',\n    year: 'numeric',\n  }).formatToParts(dateUtc);\n\n  const map = {};\n  for (const p of parts) if (p.type !== 'literal') map[p.type] = p.value;\n\n  return `${map.day}${map.month}${map.year}`;\n}\n\n// YYYY-MM-DD in TZ from UTC date\nfunction formatYYYYMMDDInTz(dateUtc, tzName) {\n  const parts = new Intl.DateTimeFormat('en-CA', {\n    timeZone: tzName,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n  }).formatToParts(dateUtc);\n\n  const map = {};\n  for (const p of parts) if (p.type !== 'literal') map[p.type] = p.value;\n\n  return `${map.year}-${map.month}-${map.day}`;\n}\n\nfunction buildOldLink({ old_id, label }, storeId, datePart, parseMode) {\n  const sid = String(storeId ?? '').trim();\n  if (!sid) return null;\n\n  // —à–∞–±–ª–æ–Ω –∫–∞–∫ –≤ —Ç–≤–æ—ë–º –ø—Ä–∏–º–µ—Ä–µ: webapp_<oldId><DDMMYYYY><storeId>_<storeId>\n  const startParam = `webapp_${old_id}${datePart}${sid}_${sid}`;\n  const url = `${TG_OLD_BOT_BASE}${startParam}`;\n\n  if (parseMode === 'MarkdownV2') {\n    const textMd = escapeMarkdownV2(label);\n    // URL –≤ MarkdownV2 –ª—É—á—à–µ —Ç–æ–∂–µ —ç–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –º–∏–Ω–∏–º—É–º (—Å–∫–æ–±–∫–∏ –∏ —Ç.–ø.)\n    const urlMd = url.replace(/\\)/g, '\\\\)').replace(/\\(/g, '\\\\(');\n    return `[${textMd}](${urlMd})`;\n  }\n\n  // HTML\n  const textHtml = escapeHtml(label);\n  const urlHtml = escapeHtml(url);\n  return `<a href=\"${urlHtml}\">${textHtml}</a>`;\n}\n\nfunction appendOldLinkToText(text, oldLink) {\n  const base = (text ?? '').toString();\n  if (!oldLink) return base;\n  if (!base.trim()) return oldLink;\n  return `${base}\\n\\n${oldLink}`;\n}\n\n// --- Invite footer helpers ---\nfunction cleanUrl(v) {\n  const s = String(v ?? '').trim();\n  return s ? s : null;\n}\n\nfunction buildLinkLabel(label, url, parseMode) {\n  if (!url) return null;\n\n  if (parseMode === 'MarkdownV2') {\n    const t = escapeMarkdownV2(label);\n    const u = String(url).replace(/\\)/g, '\\\\)').replace(/\\(/g, '\\\\(');\n    return `[${t}](${u})`;\n  }\n\n  // HTML\n  return `<a href=\"${escapeHtml(url)}\">${escapeHtml(label)}</a>`;\n}\n\n// UPDATED: labels without \"–Ω–∞ –∫–∞–Ω–∞–ª\"\nfunction buildInviteFooter(parseMode, tgUrl, maxUrl) {\n  const lines = [];\n\n  const tgLine = buildLinkLabel('üì¢ –ü–æ–¥–ø–∏—à–∏—Å—å –≤ Telegram', tgUrl, parseMode);\n  if (tgLine) lines.push(tgLine);\n\n  const maxLine = buildLinkLabel('‚ö° –ü–æ–¥–ø–∏—à–∏—Å—å –≤ MAX', maxUrl, parseMode);\n  if (maxLine) lines.push(maxLine);\n\n  return lines.length ? lines.join('\\n') : null;\n}\n\nfunction appendFooter(text, footer) {\n  const base = (text ?? '').toString();\n  if (!footer) return base;\n  if (!base.trim()) return footer;\n  return `${base}\\n\\n${footer}`;\n}\n\n// --- Order links as TEXT block (for Telegram post_auth_type=1) ---\nfunction buildOrderLinksText(orderLinks, parseMode) {\n  if (!Array.isArray(orderLinks) || orderLinks.length === 0) return null;\n\n  const lines = [];\n  for (const b of orderLinks) {\n    const t = cleanLine(b?.text);\n    const u = cleanLine(b?.url);\n    if (!t || !u) continue;\n\n    let link = buildLinkLabel(t, u, parseMode);\n    if (!link) continue;\n\n    // Make order_links bold in Telegram\n    if (parseMode === 'MarkdownV2') {\n      link = `**${link}**`;\n    } else {\n      // HTML\n      link = `<b>${link}</b>`;\n    }\n\n    lines.push(`‚Ä¢ ${link}`);\n  }\n\n  return lines.length ? lines.join('\\n') : null;\n}\n\nfunction appendOrderLinksToText(text, orderLinks, parseMode) {\n  const base = (text ?? '').toString();\n  const block = buildOrderLinksText(orderLinks, parseMode);\n  if (!block) return base;\n  if (!base.trim()) return block;\n  return `${base}\\n\\n${block}`;\n}\n\n// –í–∞—à —Ñ–æ—Ä–º–∞—Ç: store_195_–ë–æ–ª—å—à–µ–≤–∏—Å—Ç—Å–∫–∞—è\nfunction pickStoreIdsFromRaw(raw) {\n  const ids = [];\n  for (const [k, v] of Object.entries(raw || {})) {\n    const key = String(k ?? '').trim();\n    const m = key.match(/^store_(\\d+)_/); // —Å—Ç—Ä–æ–≥–æ –≤–∞—à —Ñ–æ—Ä–º–∞—Ç\n    if (!m) continue;\n\n    const storeId = Number(m[1]);\n    if (!Number.isFinite(storeId)) continue;\n\n    const vv = (v ?? '').toString().trim();\n    if (vv === '1') ids.push(storeId);\n  }\n  return ids;\n}\n\nfunction cleanLine(s) {\n  return String(s ?? '')\n    .replace(/[\\uFEFF\\u200B\\u200C\\u200D\\u2060\\u00AD]/g, '')\n    .trim();\n}\n\nfunction parseOrderLinks(orderLinkRaw) {\n  const raw = (orderLinkRaw ?? '').toString();\n  const lines = raw.split(/\\r\\n|\\n|\\r/g).map(cleanLine).filter(Boolean);\n\n  const out = [];\n  for (const line of lines) {\n    // Format: Button text|https://...\n    const parts = line.split('|');\n    if (parts.length < 2) continue;\n\n    const text = cleanLine(parts[0]);\n    const url = cleanLine(parts.slice(1).join('|')); // keep '|' inside URL if any\n\n    if (!text || !url) continue;\n\n    // minimal url sanity check\n    if (!/^https?:\\/\\//i.test(url)) continue;\n\n    out.push({ text, url });\n  }\n\n  return out.length ? out : null;\n}\n\n/**\n * media_raw format (each line):\n *   —Ñ|https://...\n *   –≤|https://...\n * returns [{type:'photo'|'video', media:'url'}]\n */\nfunction parseMediaLines(mediaRaw) {\n  const raw = (mediaRaw ?? '').toString();\n  const lines = raw.split(/\\r\\n|\\n|\\r/g).map(cleanLine).filter(Boolean);\n\n  const out = [];\n  for (const line of lines) {\n    const m = line.match(/^([—Ñ–≤])\\|(.*)$/i);\n    if (!m) continue;\n\n    const kind = m[1].toLowerCase();\n    const url = cleanLine(m[2] || '');\n    if (!url) continue;\n\n    out.push({\n      type: kind === '—Ñ' ? 'photo' : 'video',\n      media: url,\n    });\n  }\n  return out;\n}\n\nfunction isCaptionOk(text) {\n  const t = (text ?? '').toString();\n  // caption limit ~1024; keep margin\n  return t.length > 0 && t.length <= 950;\n}\n\n// NEW: normalize COOP_FACT date to YYYY-MM-DD (supports 04/01/2026)\nfunction normalizeFactDate(v) {\n  const s = cleanLine(v);\n  if (!s) return null;\n\n  // YYYY-MM-DD\n  let m = s.match(/^(\\d{4})-(\\d{2})-(\\d{2})$/);\n  if (m) return `${m[1]}-${m[2]}-${m[3]}`;\n\n  // DD.MM.YYYY\n  m = s.match(/^(\\d{2})\\.(\\d{2})\\.(\\d{4})$/);\n  if (m) return `${m[3]}-${m[2]}-${m[1]}`;\n\n  // DD/MM/YYYY  (your format: 04/01/2026)\n  m = s.match(/^(\\d{2})\\/(\\d{2})\\/(\\d{4})$/);\n  if (m) {\n    const dd = Number(m[1]);\n    const mm = Number(m[2]);\n    const yyyy = Number(m[3]);\n    if (dd >= 1 && dd <= 31 && mm >= 1 && mm <= 12) {\n      const dds = String(dd).padStart(2, '0');\n      const mms = String(mm).padStart(2, '0');\n      return `${yyyy}-${mms}-${dds}`;\n    }\n  }\n\n  // Try Date.parse for ISO-ish values (not reliable for 04/01/2026, but ok for other strings)\n  const t = Date.parse(s);\n  if (!Number.isNaN(t)) {\n    const d = new Date(t);\n    const y = d.getUTCFullYear();\n    const mo = String(d.getUTCMonth() + 1).padStart(2, '0');\n    const da = String(d.getUTCDate()).padStart(2, '0');\n    return `${y}-${mo}-${da}`;\n  }\n\n  return null;\n}\n\n// get publish date (YYYY-MM-DD) in region TZ for GOODMORNING\nfunction getGoodMorningDateKey(post, tzName) {\n  // Prefer _occurrence_utc (for recurring). For one-time it will also be present in your Determine due.\n  const occIso = cleanLine(post._occurrence_utc);\n  if (occIso) {\n    const d = new Date(occIso);\n    if (!Number.isNaN(d.getTime())) return formatYYYYMMDDInTz(d, tzName);\n  }\n\n  // Fallback: parse from _occurrence_local / _publish_at_parsed (strings like \"YYYY-MM-DD ... (TZ)\")\n  const s1 = cleanLine(post._occurrence_local);\n  if (s1) {\n    const m = s1.match(/^(\\d{4}-\\d{2}-\\d{2})\\b/);\n    if (m) return m[1];\n  }\n\n  const s2 = cleanLine(post._publish_at_parsed);\n  if (s2) {\n    const m = s2.match(/^(\\d{4}-\\d{2}-\\d{2})\\b/);\n    if (m) return m[1];\n  }\n\n  // Last resort: if publish_at exists as \"YYYY-MM-DD ...\" without TZ\n  const s3 = cleanLine(post.publish_at);\n  if (s3) {\n    const m = s3.match(/^(\\d{4}-\\d{2}-\\d{2})\\b/);\n    if (m) return m[1];\n  }\n\n  return null;\n}\n\n// --- –ó–∞–±–∏—Ä–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ –∏–º–µ–Ω–∏ —É–∑–ª–æ–≤ ---\nconst postsInput = $items(FILTER_NODE_NAME).map(x => x.json);\nconst storesInput = $items(POSTGRES_NODE_NAME).map(x => x.json);\nconst factsInput = $items(COOP_FACT_NODE_NAME).map(x => x.json);\n\n// Build facts map: YYYY-MM-DD -> fact\nconst factMap = new Map();\nfor (const row of factsInput) {\n  const dk = normalizeFactDate(row?.date);\n  const fact = cleanLine(row?.fact);\n  if (!dk || !fact) continue;\n  factMap.set(dk, row.fact); // keep last\n}\n\n// –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ stores\nconst tzSet = new Set();\nfor (const s of storesInput) {\n  if (s && s.time_zone !== undefined && s.time_zone !== null && s.time_zone !== '') {\n    tzSet.add(String(s.time_zone));\n  }\n}\nconst storesDebug = {\n  stores_count: storesInput.length,\n  stores_time_zones: Array.from(tzSet).sort(),\n  stores_first_keys: storesInput[0] ? Object.keys(storesInput[0]) : [],\n  facts_count: factsInput.length,\n  facts_keys_sample: Array.from(factMap.keys()).slice(0, 10),\n};\n\n// –ï—Å–ª–∏ stores –Ω–µ –ø—Ä–∏—à–ª–∏ ‚Äî –≤–µ—Ä–Ω—ë–º –æ—à–∏–±–∫—É –Ω–∞ –∫–∞–∂–¥—ã–π –ø–æ—Å—Ç\nif (storesInput.length === 0) {\n  return postsInput.map(post => ({\n    json: {\n      ...post,\n      // NEW\n      order_links: parseOrderLinks(post.order_link ?? post._raw?.order_link),\n      _tg_targets_empty: true,\n      _tg_targets_reason: `stores input is empty: $items(\"${POSTGRES_NODE_NAME}\") returned 0 rows`,\n      _stores_debug: storesDebug,\n\n      // –≤–∞–∂–Ω—ã–µ —Å–ª—É–∂–µ–±–Ω—ã–µ –ø–æ–ª—è –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–≥–æ –∞–ø–¥–µ–π—Ç–∞ Sheets\n      row_number: post?._raw?.row_number ?? null,\n      _now: post._now ?? null,\n      _now_utc: post._now_utc ?? null,\n      _run_key: post._run_key ?? null,\n    },\n  }));\n}\n\n// Map store_id -> storeRow\nconst storeMap = new Map();\nfor (const s of storesInput) {\n  const storeId = Number(s.store_id);\n  if (!Number.isFinite(storeId)) continue;\n  if (!storeMap.has(storeId)) storeMap.set(storeId, s);\n}\n\nconst out = [];\n\nfor (const post of postsInput) {\n  const hasAnyChannel = Boolean(post.send_tg || post.send_max || post.send_vk || post.send_site);\n  if (!hasAnyChannel) continue;\n\n  // --- –ø—Ä–æ—Ç–∞—Å–∫–∏–≤–∞–µ–º row_number (–¥–ª—è Update –≤ Sheets) ---\n  const rowNumber = post?._raw?.row_number ?? null;\n\n  // --- –ø—Ä–æ—Ç–∞—Å–∫–∏–≤–∞–µ–º —Å–ª—É–∂–µ–±–Ω—ã–µ –ø–æ–ª—è –∑–∞–ø—É—Å–∫–∞ (–¥–ª—è last_run_*) ---\n  const nowLocal = post._now ?? null;      // –ª–æ–∫–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è —Ä–µ–≥–∏–æ–Ω–∞ (—Å—Ç—Ä–æ–∫–∞)\n  const nowUtcIso = post._now_utc ?? null; // ISO UTC\n  const runKey = post._run_key ?? null;\n\n  // --- GOODMORNING text override from COOP_FACT (–æ–±—â–∏–π, –º–µ–Ω—è–µ–º post.text) ---\n  const tzName = regionToTzName(post.region);\n  let postForText = post;\n\n  if (post._goodmorning === true) {\n    const dateKey = getGoodMorningDateKey(post, tzName);\n    const fact = dateKey ? factMap.get(dateKey) : null;\n\n    if (!dateKey) {\n      out.push({\n        json: {\n          ...post,\n          // NEW\n          order_links: parseOrderLinks(post.order_link ?? post._raw?.order_link),\n          row_number: rowNumber,\n          _now: nowLocal,\n          _now_utc: nowUtcIso,\n          _run_key: runKey,\n\n          _prepare_error: `GOODMORNING: cannot determine date key from occurrence/publish fields`,\n          _goodmorning_date_key: null,\n          _stores_debug: storesDebug,\n        },\n      });\n      continue;\n    }\n\n    if (!fact || !cleanLine(fact)) {\n      out.push({\n        json: {\n          ...post,\n          // NEW\n          order_links: parseOrderLinks(post.order_link ?? post._raw?.order_link),\n          row_number: rowNumber,\n          _now: nowLocal,\n          _now_utc: nowUtcIso,\n          _run_key: runKey,\n\n          _prepare_error: `GOODMORNING: no fact found for date=${dateKey} in COOP_FACT`,\n          _goodmorning_date_key: dateKey,\n          _stores_debug: storesDebug,\n        },\n      });\n      continue;\n    }\n\n    postForText = {\n      ...post,\n      text: `${fact}\\n!!–ù–∞–≤–∏–≥–∞—Ü–∏—è`,\n      _goodmorning_date_key: dateKey,\n    };\n  }\n  // --- /GOODMORNING ---\n\n  const needTg = Boolean(postForText.send_tg);\n  const needMax = Boolean(postForText.send_max);\n\n  // NEW: parse order links (multi-line: Text|URL)\n  const order_links = parseOrderLinks(postForText.order_link ?? postForText._raw?.order_link);\n\n  // === –ï—Å–ª–∏ TG/MAX –Ω–µ –Ω—É–∂–Ω—ã ‚Äî –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º item –¥–∞–ª—å—à–µ (–¥–ª—è VK/SITE) ===\n  if (!needTg && !needMax) {\n    out.push({\n      json: {\n        ...postForText,\n\n        // NEW\n        order_links,\n\n        row_number: rowNumber,\n        _now: nowLocal,\n        _now_utc: nowUtcIso,\n        _run_key: runKey,\n        _stores_debug: storesDebug,\n      },\n    });\n    continue;\n  }\n\n  const tzNeed = regionToStoreTz(postForText.region);\n  if (tzNeed === null) {\n    // –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–µ–≥–∏–æ–Ω ‚Äî –Ω–µ –º–æ–∂–µ–º –ø–æ–¥–æ–±—Ä–∞—Ç—å —Ç–æ—á–∫–∏\n    if (needTg) {\n      out.push({\n        json: {\n          ...postForText,\n          // NEW\n          order_links,\n          row_number: rowNumber,\n          _now: nowLocal,\n          _now_utc: nowUtcIso,\n          _run_key: runKey,\n\n          _tg_targets_empty: true,\n          _tg_targets_reason: `unknown region=${postForText.region}`,\n          _stores_debug: storesDebug,\n        },\n      });\n    }\n    continue;\n  }\n\n  // store_id —Ü–µ–ª–∏\n  let targetStoreIds = [];\n  if (postForText.all_region) {\n    for (const s of storesInput) {\n      if (Number(s.time_zone) === tzNeed) {\n        const id = Number(s.store_id);\n        if (Number.isFinite(id)) targetStoreIds.push(id);\n      }\n    }\n  } else {\n    targetStoreIds = pickStoreIdsFromRaw(postForText._raw);\n  }\n\n  targetStoreIds = Array.from(new Set(targetStoreIds));\n\n  if (targetStoreIds.length === 0) {\n    if (needTg) {\n      out.push({\n        json: {\n          ...postForText,\n          // NEW\n          order_links,\n          row_number: rowNumber,\n          _now: nowLocal,\n          _now_utc: nowUtcIso,\n          _run_key: runKey,\n\n          _tg_targets_empty: true,\n          _tg_targets_reason: postForText.all_region\n            ? `no stores found for time_zone=${tzNeed} (stores_count=${storesInput.length}, tzs=${storesDebug.stores_time_zones.join(',')})`\n            : 'no store columns selected in sheet row (no store_* = 1)',\n          _stores_debug: storesDebug,\n        },\n      });\n    }\n    continue;\n  }\n\n  // ---- parse media ----\n  const mediaRaw = (postForText.media_raw ?? postForText.media_url ?? postForText._raw?.media_raw ?? postForText._raw?.media_url ?? '').toString();\n  const mediaArr = parseMediaLines(mediaRaw);\n\n  // old_post parsing (only if present) ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –¥–ª—è TG deep-link\n  const oldParsed = parseOldPost(postForText.old_post ?? postForText._raw?.old_post);\n\n  // date part for old_link in region tz\n  const nowUtcObj = nowUtcIso ? new Date(nowUtcIso) : new Date();\n  const datePart = formatDDMMYYYYInTz(nowUtcObj, tzName);\n\n  // --- TG prep (–∫–∞–∫ –±—ã–ª–æ) ---\n  const tgBase = needTg ? buildTgTextAndMode(postForText) : null;\n  const debugMode = needTg ? (Number(postForText.tg_debug) === 1) : false;\n\n  // –±–∞–∑–æ–≤–æ–µ —Ä–µ—à–µ–Ω–∏–µ –ø–æ —Ç–∏–ø—É –æ—Ç–ø—Ä–∞–≤–∫–∏ (TG)\n  let baseOpTg = 'message'; // message | photo | video | media_group\n  let baseMediaTg = null;\n\n  if (mediaArr.length === 0) {\n    baseOpTg = 'message';\n  } else if (mediaArr.length === 1) {\n    baseOpTg = mediaArr[0].type === 'photo' ? 'photo' : 'video';\n    baseMediaTg = mediaArr[0].media;\n  } else {\n    baseOpTg = 'media_group';\n  }\n\n  // --- MAX prep ---\n  // MAX API: photo -> image (type=image)\n  const mediaArrMax = mediaArr.map(m => ({\n    type: m.type === 'photo' ? 'image' : 'video',\n    media: m.media,\n  }));\n\n  let baseOpMax = 'message'; // message | image | video | media_group\n  let baseMediaMax = null;\n\n  if (mediaArrMax.length === 0) {\n    baseOpMax = 'message';\n  } else if (mediaArrMax.length === 1) {\n    baseOpMax = mediaArrMax[0].type === 'image' ? 'image' : 'video';\n    baseMediaMax = mediaArrMax[0].media;\n  } else {\n    baseOpMax = 'media_group';\n  }\n\n  const seenChat = new Set(); // TG dedupe by chat_id\n  const seenMax = new Set();  // MAX dedupe by max_channel_id\n\n  let producedTg = 0;\n  let producedMax = 0;\n\n  for (const storeId of targetStoreIds) {\n    const s = storeMap.get(storeId);\n    if (!s) continue;\n    if (Number(s.time_zone) !== tzNeed) continue;\n\n    const tgInvExptEmpty = !String(postForText.tg_inv_expt ?? '').trim();\n    const tgInvite = tgInvExptEmpty ? cleanUrl(s.tg_invite_url_channel_friend) : null;\n    const maxInvite = tgInvExptEmpty ? cleanUrl(s.max_invite_url_channel_friend) : null;\n\n    // ---------------- TG ----------------\n    if (needTg) {\n      const chatId = debugMode ? TG_TEST_CHAT_ID : s.channel_chat_id;\n      const chatKey = String(chatId);\n      if (!chatId) {\n        // –µ—Å–ª–∏ –Ω–µ—Ç chat_id ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º\n      } else if (!seenChat.has(chatKey)) {\n        seenChat.add(chatKey);\n\n        const effectiveAuthType =\n          (debugMode && TG_TEST_FORCE_AUTH_TYPE_1)\n            ? 1\n            : Number(postForText.post_auth_type ?? s.post_auth_type);\n\n        const authType1 = effectiveAuthType === 1;\n\n        // --- old link for this store (depends on storeId) ---\n        // IMPORTANT: if post_auth_type = 1 -> ignore old_post completely\n        const oldLink = (!authType1 && oldParsed)\n          ? buildOldLink(oldParsed, storeId, datePart, tgBase.parse_mode)\n          : null;\n\n        // --- text final (Telegram) ---\n        // post_auth_type = 1:\n        //   - base text\n        //   - then order_links block (from order_link)\n        //   - then invite footer (if enabled)\n        // else:\n        //   - current behavior (oldLink + footer)\n        let tgTextFinal = tgBase.text;\n\n        if (authType1) {\n          tgTextFinal = appendOrderLinksToText(tgTextFinal, order_links, tgBase.parse_mode);\n        } else {\n          tgTextFinal = appendOldLinkToText(tgTextFinal, oldLink);\n        }\n\n        if (tgInvExptEmpty) {\n          const footer = buildInviteFooter(tgBase.parse_mode, tgInvite, maxInvite);\n          tgTextFinal = appendFooter(tgTextFinal, footer);\n        }\n\n        // --- per-store media decision for albums: caption may be too long ---\n        let tgOp = baseOpTg;\n        let tgMedia = baseMediaTg;\n        let tgMediaGroup = null;\n        let needExtraTextMessage = false;\n\n        if (baseOpTg === 'media_group') {\n          tgMediaGroup = mediaArr;\n\n          if (isCaptionOk(tgTextFinal)) {\n            tgMediaGroup = tgMediaGroup.map((m, idx) => {\n              if (idx === 0) {\n                return {\n                  ...m,\n                  caption: tgTextFinal,\n                  parse_mode: tgBase.parse_mode,\n                };\n              }\n              return m;\n            });\n          } else if (tgTextFinal.trim()) {\n            // caption —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π ‚Äî –∞–ª—å–±–æ–º –±–µ–∑ caption, –∞ —Ç–µ–∫—Å—Ç –æ—Ç–¥–µ–ª—å–Ω—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º\n            needExtraTextMessage = true;\n          }\n        }\n\n        // 1) –æ—Å–Ω–æ–≤–Ω–æ–π item\n        out.push({\n          json: {\n            ...postForText,\n\n            // NEW\n            order_links,\n\n            channel: 'tg',\n\n            // —Å–ª—É–∂–µ–±–Ω—ã–µ –ø–æ–ª—è –¥–ª—è –∞–ø–¥–µ–π—Ç–∞ Sheets\n            row_number: rowNumber,\n            _now: nowLocal,\n            _now_utc: nowUtcIso,\n            _run_key: runKey,\n\n            // –¥–∞–Ω–Ω—ã–µ —Ü–µ–ª–∏\n            store_id: storeId,\n            store_description: s.store_description ?? null,\n\n            // routing for telegram\n            tg_op: tgOp,\n            tg_media: tgMedia,\n            tg_media_group: tgMediaGroup,\n\n            // old link debug\n            _old_post_parsed: oldParsed,\n            _old_post_date_ddmmyyyy: datePart,\n            _old_post_link: oldLink,\n\n            tg: {\n              chat_id: chatId,\n              text: tgTextFinal,\n              parse_mode: tgBase.parse_mode,\n              debug: debugMode,\n            },\n\n            _run_key_channel: runKey ? `${runKey}|tg|store:${storeId}` : null,\n            _stores_debug: storesDebug,\n          },\n        });\n\n        producedTg++;\n\n        // 2) –µ—Å–ª–∏ –∞–ª—å–±–æ–º –∏ —Ç–µ–∫—Å—Ç –¥–ª–∏–Ω–Ω—ã–π ‚Äî –æ—Ç–¥–µ–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–æ–º –ø–æ—Å–ª–µ –∞–ª—å–±–æ–º–∞\n        if (tgOp === 'media_group' && needExtraTextMessage) {\n          out.push({\n            json: {\n              ...postForText,\n\n              // NEW\n              order_links,\n\n              channel: 'tg',\n\n              row_number: rowNumber,\n              _now: nowLocal,\n              _now_utc: nowUtcIso,\n              _run_key: runKey,\n\n              store_id: storeId,\n              store_description: s.store_description ?? null,\n\n              tg_op: 'message',\n              tg_media: null,\n              tg_media_group: null,\n\n              // old link debug\n              _old_post_parsed: oldParsed,\n              _old_post_date_ddmmyyyy: datePart,\n              _old_post_link: oldLink,\n\n              tg: {\n                chat_id: chatId,\n                text: tgTextFinal,\n                parse_mode: tgBase.parse_mode,\n                debug: debugMode,\n              },\n\n              _run_key_channel: runKey ? `${runKey}|tg|store:${storeId}|text_after_album` : null,\n              _stores_debug: storesDebug,\n            },\n          });\n        }\n      }\n    }\n\n    // ---------------- MAX ----------------\n    if (needMax) {\n      const maxChannelId = s.max_channel_id;\n      const maxKey = String(maxChannelId ?? '');\n      if (!maxChannelId) {\n        // –Ω–µ—Ç –∫–∞–Ω–∞–ª–∞ MAX —É —Ç–æ—á–∫–∏ ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º\n      } else if (!seenMax.has(maxKey)) {\n        seenMax.add(maxKey);\n\n        let maxOp = baseOpMax;\n        let maxMedia = baseMediaMax;\n        let maxMediaGroup = null;\n\n        if (baseOpMax === 'media_group') {\n          maxMediaGroup = mediaArrMax;\n        }\n\n        // NEW: MAX text + invite footer (MARKDOWN links)\n        let maxTextFinal = (postForText.text ?? '').toString().trim();\n\n        function mdLink(label, url) {\n          const u = String(url ?? '').trim();\n          if (!u) return null;\n          return `[${label}](${u})`;\n        }\n\n        if (tgInvExptEmpty) {\n          const lines = [];\n\n          const tgLink = mdLink('üì¢ –ü–æ–¥–ø–∏—à–∏—Å—å –≤ Telegram', tgInvite);\n          if (tgLink) lines.push(tgLink);\n\n          const maxLink = mdLink('‚ö° –ü–æ–¥–ø–∏—à–∏—Å—å –≤ MAX', maxInvite);\n          if (maxLink) lines.push(maxLink);\n\n          if (lines.length) {\n            const footer = lines.join('\\n\\n');\n            maxTextFinal = maxTextFinal\n              ? `${maxTextFinal}\\n\\n${footer}`\n              : footer;\n          }\n        }\n\n        out.push({\n          json: {\n            ...postForText,\n\n            // NEW\n            order_links,\n\n            channel: 'max',\n\n            row_number: rowNumber,\n            _now: nowLocal,\n            _now_utc: nowUtcIso,\n            _run_key: runKey,\n\n            store_id: storeId,\n            store_description: s.store_description ?? null,\n\n            max_op: maxOp,\n            max_media: maxMedia,\n            max_media_group: maxMediaGroup,\n\n            max: {\n              channel_id: maxChannelId,\n              text: maxTextFinal,\n            },\n\n            _run_key_channel: runKey ? `${runKey}|max|store:${storeId}` : null,\n            _stores_debug: storesDebug,\n          },\n        });\n\n        producedMax++;\n      }\n    }\n  }\n\n  if (needTg && producedTg === 0) {\n    out.push({\n      json: {\n        ...postForText,\n        // NEW\n        order_links,\n        row_number: rowNumber,\n        _now: nowLocal,\n        _now_utc: nowUtcIso,\n        _run_key: runKey,\n\n        _tg_targets_empty: true,\n        _tg_targets_reason: `stores selected but none matched mapping for time_zone=${tzNeed} (stores_count=${storesInput.length}, tzs=${storesDebug.stores_time_zones.join(',')})`,\n        _stores_debug: storesDebug,\n      },\n    });\n  }\n}\n\nreturn out;\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[4000,2080],"id":"20694f37-278f-4f95-92be-b13e652133e7","name":"Code in JavaScript2","onError":"continueRegularOutput"},{"parameters":{"chatId":"={{ $json.tg_chat_id }}","text":"={{ $json.tg_text }}","additionalFields":{"appendAttribution":false,"parse_mode":"={{ $json.tg_parse_mode }}"}},"type":"n8n-nodes-base.telegram","typeVersion":1.2,"position":[5520,1808],"id":"88be1d02-182d-4400-83d5-5af1edb0a6f4","name":"Send a text message","webhookId":"7bc76fa8-4f21-4ca3-a3c8-789ed15814dc","alwaysOutputData":true,"credentials":{"telegramApi":{"id":"PvtTCKhw5iSNTNjL","name":"Telegram account"}},"onError":"continueRegularOutput"},{"parameters":{"operation":"executeQuery","query":"SELECT\n  s.store_id,\n  s.store_description,\n  s.time_zone,\n  s.post_auth_type,\n  MAX(sc.channel_chat_id)              AS channel_chat_id,\n  MAX(sc.discussion_chat_id)            AS discussion_chat_id,\n  MAX(sc.max_channel_id)                AS max_channel_id,\n  MAX(sc.tg_invite_url_channel_friend)  AS tg_invite_url_channel_friend,\n  MAX(sc.max_invite_url_channel_friend) AS max_invite_url_channel_friend\nFROM coop.order_store s\nJOIN coop.store_channel sc ON sc.store_id = s.store_id\nWHERE (sc.channel_chat_id IS NOT NULL \n       OR sc.max_channel_id IS NOT NULL)\n  AND s.time_zone IN (3, 7)\n  AND s.store_close_date IS NULL\nGROUP BY s.store_id, s.store_description, s.time_zone, s.post_auth_type\nORDER BY s.time_zone, s.store_id;","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[3456,2288],"id":"15c00129-5984-4890-8121-6f46c9db04f1","name":"Postgre_store_extract","executeOnce":true,"credentials":{"postgres":{"id":"Nn7xJ9wkuFYHFyvT","name":"Postgres account"}}},{"parameters":{"jsCode":"/**\n * Collect TG results per post_id (after Merge Combine/Position)\n * Supports:\n *  - Telegram nodes (they often return { ok:true, result:... } or set p.error on continueRegularOutput)\n *  - HTTP Request node (sendMediaGroup) which may return:\n *      - { statusCode: 200, body: { ok:true, result:[...] } }  (when JSON)\n *      - { statusCode: 200, body: \"...\" }                      (when string)\n *      - errors in p.error / p.message / p.response / p.body\n *\n * Output: one item per post_id with aggregation + Sheets update fields\n */\n\nconst items = $input.all();\n\nfunction safeStr(v) {\n  if (v === null || v === undefined) return '';\n  return String(v);\n}\n\nfunction toNumOrNull(v) {\n  if (v === null || v === undefined || v === '') return null;\n  const n = Number(v);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction appendLog(existing, line) {\n  const base = (existing ?? '').toString().trim();\n  if (!base) return line;\n  return base + '\\n' + line;\n}\n\nfunction tryJsonParse(s) {\n  try {\n    return JSON.parse(s);\n  } catch (e) {\n    return null;\n  }\n}\n\n// --- Detect ok for both Telegram node and HTTP Request node ---\nfunction detectOk(p) {\n  if (!p) return false;\n\n  // Telegram node common\n  if (p.ok === true || p.success === true) return true;\n\n  // HTTP Request node common shapes\n  // 1) response object\n  if (p.response && (p.response.ok === true || p.response.success === true)) return true;\n\n  // 2) body may be object or stringified json\n  const body = p.body ?? p.response?.body ?? null;\n  if (body && typeof body === 'object') {\n    if (body.ok === true) return true;\n    // sometimes nested\n    if (body.data?.ok === true) return true;\n  }\n  if (typeof body === 'string') {\n    const j = tryJsonParse(body);\n    if (j && j.ok === true) return true;\n  }\n\n  // 3) n8n httpRequest often exposes statusCode\n  const sc = p.statusCode ?? p.status ?? p.response?.statusCode ?? null;\n  if (typeof sc === 'number' && sc >= 200 && sc < 300) {\n    // If Telegram returns non-ok with 200, we'd have body.ok=false.\n    // But if we can't see body, treat 2xx as ok to avoid false FAIL logs.\n    return true;\n  }\n\n  return false;\n}\n\nfunction extractErrorText(p) {\n  if (!p) return 'unknown error';\n\n  // Telegram node error object\n  if (typeof p.error === 'string') return p.error;\n  if (p.error?.message) return safeStr(p.error.message);\n\n  // httpRequest node sometimes exposes errorMessage / message\n  if (p.errorMessage) return safeStr(p.errorMessage);\n  if (p.message) return safeStr(p.message);\n  if (p.description) return safeStr(p.description);\n  if (p.cause) return safeStr(p.cause);\n\n  // response/body shapes\n  const body = p.body ?? p.response?.body ?? p.responseBody ?? null;\n\n  if (body && typeof body === 'object') {\n    if (body.description) return safeStr(body.description);\n    if (body.error) return safeStr(body.error);\n    if (body.message) return safeStr(body.message);\n    if (body.ok === false && body.description) return safeStr(body.description);\n    try {\n      return JSON.stringify(body);\n    } catch (e) {\n      return 'unstringifiable body';\n    }\n  }\n\n  if (typeof body === 'string') {\n    const j = tryJsonParse(body);\n    if (j) {\n      if (j.description) return safeStr(j.description);\n      if (j.error) return safeStr(j.error);\n      if (j.message) return safeStr(j.message);\n      if (j.ok === false && j.description) return safeStr(j.description);\n      try {\n        return JSON.stringify(j);\n      } catch (e) {}\n    }\n    // raw string body\n    const s = body.trim();\n    if (s) return s.slice(0, 500);\n  }\n\n  // fallback stringify whole p.error if exists\n  if (p.error) {\n    try {\n      return JSON.stringify(p.error);\n    } catch (e) {\n      return 'unstringifiable error';\n    }\n  }\n\n  return 'unknown error';\n}\n\n// group per post_id\nconst byPost = new Map();\n\nfor (const item of items) {\n  const p = item.json || {};\n\n  const postId = p.post_id ?? p.id ?? null;\n  if (!postId) continue;\n\n  if (!byPost.has(postId)) {\n    byPost.set(postId, {\n      post_id: postId,\n      row_number: toNumOrNull(p.row_number),\n\n      last_run_key: p._run_key ?? null,\n      now_utc: p._now_utc ?? new Date().toISOString(),\n      now_local: p._now ?? null,\n\n      plan_run_at: p._plan_run_at ?? null,\n      prev_error: p.error_prev ?? null,\n\n      total: 0,\n      ok: 0,\n      fail: 0,\n      fails: [],\n    });\n  }\n\n  const agg = byPost.get(postId);\n\n  if (!agg.plan_run_at && p._plan_run_at) agg.plan_run_at = p._plan_run_at;\n\n  agg.total += 1;\n\n  const ok = detectOk(p);\n\n  const storeId = p.store_id ?? null;\n  const chatId = p.tg_chat_id ?? p.chat_id ?? null;\n\n  if (ok) {\n    agg.ok += 1;\n  } else {\n    agg.fail += 1;\n    const desc = extractErrorText(p);\n    agg.fails.push({\n      store_id: storeId,\n      chat_id: chatId,\n      desc: safeStr(desc),\n    });\n  }\n}\n\nconst out = [];\n\nfor (const agg of byPost.values()) {\n  // success only if at least one ok and no fails\n  const allOk = agg.fail === 0 && agg.ok > 0;\n\n  let newError = agg.prev_error;\n\n  if (allOk) {\n    newError = appendLog(\n      newError,\n      `[OK TG] ${agg.now_utc} key=${safeStr(agg.last_run_key)} sent=${agg.ok}/${agg.total}`\n    );\n  } else {\n    const failLines = agg.fails\n      .slice(0, 20)\n      .map(f => `store=${safeStr(f.store_id)} chat=${safeStr(f.chat_id)} err=${safeStr(f.desc)}`)\n      .join(' | ');\n\n    newError = appendLog(\n      newError,\n      `[FAIL TG] ${agg.now_utc} key=${safeStr(agg.last_run_key)} ok=${agg.ok}/${agg.total} fails=${agg.fail}` +\n        (failLines ? ` :: ${failLines}` : '')\n    );\n  }\n\n  out.push({\n    json: {\n      post_id: agg.post_id,\n      row_number: agg.row_number,\n\n      _all_ok: allOk,\n      _sent_ok: agg.ok,\n      _sent_fail: agg.fail,\n      _sent_total: agg.total,\n\n      update_last_run_at_utc: allOk ? agg.now_utc : null,\n      update_last_run_at: allOk ? agg.now_local : null,\n      update_last_run_key: allOk ? agg.last_run_key : null,\n\n      // write plan_run_at only on success\n      update_plan_run_at: allOk ? (agg.plan_run_at ?? null) : null,\n\n      update_error: newError,\n    },\n  });\n}\n\nreturn out;\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[6176,2032],"id":"6808c6c8-1a14-492a-9355-2b8720e7abf1","name":"Collect TG results"},{"parameters":{"assignments":{"assignments":[{"id":"1f3d5cad-548c-48bd-a374-ccdde7c4314f","name":"row_number","value":"={{$json.row_number}}","type":"number"},{"id":"254b0c02-3d0b-49ad-a8ca-7458f17209c3","name":"=post_id","value":"={{$json.id}}","type":"number"},{"id":"9afe30be-bf19-4af9-80fa-87e2353d83cc","name":"=_run_key","value":"={{$json._run_key}}","type":"string"},{"id":"1af1f314-8f5a-4a78-a072-f8d807c68e4d","name":"_now","value":"={{$json._now}}","type":"string"},{"id":"0aa65ec9-dd1e-4222-be13-933718236ee1","name":"_now_utc","value":"={{$json._now_utc}}","type":"string"},{"id":"640a3f9b-df58-45a7-8fbe-f29fa198bf8a","name":"store_id","value":"={{$json.store_id}}","type":"number"},{"id":"c02060fc-02fd-43b4-9c21-5b2a0a1f439b","name":"tg_chat_id","value":"={{$json.tg.chat_id}}","type":"string"},{"id":"6ab1367a-f53c-46cc-a263-d88103dbcc96","name":"tg_text","value":"={{$json.tg.text}}","type":"string"},{"id":"2b04009d-0cf0-47df-83fe-3209c35bf1ee","name":"tg_parse_mode","value":"={{$json.tg.parse_mode}}","type":"string"},{"id":"b9c1c913-0000-4295-88b0-9f32cd8d6d6b","name":"error_prev","value":"={{$json.error}}","type":"string"},{"id":"077dde57-5614-483b-afbe-504eec04fb67","name":"tg_op","value":"={{$json.tg_op}}","type":"string"},{"id":"2e21132e-99ed-4797-b9a9-373ab5b8ec2b","name":"tg_media","value":"={{$json.tg_media}}","type":"string"},{"id":"4fe678fe-b144-40d8-89d9-7037ede12a83","name":"tg_media_group_json","value":"={{ JSON.stringify($json.tg_media_group) }}","type":"string"},{"id":"f3930a07-f3c3-4722-a6e6-0bbb3ecddb35","name":"_old_post_link","value":"={{$json._old_post_link}}","type":"string"},{"id":"e0106ac8-b2bf-455d-81e8-ee4bfe5cd40a","name":"_plan_run_at","value":"={{$json._plan_run_at}}","type":"string"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[4752,2224],"id":"e3d37501-e339-47e8-9915-2eaf29b3e17b","name":"Edit Fields"},{"parameters":{"mode":"combine","combineBy":"combineByPosition","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5696,1968],"id":"a3e0cbda-f8e6-4247-a0c7-561bebd112ef","name":"Merge"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"loose","version":3},"conditions":[{"id":"1de16de6-60be-47d0-85bb-be106d58e7e2","leftValue":"={{$json._all_ok}}","rightValue":"true","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"looseTypeValidation":true,"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.3,"position":[8128,1984],"id":"55cf5005-7a59-4b86-8722-f39921836719","name":"If"},{"parameters":{"operation":"update","documentId":{"__rl":true,"value":"1FyEGxa6JYTJxDrowfgzAzroTM8L3CWCSY1rgI2DK9KQ","mode":"id"},"sheetName":{"__rl":true,"value":"POST","mode":"name"},"columns":{"mappingMode":"defineBelow","value":{"row_number":"={{$json.row_number}}","last_run_at_utc":"={{$json.update_last_run_at_utc}}","last_run_at":"={{$json.update_last_run_at}}","last_run_key":"={{$json.update_last_run_key}}","error":"={{$json.update_error}}","plan_run_at":"={{$json.update_plan_run_at}}"},"matchingColumns":["row_number"],"schema":[{"id":"id","displayName":"id","required":false,"defaultMatch":true,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"status","displayName":"status","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"region","displayName":"region","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"post_type","displayName":"post_type","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"tg_debug","displayName":"tg_debug","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"send_tg","displayName":"send_tg","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"send_vk","displayName":"send_vk","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"send_site","displayName":"send_site","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"old_post","displayName":"old_post","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"title","displayName":"title","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"media_url","displayName":"media_url","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"parse_mode","displayName":"parse_mode","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"text","displayName":"text","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"points_note_mode","displayName":"points_note_mode","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"all_region","displayName":"all_region","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_195_–ë–æ–ª—å—à–µ–≤–∏—Å—Ç—Å–∫–∞—è","displayName":"store_195_–ë–æ–ª—å—à–µ–≤–∏—Å—Ç—Å–∫–∞—è","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_191_–†—è–±–∏–Ω–æ–≤–∞—è","displayName":"store_191_–†—è–±–∏–Ω–æ–≤–∞—è","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_190_–ó–æ–ª–æ—Ç–æ–¥–æ–ª–∏–Ω—Å–∫–∞—è","displayName":"store_190_–ó–æ–ª–æ—Ç–æ–¥–æ–ª–∏–Ω—Å–∫–∞—è","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_174_–û–Ω–µ–≥–∞","displayName":"store_174_–û–Ω–µ–≥–∞","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_166_–°—Ç–∞–Ω–∏—Å–ª–∞–≤—Å–∫–æ–≥–æ","displayName":"store_166_–°—Ç–∞–Ω–∏—Å–ª–∞–≤—Å–∫–æ–≥–æ","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_186_–ö—Ä–∞—Å–Ω–æ–æ–±—Å–∫","displayName":"store_186_–ö—Ä–∞—Å–Ω–æ–æ–±—Å–∫","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_193_–ë–µ—Ä–¥—Å–∫–í–æ–∫–∑–∞–ª—å–Ω–∞—è","displayName":"store_193_–ë–µ—Ä–¥—Å–∫–í–æ–∫–∑–∞–ª—å–Ω–∞—è","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_160_–î–µ–∫–∞–±—Ä–∏—Å—Ç–æ–≤41","displayName":"store_160_–î–µ–∫–∞–±—Ä–∏—Å—Ç–æ–≤41","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_189_–Ø–ª—Ç–∞","displayName":"store_189_–Ø–ª—Ç–∞","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_211_–°–∏–º—Ñ–µ—Ä–æ–ø–æ–ª—å","displayName":"store_211_–°–∏–º—Ñ–µ—Ä–æ–ø–æ–ª—å","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"schedule","displayName":"schedule","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"publish_at","displayName":"publish_at","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"last_run_at_utc","displayName":"last_run_at_utc","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":false},{"id":"last_run_at","displayName":"last_run_at","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":false},{"id":"last_run_key","displayName":"last_run_key","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":false},{"id":"plan_run_at","displayName":"plan_run_at","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":false},{"id":"error","displayName":"error","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":false},{"id":"row_number","displayName":"row_number","required":false,"defaultMatch":false,"display":true,"type":"number","canBeUsedToMatch":true,"readOnly":true,"removed":false}],"attemptToConvertTypes":false,"convertFieldsToString":false},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[8400,1712],"id":"6ec7c2a9-ce18-4341-922c-9f9e7751ba52","name":"Update row in sheet","credentials":{"googleSheetsOAuth2Api":{"id":"b5DluHDjTyDAsQWd","name":"Google Sheets account"}}},{"parameters":{"operation":"update","documentId":{"__rl":true,"value":"1FyEGxa6JYTJxDrowfgzAzroTM8L3CWCSY1rgI2DK9KQ","mode":"id"},"sheetName":{"__rl":true,"value":"POST","mode":"name"},"columns":{"mappingMode":"defineBelow","value":{"row_number":"={{$json.row_number}}","error":"={{$json.update_error}}"},"matchingColumns":["row_number"],"schema":[{"id":"id","displayName":"id","required":false,"defaultMatch":true,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"status","displayName":"status","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"region","displayName":"region","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"post_type","displayName":"post_type","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"tg_debug","displayName":"tg_debug","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"send_tg","displayName":"send_tg","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"send_vk","displayName":"send_vk","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"send_site","displayName":"send_site","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"title","displayName":"title","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"media_url","displayName":"media_url","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"parse_mode","displayName":"parse_mode","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"text","displayName":"text","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"points_note_mode","displayName":"points_note_mode","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"all_region","displayName":"all_region","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_195_–ë–æ–ª—å—à–µ–≤–∏—Å—Ç—Å–∫–∞—è","displayName":"store_195_–ë–æ–ª—å—à–µ–≤–∏—Å—Ç—Å–∫–∞—è","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_191_–†—è–±–∏–Ω–æ–≤–∞—è","displayName":"store_191_–†—è–±–∏–Ω–æ–≤–∞—è","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_190_–ó–æ–ª–æ—Ç–æ–¥–æ–ª–∏–Ω—Å–∫–∞—è","displayName":"store_190_–ó–æ–ª–æ—Ç–æ–¥–æ–ª–∏–Ω—Å–∫–∞—è","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_174_–û–Ω–µ–≥–∞","displayName":"store_174_–û–Ω–µ–≥–∞","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_166_–°—Ç–∞–Ω–∏—Å–ª–∞–≤—Å–∫–æ–≥–æ","displayName":"store_166_–°—Ç–∞–Ω–∏—Å–ª–∞–≤—Å–∫–æ–≥–æ","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_186_–ö—Ä–∞—Å–Ω–æ–æ–±—Å–∫","displayName":"store_186_–ö—Ä–∞—Å–Ω–æ–æ–±—Å–∫","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_193_–ë–µ—Ä–¥—Å–∫–í–æ–∫–∑–∞–ª—å–Ω–∞—è","displayName":"store_193_–ë–µ—Ä–¥—Å–∫–í–æ–∫–∑–∞–ª—å–Ω–∞—è","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_160_–î–µ–∫–∞–±—Ä–∏—Å—Ç–æ–≤41","displayName":"store_160_–î–µ–∫–∞–±—Ä–∏—Å—Ç–æ–≤41","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_189_–Ø–ª—Ç–∞","displayName":"store_189_–Ø–ª—Ç–∞","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_211_–°–∏–º—Ñ–µ—Ä–æ–ø–æ–ª—å","displayName":"store_211_–°–∏–º—Ñ–µ—Ä–æ–ø–æ–ª—å","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"schedule","displayName":"schedule","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"last_run_at_utc","displayName":"last_run_at_utc","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"last_run_at","displayName":"last_run_at","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"last_run_key","displayName":"last_run_key","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"error","displayName":"error","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":false},{"id":"publish_at","displayName":"publish_at","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"row_number","displayName":"row_number","required":false,"defaultMatch":false,"display":true,"type":"number","canBeUsedToMatch":true,"readOnly":true,"removed":false}],"attemptToConvertTypes":false,"convertFieldsToString":false},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[8400,2176],"id":"9599a944-9d02-4a0c-be61-ce35f94f9b81","name":"Update row in sheet1","credentials":{"googleSheetsOAuth2Api":{"id":"b5DluHDjTyDAsQWd","name":"Google Sheets account"}}},{"parameters":{},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[3584,2064],"id":"c2b4a5a5-e1ae-4dfb-9b0d-a455fc7d9dd8","name":"Merge1"},{"parameters":{"rules":{"values":[{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"leftValue":"={{$json.tg_op}}","rightValue":"message","operator":{"type":"string","operation":"equals"},"id":"a889ad03-e512-413d-afc6-cb13b4d06e20"}],"combinator":"and"},"renameOutput":true,"outputKey":"Output 1"},{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"id":"3b373903-657f-4d1c-b292-d7e347a05ecb","leftValue":"={{$json.tg_op}}","rightValue":"photo","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"renameOutput":true,"outputKey":"Output 2"},{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"id":"ec2bd0f8-d963-46e1-b215-dac61c822773","leftValue":"={{$json.tg_op}}","rightValue":"video","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"renameOutput":true,"outputKey":"Output 3"},{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"id":"b0a65edb-b26b-43f5-a746-8ef43cc19e0c","leftValue":"={{$json.tg_op}}","rightValue":"media_group","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"renameOutput":true,"outputKey":"Output 4"}]},"options":{}},"type":"n8n-nodes-base.switch","typeVersion":3.4,"position":[5216,2176],"id":"9ed13b53-2c6e-40ef-812d-ecdbe3136050","name":"Switch"},{"parameters":{"operation":"sendPhoto","chatId":"={{$json.tg_chat_id}}","file":"={{$json.tg_media}}","additionalFields":{"caption":"={{$json.tg_text}}","parse_mode":"={{$json.tg_parse_mode}}"}},"type":"n8n-nodes-base.telegram","typeVersion":1.2,"position":[5552,2256],"id":"90efda40-eafe-42eb-af2a-b7c6409f163e","name":"Send a photo message","webhookId":"96bbf79c-5f72-4ec7-9b00-9eefc668bfaa","alwaysOutputData":true,"notesInFlow":false,"credentials":{"telegramApi":{"id":"PvtTCKhw5iSNTNjL","name":"Telegram account"}},"onError":"continueRegularOutput"},{"parameters":{"mode":"combine","combineBy":"combineByPosition","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5728,2208],"id":"d7c1e173-99e5-4067-992e-064016f0db83","name":"Merge2"},{"parameters":{"operation":"sendVideo","chatId":"={{$json.tg_chat_id}}","file":"={{$json.tg_media}}","additionalFields":{"caption":"={{$json.tg_text}}","parse_mode":"={{$json.tg_parse_mode}}"}},"type":"n8n-nodes-base.telegram","typeVersion":1.2,"position":[5568,2432],"id":"1aa25e72-dee3-4848-a1d0-114b472e859b","name":"Send a video","webhookId":"bfa40423-543f-4fe5-925c-0d320fa5127f","credentials":{"telegramApi":{"id":"PvtTCKhw5iSNTNjL","name":"Telegram account"}},"onError":"continueRegularOutput"},{"parameters":{"mode":"combine","combineBy":"combineByPosition","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5728,2448],"id":"73e06c62-7d98-4c9c-9fb7-f11e0c54d71d","name":"Merge3"},{"parameters":{"method":"POST","url":"https://api.telegram.org/bot8207832455:AAGzn7aGpClD91WdqE5Mcx6nhVw8R5tLXCk/sendMediaGroup","sendBody":true,"bodyParameters":{"parameters":[{"name":"chat_id","value":"={{$json.tg_chat_id}}"},{"name":"media","value":"={{$json.tg_media_group_json}}"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[5568,2784],"id":"0ddcef38-3939-4414-8a54-0687bca0eba0","name":"HTTP Request","onError":"continueRegularOutput"},{"parameters":{"mode":"combine","combineBy":"combineByPosition","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5712,2784],"id":"3915f63c-5857-4aaf-8169-22ccafe8d72a","name":"Merge4"},{"parameters":{"numberInputs":4},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5952,2048],"id":"71f6a733-a381-43a5-b6da-d9e8d1719c48","name":"Merge5"},{"parameters":{"documentId":{"__rl":true,"value":"1FyEGxa6JYTJxDrowfgzAzroTM8L3CWCSY1rgI2DK9KQ","mode":"id"},"sheetName":{"__rl":true,"value":"COOP_FACT","mode":"name"},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[3456,1760],"id":"d066a61e-43dc-4181-9523-e664e57b1f37","name":"GS_CoopFact_GetRows","executeOnce":true,"credentials":{"googleSheetsOAuth2Api":{"id":"b5DluHDjTyDAsQWd","name":"Google Sheets account"}}},{"parameters":{},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[3712,1888],"id":"f7085228-b996-462d-a267-2c8b1c159313","name":"Merge_Facts_Barrier"},{"parameters":{"jsCode":"function regionToTz(region) {\n  if (region === 54) return 'Asia/Novosibirsk';\n  if (region === 82) return 'Europe/Simferopol';\n  return 'Europe/Moscow';\n}\n\nfunction cleanLine(s) {\n  return String(s ?? '')\n    .replace(/[\\uFEFF\\u200B\\u200C\\u200D\\u2060\\u00AD]/g, '')\n    .trim();\n}\n\nfunction formatLocalHuman(utcDate, tz) {\n  const dtf = new Intl.DateTimeFormat('en-CA', {\n    timeZone: tz,\n    hour12: false,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n  });\n\n  const parts = dtf.formatToParts(utcDate);\n  const map = {};\n  for (const p of parts) if (p.type !== 'literal') map[p.type] = p.value;\n\n  // –ø—Ä–æ–±–µ–ª –≤–º–µ—Å—Ç–æ T ‚Äî –ª—é–¥—è–º –ø—Ä–æ—â–µ\n  return `${map.year}-${map.month}-${map.day} ${map.hour}:${map.minute}:${map.second} (${tz})`;\n}\n\n// FIX: –ø—Ä–∏–Ω–∏–º–∞–µ–º 1-2 —Ü–∏—Ñ—Ä—ã –¥–ª—è —á–∞—Å–∞ (–∏ –¥–ª—è minutes/seconds —Ç–æ–∂–µ –ø–æ–∑–≤–æ–ª–∏–º 1-2 –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π)\nfunction parseLocal(value) {\n  const s = cleanLine(value);\n  if (!s) return null;\n\n  // 0) YYYYMMDDTHHMMSS –∏–ª–∏ YYYYMMDDTHHMM\n  let m = s.match(/^(\\d{4})(\\d{2})(\\d{2})T(\\d{1,2})(\\d{1,2})(\\d{1,2})?$/);\n  if (m) {\n    const [_, Y, M, D, h, min, sec] = m;\n    const hh = Number(h);\n    const mm = Number(min);\n    const ss = sec ? Number(sec) : 0;\n    if (!Number.isFinite(hh) || !Number.isFinite(mm) || !Number.isFinite(ss)) return null;\n    if (hh < 0 || hh > 23 || mm < 0 || mm > 59 || ss < 0 || ss > 59) return null;\n    return { Y: +Y, M: +M, D: +D, h: hh, min: mm, s: ss };\n  }\n\n  // 1) YYYY-MM-DD HH:mm(:ss)\n  m = s.match(/^(\\d{4})-(\\d{2})-(\\d{2})[ T](\\d{1,2}):(\\d{1,2})(?::(\\d{1,2}))?$/);\n  if (m) {\n    const [_, Y, M, D, h, min, sec] = m;\n    const hh = Number(h);\n    const mm = Number(min);\n    const ss = sec ? Number(sec) : 0;\n    if (!Number.isFinite(hh) || !Number.isFinite(mm) || !Number.isFinite(ss)) return null;\n    if (hh < 0 || hh > 23 || mm < 0 || mm > 59 || ss < 0 || ss > 59) return null;\n    return { Y: +Y, M: +M, D: +D, h: hh, min: mm, s: ss };\n  }\n\n  // 2) DD.MM.YYYY HH:mm(:ss)\n  m = s.match(/^(\\d{2})\\.(\\d{2})\\.(\\d{4})[ T](\\d{1,2}):(\\d{1,2})(?::(\\d{1,2}))?$/);\n  if (m) {\n    const [_, D, M, Y, h, min, sec] = m;\n    const hh = Number(h);\n    const mm = Number(min);\n    const ss = sec ? Number(sec) : 0;\n    if (!Number.isFinite(hh) || !Number.isFinite(mm) || !Number.isFinite(ss)) return null;\n    if (hh < 0 || hh > 23 || mm < 0 || mm > 59 || ss < 0 || ss > 59) return null;\n    return { Y: +Y, M: +M, D: +D, h: hh, min: mm, s: ss };\n  }\n\n  return null;\n}\n\nfunction isIsoLike(value) {\n  const s = cleanLine(value);\n  return /T/.test(s) || /Z$/.test(s) || /[+-]\\d{2}:\\d{2}$/.test(s);\n}\n\nfunction tzOffsetMinutesAt(utcDate, timeZone) {\n  const dtf = new Intl.DateTimeFormat('en-US', {\n    timeZone,\n    hour12: false,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n  });\n\n  const parts = dtf.formatToParts(utcDate);\n  const map = {};\n  for (const p of parts) if (p.type !== 'literal') map[p.type] = p.value;\n\n  const asIfUtc = Date.UTC(\n    Number(map.year),\n    Number(map.month) - 1,\n    Number(map.day),\n    Number(map.hour),\n    Number(map.minute),\n    Number(map.second),\n  );\n\n  const offsetMs = asIfUtc - utcDate.getTime();\n  return Math.round(offsetMs / 60000);\n}\n\nfunction dateFromLocalInTz(local, timeZone) {\n  const approxUtc = new Date(Date.UTC(local.Y, local.M - 1, local.D, local.h, local.min, local.s, 0));\n\n  const offsetMin1 = tzOffsetMinutesAt(approxUtc, timeZone);\n\n  let utcMs = approxUtc.getTime() - offsetMin1 * 60000;\n  let utcDate = new Date(utcMs);\n\n  const offsetMin2 = tzOffsetMinutesAt(utcDate, timeZone);\n  if (offsetMin2 !== offsetMin1) {\n    utcMs = approxUtc.getTime() - offsetMin2 * 60000;\n    utcDate = new Date(utcMs);\n  }\n\n  return utcDate;\n}\n\nfunction parseDateTimeByTz(value, timeZone) {\n  const v = cleanLine(value);\n  if (!v) return null;\n\n  // ISO —Å–æ —Å–º–µ—â–µ–Ω–∏–µ–º/UTC ‚Äî –ø–∞—Ä—Å–∏–º –Ω–∞–ø—Ä—è–º—É—é\n  if (isIsoLike(v)) {\n    const iso = Date.parse(v);\n    return Number.isNaN(iso) ? null : new Date(iso);\n  }\n\n  // –ò–Ω–∞—á–µ ‚Äî –ª–æ–∫–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è TZ\n  const local = parseLocal(v);\n  if (!local) return null;\n\n  return dateFromLocalInTz(local, timeZone);\n}\n\nfunction parseDateTimeByRegion(value, region) {\n  const tz = regionToTz(region);\n  return parseDateTimeByTz(value, tz);\n}\n\n// ---------------- schedule mini DSL ----------------\n\n/**\n * IMPORTANT FIX:\n * –†–∞–Ω—å—à–µ –º—ã \"—Ä–∞—Å—â–µ–ø–ª—è–ª–∏\" –≤–µ—Å—å schedule –ø–æ ';', –∏–∑-–∑–∞ —á–µ–≥–æ RRULE —Ä–∞–∑–≤–∞–ª–∏–≤–∞–ª—Å—è,\n * –∏ BYDAY —á–∞—Å—Ç–æ —Ç–µ—Ä—è–ª—Å—è (—Å—Ç–∞–Ω–æ–≤–∏–ª—Å—è null).\n *\n * –¢–µ–ø–µ—Ä—å:\n * - –ù–ò–ö–û–ì–î–ê –Ω–µ –¥–µ–ª–∏–º –≤–µ—Å—å —Ç–µ–∫—Å—Ç –ø–æ ';'\n * - –ò—â–µ–º —Å—Ç—Ä–æ–∫–∏ DTSTART / RRULE / TZ / UNTIL –ø–æ –≤—Å–µ–º—É —Ç–µ–∫—Å—Ç—É\n * - ';' –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ –≤–Ω—É—Ç—Ä–∏ rruleRaw (rruleRaw.split(';'))\n */\nfunction parseSchedule(scheduleText) {\n  const raw0 = (scheduleText ?? '').toString();\n  const raw = raw0.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n  if (!cleanLine(raw)) return { ok: false, error: 'schedule empty' };\n\n  const findVal = (key) => {\n    const re = new RegExp(`(?:^|\\\\n)\\\\s*${key}(?:;[^:=]*)?\\\\s*[:=]\\\\s*(.+?)\\\\s*(?=\\\\n|$)`, 'i');\n    const m = raw.match(re);\n    return m ? cleanLine(m[1]) : null;\n  };\n\n  const tz = findVal('TZ');\n  const dtstartRaw = findVal('DTSTART');\n  const rruleRaw = findVal('RRULE');\n  const untilRaw = findVal('UNTIL');\n\n  if (!dtstartRaw) return { ok: false, error: 'DTSTART missing' };\n  if (!rruleRaw) return { ok: false, error: 'RRULE missing' };\n\n  const props = {};\n  for (const part0 of rruleRaw.split(';')) {\n    const part = cleanLine(part0);\n    if (!part) continue;\n\n    const eq = part.indexOf('=');\n    if (eq <= 0) continue;\n\n    const k = cleanLine(part.slice(0, eq)).toUpperCase();\n    const v = cleanLine(part.slice(eq + 1));\n    if (!k || v == null) continue;\n\n    props[k] = v;\n  }\n\n  const freq = (props.FREQ || '').toUpperCase();\n  if (!['DAILY', 'WEEKLY', 'MONTHLY'].includes(freq)) {\n    return { ok: false, error: `Unsupported FREQ=${props.FREQ || ''}` };\n  }\n\n  const interval = props.INTERVAL ? Math.max(1, Number(props.INTERVAL)) : 1;\n  const count = props.COUNT ? Math.max(1, Number(props.COUNT)) : null;\n  const untilStr = props.UNTIL || untilRaw || null;\n\n  const byday = props.BYDAY\n    ? props.BYDAY.split(',').map(s => cleanLine(s).toUpperCase()).filter(Boolean)\n    : null;\n\n  const byhour = props.BYHOUR != null\n    ? props.BYHOUR.split(',').map(x => Number(cleanLine(x)))\n    : null;\n\n  const byminute = props.BYMINUTE != null\n    ? props.BYMINUTE.split(',').map(x => Number(cleanLine(x)))\n    : null;\n\n  return { ok: true, tz, dtstartRaw, freq, interval, count, untilStr, byday, byhour, byminute, raw: { rruleRaw, scheduleRaw: raw } };\n}\n\nfunction formatPartsYMDInTz(utcDate, tz) {\n  const parts = new Intl.DateTimeFormat('en-US', {\n    timeZone: tz,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n  }).formatToParts(utcDate);\n\n  const map = {};\n  for (const p of parts) if (p.type !== 'literal') map[p.type] = p.value;\n\n  return { y: Number(map.year), m: Number(map.month), d: Number(map.day) };\n}\n\nfunction localYmdHmsToUtc(y, m, d, hh, mm, ss, tz) {\n  return dateFromLocalInTz({ Y: y, M: m, D: d, h: hh, min: mm, s: ss }, tz);\n}\n\nfunction addDaysUtc(date, days) {\n  return new Date(date.getTime() + days * 86400000);\n}\n\nfunction addWeeksUtc(date, weeks) {\n  return addDaysUtc(date, weeks * 7);\n}\n\nfunction addMonthsUtc(date, months) {\n  const y = date.getUTCFullYear();\n  const m = date.getUTCMonth();\n  const d = date.getUTCDate();\n  const hh = date.getUTCHours();\n  const mm = date.getUTCMinutes();\n  const ss = date.getUTCSeconds();\n\n  const targetMonthIndex = m + months;\n  const targetY = y + Math.floor(targetMonthIndex / 12);\n  const targetM = ((targetMonthIndex % 12) + 12) % 12;\n\n  const lastDay = new Date(Date.UTC(targetY, targetM + 1, 0)).getUTCDate();\n  const clampedD = Math.min(d, lastDay);\n\n  return new Date(Date.UTC(targetY, targetM, clampedD, hh, mm, ss));\n}\n\nfunction makeRunKeyLocal(postId, tz, occurrenceUtc) {\n  const id = (postId ?? 'unknown').toString();\n  const local = new Intl.DateTimeFormat('en-CA', {\n    timeZone: tz,\n    hour12: false,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n  }).format(occurrenceUtc).replace(', ', ' ');\n  return `post:${id}|${tz}|${local}`;\n}\n\n/**\n * Stable weekday for a LOCAL date (y,m,d) in timezone tz.\n * We convert local noon to UTC and then format weekday in tz.\n * Noon avoids boundary issues around midnight and DST.\n * Returns two-letter codes: MO,TU,WE,TH,FR,SA,SU.\n */\nfunction weekdayFromLocalYmd(y, m, d, tz) {\n  const probeUtc = localYmdHmsToUtc(y, m, d, 12, 0, 0, tz);\n  const w = new Intl.DateTimeFormat('en-US', { timeZone: tz, weekday: 'short' })\n    .format(probeUtc)\n    .slice(0, 2)\n    .toUpperCase();\n  return w;\n}\n\nfunction findLastOccurrenceUtc({ tz, dtstartUtc, dtstartLocalParts, rule, untilUtc, nowUtc }) {\n  let windowStartUtc;\n  if (rule.freq === 'DAILY') windowStartUtc = new Date(nowUtc.getTime() - 40 * 86400000);\n  else if (rule.freq === 'WEEKLY') windowStartUtc = new Date(nowUtc.getTime() - 26 * 7 * 86400000);\n  else windowStartUtc = new Date(nowUtc.getTime() - 24 * 31 * 86400000);\n\n  if (windowStartUtc < dtstartUtc) windowStartUtc = dtstartUtc;\n  const windowEndUtc = nowUtc;\n\n  const defaultH = dtstartLocalParts.h;\n  const defaultM = dtstartLocalParts.min;\n  const defaultS = dtstartLocalParts.s;\n\n  const hours = rule.byhour && rule.byhour.length ? rule.byhour : [defaultH];\n  const minutes = rule.byminute && rule.byminute.length ? rule.byminute : [defaultM];\n\n  let last = null;\n  let produced = 0;\n  const maxProduced = 5000;\n\n  if (rule.freq === 'DAILY') {\n    let cursor = new Date(Date.UTC(\n      windowStartUtc.getUTCFullYear(),\n      windowStartUtc.getUTCMonth(),\n      windowStartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    const dt0 = new Date(Date.UTC(\n      dtstartUtc.getUTCFullYear(),\n      dtstartUtc.getUTCMonth(),\n      dtstartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    let diffDays = Math.floor((cursor.getTime() - dt0.getTime()) / 86400000);\n    if (diffDays < 0) diffDays = 0;\n    const mod = diffDays % rule.interval;\n    if (mod !== 0) cursor = addDaysUtc(cursor, rule.interval - mod);\n\n    while (cursor <= windowEndUtc && produced < maxProduced) {\n      const ymd = formatPartsYMDInTz(cursor, tz);\n\n      if (rule.byday && rule.byday.length) {\n        const localWday = weekdayFromLocalYmd(ymd.y, ymd.m, ymd.d, tz);\n        if (!rule.byday.includes(localWday)) {\n          cursor = addDaysUtc(cursor, rule.interval);\n          continue;\n        }\n      }\n\n      for (const hh of hours) {\n        for (const mm of minutes) {\n          const occUtc = localYmdHmsToUtc(ymd.y, ymd.m, ymd.d, hh, mm, defaultS, tz);\n          if (occUtc < dtstartUtc) continue;\n          if (untilUtc && occUtc > untilUtc) continue;\n          if (occUtc < windowStartUtc || occUtc > windowEndUtc) continue;\n\n          produced++;\n          if (rule.count && produced > rule.count) return last;\n\n          if (!last || occUtc > last) last = occUtc;\n          if (produced >= maxProduced) break;\n        }\n        if (produced >= maxProduced) break;\n      }\n\n      cursor = addDaysUtc(cursor, rule.interval);\n    }\n  }\n\n  if (rule.freq === 'WEEKLY') {\n    const dtLocalWday = weekdayFromLocalYmd(dtstartLocalParts.Y, dtstartLocalParts.M, dtstartLocalParts.D, tz);\n    const days = (rule.byday && rule.byday.length) ? rule.byday : [dtLocalWday];\n\n    let cursorWeekStart = new Date(Date.UTC(\n      windowStartUtc.getUTCFullYear(),\n      windowStartUtc.getUTCMonth(),\n      windowStartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    const dt0 = new Date(Date.UTC(\n      dtstartUtc.getUTCFullYear(),\n      dtstartUtc.getUTCMonth(),\n      dtstartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    let diffDays = Math.floor((cursorWeekStart.getTime() - dt0.getTime()) / 86400000);\n    if (diffDays < 0) diffDays = 0;\n    const diffWeeks = Math.floor(diffDays / 7);\n    const mod = diffWeeks % rule.interval;\n    if (mod !== 0) cursorWeekStart = addWeeksUtc(cursorWeekStart, rule.interval - mod);\n\n    while (cursorWeekStart <= windowEndUtc && produced < maxProduced) {\n      for (let i = 0; i < 7; i++) {\n        const dayUtc = addDaysUtc(cursorWeekStart, i);\n        const ymd = formatPartsYMDInTz(dayUtc, tz);\n        const localWday = weekdayFromLocalYmd(ymd.y, ymd.m, ymd.d, tz);\n\n        if (!days.includes(localWday)) continue;\n\n        for (const hh of hours) {\n          for (const mm of minutes) {\n            const occUtc = localYmdHmsToUtc(ymd.y, ymd.m, ymd.d, hh, mm, defaultS, tz);\n            if (occUtc < dtstartUtc) continue;\n            if (untilUtc && occUtc > untilUtc) continue;\n            if (occUtc < windowStartUtc || occUtc > windowEndUtc) continue;\n\n            produced++;\n            if (rule.count && produced > rule.count) return last;\n\n            if (!last || occUtc > last) last = occUtc;\n            if (produced >= maxProduced) break;\n          }\n          if (produced >= maxProduced) break;\n        }\n      }\n\n      cursorWeekStart = addWeeksUtc(cursorWeekStart, rule.interval);\n    }\n  }\n\n  if (rule.freq === 'MONTHLY') {\n    let cursor = dtstartUtc;\n    let iterations = 0;\n    const maxIter = 300;\n\n    while (cursor < windowStartUtc && iterations < maxIter) {\n      cursor = addMonthsUtc(cursor, rule.interval);\n      iterations++;\n    }\n\n    while (cursor <= windowEndUtc && iterations < maxIter && produced < maxProduced) {\n      const ymd = formatPartsYMDInTz(cursor, tz);\n\n      for (const hh of hours) {\n        for (const mm of minutes) {\n          const occUtc = localYmdHmsToUtc(ymd.y, ymd.m, ymd.d, hh, mm, defaultS, tz);\n          if (occUtc < dtstartUtc) continue;\n          if (untilUtc && occUtc > untilUtc) continue;\n          if (occUtc < windowStartUtc || occUtc > windowEndUtc) continue;\n\n          produced++;\n          if (rule.count && produced > rule.count) return last;\n\n          if (!last || occUtc > last) last = occUtc;\n          if (produced >= maxProduced) break;\n        }\n        if (produced >= maxProduced) break;\n      }\n\n      cursor = addMonthsUtc(cursor, rule.interval);\n      iterations++;\n    }\n  }\n\n  return last;\n}\n\n// NEW: find next occurrence strictly after nowUtc\nfunction findNextOccurrenceUtc({ tz, dtstartUtc, dtstartLocalParts, rule, untilUtc, nowUtc }) {\n  const windowStartUtc = nowUtc;\n  let windowEndUtc;\n  if (rule.freq === 'DAILY') windowEndUtc = new Date(nowUtc.getTime() + 60 * 86400000);\n  else if (rule.freq === 'WEEKLY') windowEndUtc = new Date(nowUtc.getTime() + 60 * 7 * 86400000);\n  else windowEndUtc = new Date(nowUtc.getTime() + 24 * 31 * 86400000);\n\n  if (untilUtc && untilUtc < windowEndUtc) windowEndUtc = untilUtc;\n\n  const defaultH = dtstartLocalParts.h;\n  const defaultM = dtstartLocalParts.min;\n  const defaultS = dtstartLocalParts.s;\n\n  const hours = rule.byhour && rule.byhour.length ? rule.byhour : [defaultH];\n  const minutes = rule.byminute && rule.byminute.length ? rule.byminute : [defaultM];\n\n  let best = null;\n  let produced = 0;\n  const maxProduced = 5000;\n\n  if (rule.freq === 'DAILY') {\n    let cursor = new Date(Date.UTC(\n      windowStartUtc.getUTCFullYear(),\n      windowStartUtc.getUTCMonth(),\n      windowStartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    const dt0 = new Date(Date.UTC(\n      dtstartUtc.getUTCFullYear(),\n      dtstartUtc.getUTCMonth(),\n      dtstartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    let diffDays = Math.floor((cursor.getTime() - dt0.getTime()) / 86400000);\n    if (diffDays < 0) diffDays = 0;\n    const mod = diffDays % rule.interval;\n    if (mod !== 0) cursor = addDaysUtc(cursor, rule.interval - mod);\n\n    while (cursor <= windowEndUtc && produced < maxProduced) {\n      const ymd = formatPartsYMDInTz(cursor, tz);\n\n      if (rule.byday && rule.byday.length) {\n        const localWday = weekdayFromLocalYmd(ymd.y, ymd.m, ymd.d, tz);\n        if (!rule.byday.includes(localWday)) {\n          cursor = addDaysUtc(cursor, rule.interval);\n          continue;\n        }\n      }\n\n      for (const hh of hours) {\n        for (const mm of minutes) {\n          const occUtc = localYmdHmsToUtc(ymd.y, ymd.m, ymd.d, hh, mm, defaultS, tz);\n          if (occUtc < dtstartUtc) continue;\n          if (untilUtc && occUtc > untilUtc) continue;\n          if (occUtc <= windowStartUtc) continue;\n          if (occUtc > windowEndUtc) continue;\n\n          produced++;\n          if (rule.count && produced > rule.count) return best;\n\n          if (!best || occUtc < best) best = occUtc;\n          if (best) return best;\n        }\n      }\n\n      cursor = addDaysUtc(cursor, rule.interval);\n    }\n  }\n\n  if (rule.freq === 'WEEKLY') {\n    const dtLocalWday = weekdayFromLocalYmd(dtstartLocalParts.Y, dtstartLocalParts.M, dtstartLocalParts.D, tz);\n    const days = (rule.byday && rule.byday.length) ? rule.byday : [dtLocalWday];\n\n    let cursorWeekStart = new Date(Date.UTC(\n      windowStartUtc.getUTCFullYear(),\n      windowStartUtc.getUTCMonth(),\n      windowStartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    const dt0 = new Date(Date.UTC(\n      dtstartUtc.getUTCFullYear(),\n      dtstartUtc.getUTCMonth(),\n      dtstartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    let diffDays = Math.floor((cursorWeekStart.getTime() - dt0.getTime()) / 86400000);\n    if (diffDays < 0) diffDays = 0;\n    const diffWeeks = Math.floor(diffDays / 7);\n    const mod = diffWeeks % rule.interval;\n    if (mod !== 0) cursorWeekStart = addWeeksUtc(cursorWeekStart, rule.interval - mod);\n\n    while (cursorWeekStart <= windowEndUtc && produced < maxProduced) {\n      for (let i = 0; i < 7; i++) {\n        const dayUtc = addDaysUtc(cursorWeekStart, i);\n        const ymd = formatPartsYMDInTz(dayUtc, tz);\n        const localWday = weekdayFromLocalYmd(ymd.y, ymd.m, ymd.d, tz);\n\n        if (!days.includes(localWday)) continue;\n\n        for (const hh of hours) {\n          for (const mm of minutes) {\n            const occUtc = localYmdHmsToUtc(ymd.y, ymd.m, ymd.d, hh, mm, defaultS, tz);\n            if (occUtc < dtstartUtc) continue;\n            if (untilUtc && occUtc > untilUtc) continue;\n            if (occUtc <= windowStartUtc) continue;\n            if (occUtc > windowEndUtc) continue;\n\n            produced++;\n            if (rule.count && produced > rule.count) return best;\n\n            if (!best || occUtc < best) best = occUtc;\n            if (best) return best;\n          }\n        }\n      }\n\n      cursorWeekStart = addWeeksUtc(cursorWeekStart, rule.interval);\n    }\n  }\n\n  if (rule.freq === 'MONTHLY') {\n    let cursor = dtstartUtc;\n    let iterations = 0;\n    const maxIter = 300;\n\n    while (cursor <= windowStartUtc && iterations < maxIter) {\n      cursor = addMonthsUtc(cursor, rule.interval);\n      iterations++;\n    }\n\n    while (cursor <= windowEndUtc && iterations < maxIter && produced < maxProduced) {\n      const ymd = formatPartsYMDInTz(cursor, tz);\n\n      for (const hh of hours) {\n        for (const mm of minutes) {\n          const occUtc = localYmdHmsToUtc(ymd.y, ymd.m, ymd.d, hh, mm, defaultS, tz);\n          if (occUtc < dtstartUtc) continue;\n          if (untilUtc && occUtc > untilUtc) continue;\n          if (occUtc <= windowStartUtc) continue;\n          if (occUtc > windowEndUtc) continue;\n\n          produced++;\n          if (rule.count && produced > rule.count) return best;\n\n          if (!best || occUtc < best) best = occUtc;\n          if (best) return best;\n        }\n      }\n\n      cursor = addMonthsUtc(cursor, rule.interval);\n      iterations++;\n    }\n  }\n\n  return best;\n}\n\n// ---------------- main ----------------\n\nconst items = $input.all();\nconst nowUtc = new Date();\n\nreturn items.map(item => {\n  const p = item.json;\n\n  const tzRegion = regionToTz(p.region);\n\n  let due = false;\n  let reason = null;\n\n  // –Ω–∞—Ä—É–∂–Ω—ã–µ –ø–æ–ª—è\n  const nowLocal = formatLocalHuman(nowUtc, tzRegion);\n\n  let publishUtc = null;\n  let publishLocal = null;\n\n  let occurrenceUtc = null;\n  let occurrenceLocal = null;\n\n  let runKey = null;\n  let scheduleParsed = null;\n\n  // NEW plan\n  let planRunUtc = null;\n  let planRunLocal = null;\n\n  if (p.post_type === 2) {\n    publishUtc = parseDateTimeByRegion(p.publish_at, p.region);\n    publishLocal = publishUtc ? formatLocalHuman(publishUtc, tzRegion) : null;\n\n    if (!publishUtc) {\n      reason = 'one-time post without valid publish_at';\n    } else {\n      // –¥–ª—è —Ä–∞–∑–æ–≤–æ–≥–æ –ø–æ—Å—Ç–∞ occurrence = publish_at\n      occurrenceUtc = publishUtc;\n      occurrenceLocal = formatLocalHuman(occurrenceUtc, tzRegion);\n\n      // —Ñ–æ—Ä–º–∏—Ä—É–µ–º –∫–ª—é—á –∑–∞—Ä–∞–Ω–µ–µ (–∞–Ω—Ç–∏–¥—É–±–ª—å –∫–∞–∫ —É —Ä–µ–≥—É–ª—è—Ä–Ω—ã—Ö)\n      runKey = makeRunKeyLocal(p.id, tzRegion, occurrenceUtc);\n\n      const alreadyKey = (p.last_run_key ?? '').toString().trim();\n      if (alreadyKey === runKey) {\n        due = false;\n        reason = 'one-time: already executed (last_run_key match)';\n      } else {\n        // –∑–∞–ø–∞—Å–Ω–æ–π —Å—Ç–æ–ø–æ—Ä –ø–æ last_run_at_utc (–µ—Å–ª–∏ –∫–ª—é—á –ø–æ—á–µ–º—É-—Ç–æ –Ω–µ –ø–∏—Å–∞–ª—Å—è)\n        const lastRunAtUtc = p.last_run_at_utc ? new Date(p.last_run_at_utc) : null;\n        if (lastRunAtUtc && !isNaN(lastRunAtUtc.getTime())) {\n          if (lastRunAtUtc.getTime() >= occurrenceUtc.getTime() - 30 * 1000) {\n            due = false;\n            reason = 'one-time: already executed (last_run_at_utc >= publish_at)';\n          } else if (publishUtc <= nowUtc) {\n            due = true;\n            reason = 'due now (publish_at <= now) in region tz';\n          } else {\n            due = false;\n            reason = 'not yet (publish_at in future) in region tz';\n          }\n        } else {\n          if (publishUtc <= nowUtc) {\n            due = true;\n            reason = 'due now (publish_at <= now) in region tz';\n          } else {\n            due = false;\n            reason = 'not yet (publish_at in future) in region tz';\n          }\n        }\n      }\n    }\n  } else if (p.post_type === 1) {\n    if (!p.schedule) {\n      reason = 'regular post without schedule';\n    } else {\n      const parsed = parseSchedule(p.schedule);\n      if (!parsed.ok) {\n        reason = `schedule parse error: ${parsed.error}`;\n      } else {\n        const tz = parsed.tz || tzRegion;\n\n        const dtstartLocal = parseLocal(parsed.dtstartRaw);\n        if (!dtstartLocal) {\n          reason = 'DTSTART parse error';\n        } else {\n          const dtstartUtc = dateFromLocalInTz(dtstartLocal, tz);\n\n          let untilUtc = null;\n          if (parsed.untilStr) {\n            const u = parseDateTimeByTz(parsed.untilStr, tz);\n            if (!u) reason = 'UNTIL parse error';\n            else untilUtc = u;\n          }\n\n          if (!reason) {\n            const rule = {\n              freq: parsed.freq,\n              interval: parsed.interval,\n              count: parsed.count,\n              byday: parsed.byday,\n              byhour: parsed.byhour,\n              byminute: parsed.byminute,\n            };\n\n            scheduleParsed = {\n              tz,\n              dtstart_local: parsed.dtstartRaw,\n              dtstart_utc: dtstartUtc.toISOString(),\n              rule,\n              until_utc: untilUtc ? untilUtc.toISOString() : null,\n              raw: parsed.raw, // —á—Ç–æ–±—ã –≤–∏–¥–µ—Ç—å rruleRaw/scheduleRaw –≤ –¥–µ–±–∞–≥–µ\n            };\n\n            const lastOcc = findLastOccurrenceUtc({\n              tz,\n              dtstartUtc,\n              dtstartLocalParts: dtstartLocal,\n              rule,\n              untilUtc,\n              nowUtc,\n            });\n\n            const nextOcc = findNextOccurrenceUtc({\n              tz,\n              dtstartUtc,\n              dtstartLocalParts: dtstartLocal,\n              rule,\n              untilUtc,\n              nowUtc,\n            });\n\n            if (nextOcc) {\n              planRunUtc = nextOcc;\n              planRunLocal = formatLocalHuman(nextOcc, tz);\n            } else {\n              planRunUtc = null;\n              planRunLocal = null;\n            }\n\n            if (!lastOcc) {\n              // FIX: –∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –ø—Ä–∏—á–∏–Ω–∞, –∫–æ–≥–¥–∞ DTSTART –µ—â—ë –Ω–µ –Ω–∞—Å—Ç—É–ø–∏–ª (–≤ –±—É–¥—É—â–µ–º)\n              if (dtstartUtc > nowUtc) {\n                due = false;\n                reason = 'recurring: not yet started (DTSTART in future)';\n              } else {\n                // –µ—Å–ª–∏ DTSTART —É–∂–µ –±—ã–ª –≤ –ø—Ä–æ—à–ª–æ–º, –Ω–æ –≤ lookback –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞—à–ª–∏\n                due = false;\n                reason = 'recurring: no occurrence found in lookback window';\n              }\n            } else {\n              occurrenceUtc = lastOcc;\n              occurrenceLocal = formatLocalHuman(occurrenceUtc, tz);\n              runKey = makeRunKeyLocal(p.id, tz, occurrenceUtc);\n\n              const alreadyKey = (p.last_run_key ?? '').toString().trim();\n              if (alreadyKey === runKey) {\n                due = false;\n                reason = 'recurring: already executed (last_run_key match)';\n              } else {\n                // secondary: last_run_at_utc (–Ω–∞–¥–µ–∂–Ω–æ –ø–∞—Ä—Å–∏—Ç—Å—è)\n                const lastRunAtUtc = p.last_run_at_utc ? new Date(p.last_run_at_utc) : null;\n                if (lastRunAtUtc && !isNaN(lastRunAtUtc.getTime())) {\n                  if (lastRunAtUtc.getTime() >= occurrenceUtc.getTime() - 30 * 1000) {\n                    due = false;\n                    reason = 'recurring: already executed (last_run_at_utc >= occurrence)';\n                  } else {\n                    due = true;\n                    reason = 'recurring: occurrence <= now and not executed';\n                  }\n                } else {\n                  due = true;\n                  reason = 'recurring: occurrence <= now and not executed';\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } else {\n    reason = 'unknown post_type';\n  }\n\n  return {\n    json: {\n      ...p,\n      _due: due,\n      _due_reason: reason,\n\n      // –ª–æ–∫–∞–ª—å–Ω–æ–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ\n      _now: nowLocal,\n      _publish_at_parsed: publishLocal,\n      _occurrence_local: occurrenceLocal,\n\n      // UTC —Ç–µ—Ö–Ω–∏—á–∫–∞ (–¥–ª—è –∑–∞–ø–∏—Å–∏)\n      _now_utc: nowUtc.toISOString(),\n      _occurrence_utc: occurrenceUtc ? occurrenceUtc.toISOString() : null,\n\n      _run_key: runKey,\n      _schedule_parsed: scheduleParsed,\n\n      // NEW: next planned run (for regular posts)\n      _plan_run_at: planRunLocal,\n      _plan_run_at_utc: planRunUtc ? planRunUtc.toISOString() : null,\n    },\n  };\n});\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[3104,2048],"id":"cfa31da3-5e32-4547-a674-da9a457bf923","name":"Determine due"},{"parameters":{"rule":{"interval":[{"field":"minutes"}]}},"type":"n8n-nodes-base.scheduleTrigger","typeVersion":1.3,"position":[1008,2464],"id":"dc3da621-fe8a-46a7-8e70-c2f9db460833","name":"Schedule Trigger"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"loose","version":3},"conditions":[{"id":"d7859595-c40c-40cf-9885-a94c7a7296ba","leftValue":"={{$json.send_vk}}","rightValue":"true","operator":{"type":"boolean","operation":"true","singleValue":true}}],"combinator":"and"},"looseTypeValidation":true,"options":{}},"type":"n8n-nodes-base.filter","typeVersion":2.3,"position":[4736,1312],"id":"645816a9-4937-4d7d-8fdd-6d65d4102468","name":"Filter VK"},{"parameters":{"method":"POST","url":"https://api.vk.com/method/wall.post","sendBody":true,"contentType":"form-urlencoded","bodyParameters":{"parameters":[{"name":"owner_id","value":"=-114286850"},{"name":"from_group","value":"1"},{"name":"message","value":"={{$json.vk_message}}"},{"name":"access_token","value":"vk1.a.9nMQFYamjyb6V0wTTCDK_pi4ehFyFKa5c3ZLsizknn-4Vl0blAibzoQIy04vhvKoUmbOhVu7sKox2btvhT0ltZFsd5k97BjMGmlxSqb5YZnHc-_S6HN-o2XlkZQcM5lh5jmYRLupjGqKo2KfrO0EGLxgdEJrK6OeEp4NRcN0wDqVlWuAfUCGFZnBPUNbbbDq7kWuvJ4BmoLzbP8ZRzEHYQ"},{"name":"v","value":"5.131"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[5488,1104],"id":"b6efc021-1670-4dd1-b867-8dd1f7b8304a","name":"VK wall.post","onError":"continueRegularOutput"},{"parameters":{"jsCode":"/**\n * Collect VK results per post_id (after Merge Combine/Position)\n *\n * Supports VK API responses from HTTP Request node (wall.post), which typically return:\n *  - Success: { response: { post_id: 123, ... } }\n *  - Error:   { error: { error_code: 214, error_msg: \"...\", error_text: \"...\", request_params: [...] } }\n *\n * But n8n can wrap HTTP responses as:\n *  - { statusCode: 200, body: { response:{...} } }  (when Response Format = JSON)\n *  - { statusCode: 200, body: \"...\" }              (string)\n *  - errors in p.error / p.message / p.response / p.body\n *\n * Output: one item per post_id with aggregation + Sheets update-like fields\n * (Note: do NOT write last_run_* here if you plan to require TG+VK together;\n *        you can still output vk_ok/vk_fail counts and update_error here.)\n */\n\nconst items = $input.all();\n\nfunction safeStr(v) {\n  if (v === null || v === undefined) return '';\n  return String(v);\n}\n\nfunction toNumOrNull(v) {\n  if (v === null || v === undefined || v === '') return null;\n  const n = Number(v);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction appendLog(existing, line) {\n  const base = (existing ?? '').toString().trim();\n  if (!base) return line;\n  return base + '\\n' + line;\n}\n\nfunction tryJsonParse(s) {\n  try {\n    return JSON.parse(s);\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction unwrapBody(p) {\n  // n8n HTTP Request may expose body at top-level or nested\n  const body = p?.body ?? p?.response?.body ?? p?.responseBody ?? null;\n\n  if (body && typeof body === 'object') return body;\n\n  if (typeof body === 'string') {\n    const j = tryJsonParse(body);\n    if (j && typeof j === 'object') return j;\n  }\n\n  // Sometimes response itself is the VK json\n  if (p && typeof p === 'object') {\n    if (p.response && typeof p.response === 'object') return p.response;\n    // if p has response/error at top-level, return p itself\n    if (p.response || p.error) return p;\n  }\n\n  return null;\n}\n\nfunction detectOk(p) {\n  if (!p) return false;\n\n  // Direct VK shape\n  if (p.response && typeof p.response === 'object' && (p.response.post_id || p.response.post_id === 0)) {\n    return true;\n  }\n\n  const b = unwrapBody(p);\n  if (b) {\n    if (b.response && typeof b.response === 'object' && (b.response.post_id || b.response.post_id === 0)) {\n      return true;\n    }\n    // VK sometimes returns \"response\": 1 for some methods, but wall.post should return object\n    if (typeof b.response === 'number' && b.response > 0) return true;\n  }\n\n  // Fallback: if statusCode is 2xx but VK error not visible, treat as ok (avoid false FAIL)\n  const sc = p.statusCode ?? p.status ?? p.response?.statusCode ?? null;\n  if (typeof sc === 'number' && sc >= 200 && sc < 300) {\n    const bb = b;\n    if (bb && bb.error) return false;\n    return true;\n  }\n\n  return false;\n}\n\nfunction extractErrorText(p) {\n  if (!p) return 'unknown error';\n\n  // n8n error object\n  if (typeof p.error === 'string') return p.error;\n  if (p.error?.message) return safeStr(p.error.message);\n  if (p.errorMessage) return safeStr(p.errorMessage);\n  if (p.message) return safeStr(p.message);\n  if (p.description) return safeStr(p.description);\n  if (p.cause) return safeStr(p.cause);\n\n  // VK error shape\n  const b = unwrapBody(p);\n  const errObj = b?.error ?? p?.error ?? null;\n\n  if (errObj && typeof errObj === 'object') {\n    const code = errObj.error_code ?? errObj.code ?? null;\n    const msg = errObj.error_msg ?? errObj.message ?? errObj.error_text ?? null;\n    if (code !== null || msg) {\n      return `vk_error${code !== null ? `#${safeStr(code)}` : ''}: ${safeStr(msg || 'unknown')}`.trim();\n    }\n    try {\n      return JSON.stringify(errObj);\n    } catch (e) {\n      return 'unstringifiable vk error';\n    }\n  }\n\n  // Raw body as string\n  const rawBody = p.body ?? p.response?.body ?? p.responseBody ?? null;\n  if (typeof rawBody === 'string') {\n    const s = rawBody.trim();\n    if (s) return s.slice(0, 500);\n  }\n\n  // Last resort\n  try {\n    return JSON.stringify(p).slice(0, 500);\n  } catch (e) {\n    return 'unknown error';\n  }\n}\n\nfunction extractVkPostId(p) {\n  const b = unwrapBody(p);\n  const direct = p?.response?.post_id ?? null;\n  if (direct !== null && direct !== undefined) return direct;\n\n  const pid = b?.response?.post_id ?? null;\n  if (pid !== null && pid !== undefined) return pid;\n\n  return null;\n}\n\n// group per post_id\nconst byPost = new Map();\n\nfor (const item of items) {\n  const p = item.json || {};\n\n  const postId = p.post_id ?? p.id ?? null;\n  if (!postId) continue;\n\n  if (!byPost.has(postId)) {\n    byPost.set(postId, {\n      post_id: postId,\n      row_number: toNumOrNull(p.row_number),\n\n      last_run_key: p._run_key ?? null,\n      now_utc: p._now_utc ?? new Date().toISOString(),\n      now_local: p._now ?? null,\n\n      plan_run_at: p._plan_run_at ?? null,\n      prev_error: p.error_prev ?? null,\n\n      total: 0,\n      ok: 0,\n      fail: 0,\n      fails: [],\n      vk_post_ids: [],\n    });\n  }\n\n  const agg = byPost.get(postId);\n\n  if (!agg.plan_run_at && p._plan_run_at) agg.plan_run_at = p._plan_run_at;\n\n  agg.total += 1;\n\n  const ok = detectOk(p);\n\n  if (ok) {\n    agg.ok += 1;\n    const vkPid = extractVkPostId(p);\n    if (vkPid !== null && vkPid !== undefined) agg.vk_post_ids.push(vkPid);\n  } else {\n    agg.fail += 1;\n    const desc = extractErrorText(p);\n    agg.fails.push({ desc: safeStr(desc) });\n  }\n}\n\nconst out = [];\n\nfor (const agg of byPost.values()) {\n  // success only if at least one ok and no fails\n  const allOk = agg.fail === 0 && agg.ok > 0;\n\n  let newError = agg.prev_error;\n\n  if (allOk) {\n    const vkInfo = agg.vk_post_ids.length ? ` vk_post_id=${safeStr(agg.vk_post_ids[0])}` : '';\n    newError = appendLog(\n      newError,\n      `[OK VK] ${agg.now_utc} key=${safeStr(agg.last_run_key)} sent=${agg.ok}/${agg.total}${vkInfo}`\n    );\n  } else {\n    const failLines = agg.fails\n      .slice(0, 20)\n      .map(f => `err=${safeStr(f.desc)}`)\n      .join(' | ');\n\n    newError = appendLog(\n      newError,\n      `[FAIL VK] ${agg.now_utc} key=${safeStr(agg.last_run_key)} ok=${agg.ok}/${agg.total} fails=${agg.fail}` +\n        (failLines ? ` :: ${failLines}` : '')\n    );\n  }\n\n  out.push({\n    json: {\n      post_id: agg.post_id,\n      row_number: agg.row_number,\n\n      _vk_all_ok: allOk,\n      _vk_sent_ok: agg.ok,\n      _vk_sent_fail: agg.fail,\n      _vk_sent_total: agg.total,\n\n      // Keep these in case you want final aggregator to decide.\n      update_last_run_at_utc: allOk ? agg.now_utc : null,\n      update_last_run_at: allOk ? agg.now_local : null,\n      update_last_run_key: allOk ? agg.last_run_key : null,\n\n      // write plan_run_at only on success\n      update_plan_run_at: allOk ? (agg.plan_run_at ?? null) : null,\n\n      update_error: newError,\n\n      // optional: useful for debugging\n      vk_post_ids: agg.vk_post_ids,\n    },\n  });\n}\n\nreturn out;\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[6128,1584],"id":"c8cbf6e2-83da-40ef-9181-078c3b5179db","name":"Collect VK results"},{"parameters":{"assignments":{"assignments":[{"id":"40cb9769-3d4e-4419-ba2d-1f2a143fc134","name":"row_number","value":"={{$json.row_number}}","type":"number"},{"id":"4a693b1b-a451-4be0-804e-dcea42cce4f1","name":"_run_key","value":"={{$json._run_key}}","type":"string"},{"id":"263354fa-7b27-48e5-b64f-e9782fe9f1c1","name":"_now","value":"{{$json._now}}","type":"string"},{"id":"800fee7f-bd57-43da-a970-c201ffd9f0d8","name":"error_prev","value":"={{$json.error}}","type":"string"},{"id":"d11608cf-910a-411d-86a7-b8de74c810b0","name":"vk_message","value":"={{$json.text}}","type":"string"},{"id":"a07aa251-a83a-4292-a9f6-c2791dcb2e72","name":"vk_owner_id","value":-114286850,"type":"number"},{"id":"c1320c28-2609-4d0a-81aa-a8913fd7433e","name":"_now_utc","value":"={{$json._now_utc}}","type":"string"},{"id":"e0226193-b507-45ff-8837-b96011bef7fb","name":"send_vk","value":"={{$json.send_vk}}","type":"boolean"},{"id":"6d495acc-0a1d-46cc-ba04-7a4b2f9b0cc6","name":"post_id","value":"={{$json.id}}","type":"number"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[5136,1216],"id":"772442fc-136a-4f25-86de-36452654bc89","name":"VK Edit Fields","onError":"continueRegularOutput"},{"parameters":{"mode":"combine","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5632,1568],"id":"936cdbd8-289b-42d5-91bb-4e6619a3f7b2","name":"Merge VK"},{"parameters":{"jsCode":"// Loop over input items and add a new field called 'myNewField' to the JSON of each one\nfor (const item of $input.all()) {\n  item.json.myNewField = 1;\n}\n\nreturn $input.all();"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[6336,1584],"id":"5587c728-c95b-4fa6-8641-f7a650eb6c28","name":"Code in JavaScript1"},{"parameters":{"numberInputs":3},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[7728,1824],"id":"b2131a10-2787-4835-b4b0-cb1cd74d8bfb","name":"Merge6"},{"parameters":{"jsCode":"/**\n * Final Collect (TG + VK + MAX) per post_id\n *\n * Input: mixed items from:\n *  - Collect TG results\n *  - Collect VK results\n *  - Collect MAX results\n *\n * Goal:\n *  - decide final _all_ok ONLY when all enabled channels succeeded\n *  - build one aggregated update_error log per post\n *  - output ONE item per post_id with fields for Google Sheets update:\n *      - update_last_run_at_utc / update_last_run_at / update_last_run_key / update_plan_run_at (ONLY if _all_ok)\n *      - update_error (always)\n */\n\nconst items = $input.all();\n\nfunction safeStr(v) {\n  if (v === null || v === undefined) return '';\n  return String(v);\n}\n\nfunction toBoolOrNull(v) {\n  if (v === null || v === undefined) return null;\n  if (typeof v === 'boolean') return v;\n  if (typeof v === 'number') return v !== 0;\n  const s = String(v).trim().toLowerCase();\n  if (s === '') return null;\n  if (s === '1' || s === 'true' || s === 'yes' || s === 'y') return true;\n  if (s === '0' || s === 'false' || s === 'no' || s === 'n') return false;\n  return null;\n}\n\nfunction toNumOrNull(v) {\n  if (v === null || v === undefined || v === '') return null;\n  const n = Number(v);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction appendLog(existing, line) {\n  const base = (existing ?? '').toString().trim();\n  if (!base) return line;\n  return base + '\\n' + line;\n}\n\nfunction isTgCollectorItem(p) {\n  // TG collector outputs: _sent_ok/_sent_fail/_sent_total and _all_ok\n  return p && (p._sent_total !== undefined || p._sent_ok !== undefined || p._sent_fail !== undefined);\n}\n\nfunction isVkCollectorItem(p) {\n  // VK collector outputs: _vk_sent_total/_vk_sent_ok/_vk_sent_fail and _vk_all_ok\n  return p && (p._vk_sent_total !== undefined || p._vk_sent_ok !== undefined || p._vk_sent_fail !== undefined);\n}\n\nfunction isMaxCollectorItem(p) {\n  // MAX collector outputs: _max_sent_total/_max_sent_ok/_max_sent_fail and _max_all_ok\n  return p && (p._max_sent_total !== undefined || p._max_sent_ok !== undefined || p._max_sent_fail !== undefined);\n}\n\nfunction pickFirstNonEmpty(...vals) {\n  for (const v of vals) {\n    if (v === null || v === undefined) continue;\n    if (typeof v === 'string' && v.trim() === '') continue;\n    return v;\n  }\n  return null;\n}\n\n// Group per post_id\nconst byPost = new Map();\n\nfor (const item of items) {\n  const p = item.json || {};\n  const postId = p.post_id ?? p.id ?? null;\n  if (!postId) continue;\n\n  if (!byPost.has(postId)) {\n    byPost.set(postId, {\n      post_id: postId,\n\n      // common context\n      row_number: toNumOrNull(p.row_number),\n      now_utc: p.update_last_run_at_utc ?? p._now_utc ?? null,\n      now_local: p.update_last_run_at ?? p._now ?? null,\n      last_run_key: p.update_last_run_key ?? p._run_key ?? null,\n      plan_run_at: p.update_plan_run_at ?? p._plan_run_at ?? null,\n\n      // flags\n      send_tg: toBoolOrNull(p.send_tg),\n      send_vk: toBoolOrNull(p.send_vk),\n      send_max: toBoolOrNull(p.send_max),\n\n      // collector results\n      tg_seen: false,\n      tg_ok: null,\n      tg_ok_count: null,\n      tg_fail_count: null,\n      tg_total: null,\n\n      vk_seen: false,\n      vk_ok: null,\n      vk_ok_count: null,\n      vk_fail_count: null,\n      vk_total: null,\n\n      max_seen: false,\n      max_ok: null,\n      max_ok_count: null,\n      max_fail_count: null,\n      max_total: null,\n\n      // logs\n      prev_error: p.error_prev ?? null,\n      tg_update_error: null,\n      vk_update_error: null,\n      max_update_error: null,\n    });\n  }\n\n  const agg = byPost.get(postId);\n\n  // keep row_number if missing\n  if (agg.row_number === null || agg.row_number === undefined) {\n    agg.row_number = toNumOrNull(p.row_number);\n  }\n\n  // keep best timestamps/keys/plan\n  agg.now_utc = pickFirstNonEmpty(agg.now_utc, p.update_last_run_at_utc, p._now_utc);\n  agg.now_local = pickFirstNonEmpty(agg.now_local, p.update_last_run_at, p._now);\n  agg.last_run_key = pickFirstNonEmpty(agg.last_run_key, p.update_last_run_key, p._run_key);\n  agg.plan_run_at = pickFirstNonEmpty(agg.plan_run_at, p.update_plan_run_at, p._plan_run_at);\n\n  // capture send flags if present anywhere\n  const st = toBoolOrNull(p.send_tg);\n  const sv = toBoolOrNull(p.send_vk);\n  const sm = toBoolOrNull(p.send_max);\n  if (st !== null) agg.send_tg = st;\n  if (sv !== null) agg.send_vk = sv;\n  if (sm !== null) agg.send_max = sm;\n\n  // capture prev_error if present\n  if (p.error_prev !== undefined && p.error_prev !== null) agg.prev_error = p.error_prev;\n\n  // Determine if this is TG/VK/MAX collector item\n  if (isTgCollectorItem(p) || p._all_ok !== undefined) {\n    agg.tg_seen = true;\n    if (typeof p._all_ok === 'boolean') agg.tg_ok = p._all_ok;\n    agg.tg_ok_count = toNumOrNull(p._sent_ok);\n    agg.tg_fail_count = toNumOrNull(p._sent_fail);\n    agg.tg_total = toNumOrNull(p._sent_total);\n    if (p.update_error) agg.tg_update_error = safeStr(p.update_error);\n  }\n\n  if (isVkCollectorItem(p) || p._vk_all_ok !== undefined) {\n    agg.vk_seen = true;\n    if (typeof p._vk_all_ok === 'boolean') agg.vk_ok = p._vk_all_ok;\n    agg.vk_ok_count = toNumOrNull(p._vk_sent_ok);\n    agg.vk_fail_count = toNumOrNull(p._vk_sent_fail);\n    agg.vk_total = toNumOrNull(p._vk_sent_total);\n    if (p.update_error) agg.vk_update_error = safeStr(p.update_error);\n  }\n\n  if (isMaxCollectorItem(p) || p._max_all_ok !== undefined) {\n    agg.max_seen = true;\n    if (typeof p._max_all_ok === 'boolean') agg.max_ok = p._max_all_ok;\n    agg.max_ok_count = toNumOrNull(p._max_sent_ok);\n    agg.max_fail_count = toNumOrNull(p._max_sent_fail);\n    agg.max_total = toNumOrNull(p._max_sent_total);\n    if (p.update_error) agg.max_update_error = safeStr(p.update_error);\n  }\n\n  // If item isn't clearly a collector, but has update_error, keep as prev_error fallback\n  if (!agg.tg_update_error && !agg.vk_update_error && !agg.max_update_error && p.update_error) {\n    agg.prev_error = p.update_error;\n  }\n}\n\n// Helper: last line of a log string\nfunction lastLine(s) {\n  if (!s) return '';\n  const lines = String(s).split('\\n').map(x => x.trim()).filter(Boolean);\n  return lines.length ? lines[lines.length - 1] : '';\n}\n\nconst out = [];\n\nfor (const agg of byPost.values()) {\n  // Decide requirements:\n  // If send_* unknown, infer from presence of collector items.\n  const reqTg = (agg.send_tg === null || agg.send_tg === undefined) ? agg.tg_seen : agg.send_tg;\n  const reqVk = (agg.send_vk === null || agg.send_vk === undefined) ? agg.vk_seen : agg.send_vk;\n  const reqMax = (agg.send_max === null || agg.send_max === undefined) ? agg.max_seen : agg.send_max;\n\n  // Determine per-channel ok:\n  const tgOk = reqTg ? (agg.tg_ok === true) : true;\n  const vkOk = reqVk ? (agg.vk_ok === true) : true;\n  const maxOk = reqMax ? (agg.max_ok === true) : true;\n\n  const allOk = tgOk && vkOk && maxOk;\n\n  // Build final error:\n  let newError = null;\n\n  const tgLine = lastLine(agg.tg_update_error);\n  const vkLine = lastLine(agg.vk_update_error);\n  const maxLine = lastLine(agg.max_update_error);\n\n  if (tgLine) newError = appendLog(newError, tgLine);\n  if (vkLine) newError = appendLog(newError, vkLine);\n  if (maxLine) newError = appendLog(newError, maxLine);\n\n  if (!newError) {\n    newError = `[INFO] ${safeStr(agg.now_utc || new Date().toISOString())} no logs from collectors`;\n  }\n\n  out.push({\n    json: {\n      post_id: agg.post_id,\n      row_number: agg.row_number,\n\n      _all_ok: allOk,\n\n      // expose requirements/statuses\n      _req_tg: reqTg,\n      _req_vk: reqVk,\n      _req_max: reqMax,\n\n      _tg_ok: agg.tg_ok,\n      _vk_ok: agg.vk_ok,\n      _max_ok: agg.max_ok,\n\n      // counts\n      _tg_sent_ok: agg.tg_ok_count,\n      _tg_sent_fail: agg.tg_fail_count,\n      _tg_sent_total: agg.tg_total,\n\n      _vk_sent_ok: agg.vk_ok_count,\n      _vk_sent_fail: agg.vk_fail_count,\n      _vk_sent_total: agg.vk_total,\n\n      _max_sent_ok: agg.max_ok_count,\n      _max_sent_fail: agg.max_fail_count,\n      _max_sent_total: agg.max_total,\n\n      // Sheets update fields (write only on final success)\n      update_last_run_at_utc: allOk ? (agg.now_utc ?? null) : null,\n      update_last_run_at: allOk ? (agg.now_local ?? null) : null,\n      update_last_run_key: allOk ? (agg.last_run_key ?? null) : null,\n      update_plan_run_at: allOk ? (agg.plan_run_at ?? null) : null,\n\n      update_error: newError,\n    },\n  });\n}\n\nreturn out;"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[7968,1808],"id":"3d14c906-2bb3-474c-93e2-23f15bc666e1","name":"Final Collect"},{"parameters":{"rules":{"values":[{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"leftValue":"={{ $json.channel }}","rightValue":"tg","operator":{"type":"string","operation":"equals"},"id":"7889b351-d5e7-44c0-9dcb-c970ed0c1d06"}],"combinator":"and"}},{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"id":"da83e7f0-69cc-492d-95d8-59d2a3618398","leftValue":"={{ $json.channel }}","rightValue":"max","operator":{"type":"string","operation":"equals"}}],"combinator":"and"}}]},"options":{}},"type":"n8n-nodes-base.switch","typeVersion":3.4,"position":[4224,2192],"id":"e838a332-17c8-4aa9-a204-d82a800807ff","name":"Switch1"},{"parameters":{"method":"POST","url":"https://platform-api.max.ru/messages","authentication":"genericCredentialType","genericAuthType":"httpHeaderAuth","sendQuery":true,"queryParameters":{"parameters":[{"name":"chat_id","value":"={{ $json.chat_id }}"}]},"sendBody":true,"specifyBody":"json","jsonBody":"={{$json}}","options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[6864,3632],"id":"74c8e667-590b-4d10-b56d-9989bf2e409e","name":"Send Message1","credentials":{"httpHeaderAuth":{"id":"EWKLZldey391MbFm","name":"MAX autopost"}},"onError":"continueRegularOutput"},{"parameters":{"method":"POST","url":"https://platform-api.max.ru/uploads1","authentication":"genericCredentialType","genericAuthType":"httpHeaderAuth","sendQuery":true,"queryParameters":{"parameters":[{"name":"type","value":"={{ $json.mediaType}}"}]},"options":{"response":{"response":{"responseFormat":"json"}}}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[4736,3040],"id":"92325066-dea0-422e-95bf-d73d5e38b8ff","name":"–£–∑–µ–ª A1","retryOnFail":true,"maxTries":5,"waitBetweenTries":2000,"credentials":{"httpHeaderAuth":{"id":"EWKLZldey391MbFm","name":"MAX autopost"}},"onError":"continueRegularOutput"},{"parameters":{"method":"POST","url":"={{$json.uploadUrl}}","sendBody":true,"contentType":"multipart-form-data","bodyParameters":{"parameters":[{"parameterType":"formBinaryData","name":"data","inputDataFieldName":"data"}]},"options":{"response":{"response":{"responseFormat":"text"}}}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[6080,3344],"id":"8debe5a3-5c9a-4bde-9cb9-86d7c1d40b9c","name":"–£–∑–µ–ª C1","onError":"continueRegularOutput"},{"parameters":{"url":"={{ $json.url }}","options":{"redirect":{"redirect":{}},"response":{"response":{"responseFormat":"file"}}}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[4864,3520],"id":"1ed07e63-b0b0-44fb-bdfe-06daf87db8f7","name":"–£–∑–µ–ª B1","onError":"continueRegularOutput"},{"parameters":{"mode":"combine","combineBy":"combineByPosition","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5776,3168],"id":"f4c6636b-fd9c-44f0-b193-74a1a6b945af","name":"Merge7","onError":"continueRegularOutput"},{"parameters":{"jsCode":"// –æ—Ç–≤–µ—Ç—ã –∏–∑ C1 (c1[i].json.data = —Å—Ç—Ä–æ–∫–∞)\nconst c1 = $items('–£–∑–µ–ª C1');\n\n// —Å—Ç—Ä–æ–∫–∏ –∏–∑ Merge7 (idx, mediaType, url, + –∫–æ–Ω—Ç–µ–∫—Å—Ç: chat_id/text/max/_run_key_channel/...)\nconst m1 = $items('Merge7');\n\n// –æ—Ç–≤–µ—Ç—ã –∏–∑ A1 (—Ç–∞–º token –¥–ª—è video)\nconst a1 = $items('–£–∑–µ–ª A1');\n\nreturn c1.map((c, i) => {\n  const resp = String(c.json?.data ?? '');\n  const base = m1[i]?.json ?? {};\n  const a1token = a1[i]?.json?.token ?? null;\n\n  // VIDEO: —Ç–æ–∫–µ–Ω –±–µ—Ä—ë–º –∏–∑ A1\n  if (base.mediaType === 'video') {\n    return {\n      json: {\n        // –í–ê–ñ–ù–û: —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç\n        ...base,\n\n        // –∏ –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–µ–º token –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º\n        token: a1token,\n      }\n    };\n  }\n\n  // IMAGE: —Ç–æ–∫–µ–Ω –≤—ã—Ç–∞—Å–∫–∏–≤–∞–µ–º –∏–∑ —Å—Ç—Ä–æ–∫–∏ –æ—Ç–≤–µ—Ç–∞ C1\n  let token = null;\n  const m = resp.match(/\"token\"\\s*:\\s*\"([^\"]+)\"/);\n  if (m) token = m[1];\n\n  return {\n    json: {\n      // –í–ê–ñ–ù–û: —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç\n      ...base,\n\n      // –∏ –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–µ–º token\n      token,\n    }\n  };\n});"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[6400,3360],"id":"36411ebd-f0d2-43ce-9510-c658ce97bddf","name":"Code in JavaScript4","onError":"continueRegularOutput"},{"parameters":{"assignments":{"assignments":[{"id":"ba4a2eab-fa7e-4cee-864a-25eddcb9b65f","name":"uploadUrl","value":"={{$json.url}}","type":"string"}]},"includeOtherFields":true,"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[5440,3072],"id":"78a3f35c-d865-46f4-9082-bf6e8bf92825","name":"Edit Fields1","onError":"continueRegularOutput"},{"parameters":{"jsCode":"/**\n * Build MAX /messages payload PER STORE (PER chat_id)\n *\n * Input: items after Code in JavaScript4\n *   (—Ç–∞–º —É–∂–µ –µ—Å—Ç—å token –¥–ª—è –∫–∞–∂–¥–æ–≥–æ media, –∏ –ø—Ä–æ–±—Ä–æ—à–µ–Ω –∫–æ–Ω—Ç–µ–∫—Å—Ç store_id/chat_id/text/order_links/...)\n *\n * Output: MANY items ‚Äî –ø–æ –æ–¥–Ω–æ–º—É –Ω–∞ —Ç–æ—á–∫—É/—á–∞—Ç.\n */\n\nconst rows = $input.all().map(x => x.json ?? {});\n\n// --- helpers ---\nfunction normButtons(orderLinks) {\n  const arr = Array.isArray(orderLinks) ? orderLinks : [];\n  const clean = arr\n    .map(b => ({\n      text: (b?.text ?? '').toString().trim(),\n      url: (b?.url ?? '').toString().trim(),\n    }))\n    .filter(b => b.text && b.url && /^https?:\\/\\//i.test(b.url));\n\n  if (!clean.length) return null;\n\n  // MAX: –±–µ–∑–æ–ø–∞—Å–Ω–æ –ø–æ 1 –∫–Ω–æ–ø–∫–µ –≤ —Ä—è–¥\n  return {\n    type: \"inline_keyboard\",\n    payload: {\n      buttons: clean.map(b => ([{ type: \"link\", text: b.text, url: b.url }]))\n    }\n  };\n}\n\nfunction groupKey(p) {\n  const postId = p.post_id ?? p.id ?? '';\n  const storeId = p.store_id ?? '';\n  const chatId = p.chat_id ?? p.max?.channel_id ?? p.max_channel_id ?? '';\n  return `${postId}::${storeId}::${chatId}`;\n}\n\n// --- group by store/chat ---\nconst groups = new Map();\nfor (const p of rows) {\n  const k = groupKey(p);\n  if (!groups.has(k)) groups.set(k, []);\n  groups.get(k).push(p);\n}\n\n// --- build one message per group ---\nconst out = [];\n\nfor (const [k, items] of groups.entries()) {\n  // —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ idx —á—Ç–æ–±—ã –º–µ–¥–∏–∞ –±—ã–ª–∏ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ\n  items.sort((a, b) => (a.idx ?? 0) - (b.idx ?? 0));\n\n  const first = items[0] || {};\n  const chatId =\n    first.chat_id ??\n    first.max?.channel_id ??\n    first.max_channel_id ??\n    null;\n\n  if (!chatId) {\n    // –µ—Å–ª–∏ –≤–¥—Ä—É–≥ –Ω–µ—Ç chat_id ‚Äî –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º, —á—Ç–æ–±—ã –Ω–µ –ø–∞–¥–∞—Ç—å\n    continue;\n  }\n\n  const text = (first.max?.text ?? first.text ?? '').toString();\n\n  // –º–µ–¥–∏–∞-–≤–ª–æ–∂–µ–Ω–∏—è (—Ç–æ–ª—å–∫–æ —Ç–∞–º –≥–¥–µ –µ—Å—Ç—å token+mediaType)\n  const mediaAttachments = items\n    .filter(x => x.token && x.mediaType)\n    .map(x => ({\n      type: x.mediaType, // \"image\" | \"video\"\n      payload: { token: x.token }\n    }));\n\n  // –∫–Ω–æ–ø–∫–∏ –∏–∑ order_links\n  const keyboardAttachment = normButtons(first.order_links);\n\n  const attachments = [...mediaAttachments];\n  if (keyboardAttachment) attachments.push(keyboardAttachment);\n\n  out.push({\n    json: {\n      // ‚úÖ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –í–ï–°–¨ –∫–æ–Ω—Ç–µ–∫—Å—Ç (–≤–∞–∂–Ω–æ –¥–ª—è Collect MAX results / —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ –º–µ—Ä–¥–∂–∞)\n      ...first,\n\n      // ‚úÖ –ø–æ–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏\n      chat_id: chatId,\n      text,\n      format: \"markdown\",\n      notify: true,\n      attachments,\n    }\n  });\n}\n\nreturn out;"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[6608,3568],"id":"f2a06c31-50e8-4ca9-9dce-26f09b08dcb4","name":"Code in JavaScript5","onError":"continueRegularOutput"},{"parameters":{"jsCode":"// MAX code after switch (UPDATED)\n// –í—Ö–æ–¥: items –∏–∑ –≤–µ—Ç–∫–∏ channel=max –ø–æ—Å–ª–µ Expand per store (—Ç.–µ. –ø–æ –æ–¥–Ω–æ–º—É item –Ω–∞ –º–∞–≥–∞–∑–∏–Ω)\n// –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ –º–µ–¥–∏–∞:\n// 1) max_media_group / max_media + max_op (–∏–∑ Expand per store) ‚úÖ\n// 2) fallback: media_raw —Å—Ç—Ä–æ–∫–∞ \"—Ñ|url ... –≤|url ...\"          (–µ—Å–ª–∏ –≤–¥—Ä—É–≥ –ø—Ä–∏–ª–µ—Ç–∞–µ—Ç)\n//\n// –í—ã—Ö–æ–¥: items –¥–ª—è A1/B1/C1 (idx, mediaType, url) + –ø—Ä–æ–±—Ä–æ—Å chat_id/text\n//\n// FIX: —Ä–∞–Ω—å—à–µ –±—ã–ª–æ $input.first() ‚Üí —Ç–µ—Ä—è–ª–∏—Å—å –æ—Å—Ç–∞–ª—å–Ω—ã–µ –º–∞–≥–∞–∑–∏–Ω—ã.\n// –¢–µ–ø–µ—Ä—å –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –í–°–ï –≤—Ö–æ–¥–Ω—ã–µ items.\n\nconst inputs = $input.all().map(i => i.json ?? {});\n\n// –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –º–µ–¥–∏–∞ –∏–∑ ‚Äú–Ω–æ–≤–æ–≥–æ‚Äù —Ñ–æ—Ä–º–∞—Ç–∞\nconst normMediaObj = (m) => {\n  if (!m) return null;\n\n  // –¥–æ–ø—É—Å–∫–∞–µ–º —Ñ–æ—Ä–º–∞—Ç—ã:\n  // { type:'image'|'video', media:'url' }\n  // { type:'image'|'video', url:'url' }\n  // { mediaType:'image'|'video', url:'url' }\n  const type = (m.type ?? m.mediaType ?? '').toString().trim().toLowerCase();\n  const url  = (m.media ?? m.url ?? '').toString().trim();\n\n  if (!url) return null;\n\n  const mediaType = (type === 'video') ? 'video' : 'image'; // default to image\n  return { mediaType, url };\n};\n\nfunction buildForOne(src) {\n  const chatId =\n    src.chat_id ??\n    src.max?.channel_id ??\n    src.max_channel_id ??\n    null;\n\n  const text = (src.max?.text ?? src.text ?? '').toString();\n\n  // max_op: message | image | video | media_group\n  const maxOp = (src.max_op ?? '').toString().trim().toLowerCase();\n\n  // 1) –ù–æ–≤—ã–π –ø—É—Ç—å: max_media_group\n  let mediaList = [];\n  if (Array.isArray(src.max_media_group) && src.max_media_group.length > 0) {\n    for (const m of src.max_media_group) {\n      const nm = normMediaObj(m);\n      if (nm) mediaList.push(nm);\n    }\n  }\n\n  // 2) –ù–æ–≤—ã–π –ø—É—Ç—å: –æ–¥–∏–Ω–æ—á–Ω–æ–µ –º–µ–¥–∏–∞\n  if (mediaList.length === 0 && src.max_media) {\n    const singleType = (maxOp === 'video') ? 'video' : 'image';\n    const url = (src.max_media ?? '').toString().trim();\n    if (url) mediaList.push({ mediaType: singleType, url });\n  }\n\n  // 3) Fallback: –ø–∞—Ä—Å–∏–Ω–≥ media_raw \"–≤|url / —Ñ|url\"\n  if (mediaList.length === 0) {\n    const mediaRaw =\n      (src.media_raw ?? src.max_media_raw ?? src._raw?.media_url ?? src._raw?.media_raw ?? '').toString();\n\n    const re = /(^|[\\s\\r\\n]+)\\+?\\s*([–≤—Ñvf])\\|(\\S+)/gi;\n    let m;\n    while ((m = re.exec(mediaRaw)) !== null) {\n      const prefix = (m[2] || '').toLowerCase();\n      const url = (m[3] || '').toString().trim();\n      if (!url) continue;\n\n      const mediaType = (prefix === '–≤' || prefix === 'v') ? 'video' : 'image';\n      mediaList.push({ mediaType, url });\n    }\n  }\n\n  // –ï—Å–ª–∏ –º–µ–¥–∏–∞ –ø–æ —Å–º—ã—Å–ª—É –Ω–µ –Ω—É–∂–Ω–æ (message) –∏–ª–∏ —Ä–µ–∞–ª—å–Ω–æ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç ‚Äî –æ—Ç–¥–∞—ë–º 1 item\n  if (maxOp === 'message' || mediaList.length === 0) {\n    return [{\n      json: {\n        ...src,\n        chat_id: chatId,\n        text,\n        idx: 0,\n        mediaType: null,\n        url: null,\n        _max_no_media: true,\n        _max_media_count: 0,\n        _max_media_source:\n          (Array.isArray(src.max_media_group) && src.max_media_group.length > 0) ? 'max_media_group' :\n          (src.max_media ? 'max_media' :\n          ((src.media_raw || src._raw?.media_url || src._raw?.media_raw) ? 'media_raw_fallback' : 'none')),\n      },\n    }];\n  }\n\n  // –î–µ–¥—É–ø URL + —Å–±–æ—Ä–∫–∞ items\n  const seen = new Set();\n  const out = [];\n  let idx = 0;\n\n  for (const it of mediaList) {\n    const key = `${it.mediaType}|${it.url}`;\n    if (seen.has(key)) continue;\n    seen.add(key);\n\n    out.push({\n      json: {\n        ...src,\n\n        // –ø—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º –Ω—É–∂–Ω–æ–µ –¥–ª—è Send Message\n        chat_id: chatId,\n        text,\n\n        // —Ç–æ, —á—Ç–æ –Ω—É–∂–Ω–æ —Ç–≤–æ–∏–º –£–∑–ª–∞–º A1/B1/C1\n        idx,\n        mediaType: it.mediaType,\n        url: it.url,\n\n        _max_no_media: false,\n      },\n    });\n\n    idx++;\n  }\n\n  if (out.length === 0) {\n    return [{\n      json: {\n        ...src,\n        chat_id: chatId,\n        text,\n        idx: 0,\n        mediaType: null,\n        url: null,\n        _max_no_media: true,\n        _max_media_count: 0,\n        _max_media_source:\n          (Array.isArray(src.max_media_group) && src.max_media_group.length > 0) ? 'max_media_group' :\n          (src.max_media ? 'max_media' :\n          ((src.media_raw || src._raw?.media_url || src._raw?.media_raw) ? 'media_raw_fallback' : 'none')),\n      },\n    }];\n  }\n\n  // –ü–æ–ª–µ–∑–Ω—ã–π –¥–µ–±–∞–≥\n  const source =\n    (Array.isArray(src.max_media_group) && src.max_media_group.length > 0) ? 'max_media_group' :\n    (src.max_media ? 'max_media' :\n    ((src.media_raw || src._raw?.media_url || src._raw?.media_raw) ? 'media_raw_fallback' : 'none'));\n\n  for (const o of out) {\n    o.json._max_media_count = out.length;\n    o.json._max_media_source = source;\n  }\n\n  return out;\n}\n\n// flatten results for all stores\nreturn inputs.flatMap(buildForOne);"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[4448,3264],"id":"f9b040c4-6c32-4b75-9b90-1ce0fdf8a494","name":"MAX code after switch"},{"parameters":{"jsCode":"/**\n * Collect MAX results per post_id (Function node version) ‚Äî FIXED\n *\n * Fixes:\n *  1) reason no longer shows \"[object Object]\" (safeJson)\n *  2) success detector recognizes MAX success by presence of message.body.mid (or body.mid)\n */\n\nconst inItems = items;\n\nfunction safeStr(v) {\n  if (v === null || v === undefined) return '';\n  return String(v);\n}\n\nfunction safeJson(v) {\n  if (v === null || v === undefined) return '';\n  if (typeof v === 'string') return v;\n  try {\n    const s = JSON.stringify(v);\n    return s.length > 500 ? s.slice(0, 500) + '‚Ä¶' : s;\n  } catch {\n    return String(v);\n  }\n}\n\nfunction toNumOrNull(v) {\n  if (v === null || v === undefined || v === '') return null;\n  const n = Number(v);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction toBoolOrNull(v) {\n  if (v === null || v === undefined) return null;\n  if (typeof v === 'boolean') return v;\n  if (typeof v === 'number') return v !== 0;\n  const s = String(v).trim().toLowerCase();\n  if (s === '') return null;\n  if (s === '1' || s === 'true' || s === 'yes' || s === 'y') return true;\n  if (s === '0' || s === 'false' || s === 'no' || s === 'n') return false;\n  return null;\n}\n\nfunction appendLog(existing, line) {\n  const base = (existing ?? '').toString().trim();\n  if (!base) return line;\n  return base + '\\n' + line;\n}\n\nfunction pickFirstNonEmpty(...vals) {\n  for (const v of vals) {\n    if (v === null || v === undefined) continue;\n    if (typeof v === 'string' && v.trim() === '') continue;\n    return v;\n  }\n  return null;\n}\n\nfunction nowIso() {\n  return new Date().toISOString();\n}\n\n// Heuristic success detector (MAX-aware)\nfunction isOk(p) {\n  // MAX success usually includes message.body.mid (or body.mid)\n  const mid = p?.message?.body?.mid ?? p?.body?.mid ?? null;\n  if (mid) return true;\n\n  const sc =\n    p.statusCode ??\n    p.status_code ??\n    p.httpStatus ??\n    p.http_status ??\n    null;\n\n  if (typeof sc === 'number') return sc >= 200 && sc < 300;\n\n  if (p.ok === true || p.success === true) return true;\n\n  if (p.error || p.err) return false;\n\n  const data = p.data ?? p.body ?? p.response ?? null;\n  if (data && typeof data === 'object') {\n    if (data.error || data.errors) return false;\n    if (data.ok === true || data.success === true) return true;\n  }\n\n  return false;\n}\n\nfunction extractErr(p) {\n  const candidates = [\n    p.error?.message,\n    p.error?.description,\n    p.err?.message,\n    p.message,\n    p.data?.error?.message,\n    p.data?.error_description,\n    p.body?.error?.message,\n    p.statusMessage,\n  ].filter(Boolean);\n\n  if (candidates.length) return candidates[0]; // may be string/object\n\n  // If MAX returned error-ish structure in message/body, keep it\n  if (p?.message) return p.message;\n  if (p?.body) return p.body;\n\n  return p; // last-resort, will be stringified by safeJson\n}\n\n// Group per post_id\nconst byPost = new Map();\n\nfor (const item of inItems) {\n  const p = item.json || {};\n  const postId = p.post_id ?? p.id ?? null;\n  if (!postId) continue;\n\n  if (!byPost.has(postId)) {\n    byPost.set(postId, {\n      post_id: postId,\n\n      row_number: toNumOrNull(p.row_number),\n      now_utc: p.update_last_run_at_utc ?? p._now_utc ?? null,\n      now_local: p.update_last_run_at ?? p._now ?? null,\n      last_run_key: p.update_last_run_key ?? p._run_key ?? null,\n      plan_run_at: p.update_plan_run_at ?? p._plan_run_at ?? null,\n\n      send_max: toBoolOrNull(p.send_max),\n\n      prev_error: p.error_prev ?? p.update_error ?? null,\n\n      total: 0,\n      ok: 0,\n      fail: 0,\n      first_fail_reason: null,\n    });\n  }\n\n  const agg = byPost.get(postId);\n\n  if (agg.row_number === null || agg.row_number === undefined) {\n    agg.row_number = toNumOrNull(p.row_number);\n  }\n\n  agg.now_utc = pickFirstNonEmpty(agg.now_utc, p.update_last_run_at_utc, p._now_utc);\n  agg.now_local = pickFirstNonEmpty(agg.now_local, p.update_last_run_at, p._now);\n  agg.last_run_key = pickFirstNonEmpty(agg.last_run_key, p.update_last_run_key, p._run_key);\n  agg.plan_run_at = pickFirstNonEmpty(agg.plan_run_at, p.update_plan_run_at, p._plan_run_at);\n\n  const sm = toBoolOrNull(p.send_max);\n  if (sm !== null) agg.send_max = sm;\n\n  agg.total += 1;\n\n  const ok = isOk(p);\n  if (ok) agg.ok += 1;\n  else {\n    agg.fail += 1;\n    if (!agg.first_fail_reason) agg.first_fail_reason = extractErr(p);\n  }\n}\n\nconst out = [];\n\nfor (const agg of byPost.values()) {\n  const reqMax = (agg.send_max === null || agg.send_max === undefined) ? true : agg.send_max;\n  const allOk = reqMax ? (agg.fail === 0) : true;\n\n  const ts = safeStr(agg.now_utc || nowIso());\n  const line = allOk\n    ? `[MAX] ${ts} ok ${agg.ok}/${agg.total}`\n    : `[MAX] ${ts} FAIL ok ${agg.ok}/${agg.total} reason: ${safeJson(agg.first_fail_reason || 'unknown')}`;\n\n  const newError = appendLog(agg.prev_error, line);\n\n  out.push({\n    json: {\n      post_id: agg.post_id,\n      row_number: agg.row_number,\n\n      send_max: reqMax,\n\n      _max_sent_total: agg.total,\n      _max_sent_ok: agg.ok,\n      _max_sent_fail: agg.fail,\n      _max_all_ok: allOk,\n\n      update_last_run_at_utc: agg.now_utc ?? null,\n      update_last_run_at: agg.now_local ?? null,\n      update_last_run_key: agg.last_run_key ?? null,\n      update_plan_run_at: agg.plan_run_at ?? null,\n\n      update_error: newError,\n    }\n  });\n}\n\nreturn out;"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[7408,2624],"id":"3d966aa4-75db-4a22-bc38-d85f89b8812c","name":"Collect MAX results","onError":"continueRegularOutput"},{"parameters":{"mode":"combine","combineBy":"combineByPosition","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[7216,3312],"id":"3e34d21a-d620-4d4d-a5e2-8b94a4ab2430","name":"Merge8","onError":"continueRegularOutput"},{"parameters":{"jsCode":"// Restore context after A1\n\nconst prev = $items('MAX code after switch'); // –∏–º—è –Ω–æ–¥—ã –î–û A1\nconst current = $input.all();\n\nreturn current.map((item, i) => {\n  const ctx = prev[i]?.json ?? {};\n\n  return {\n    json: {\n      ...ctx,        // –º–∞–≥–∞–∑–∏–Ω, chat_id, idx, text\n      ...item.json   // url/token –æ—Ç A1\n    }\n  };\n});"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[4944,3040],"id":"98d0811c-4812-4041-914d-fa0301aed50f","name":"Code in JavaScript3","onError":"continueRegularOutput"},{"parameters":{"url":"https://sheets.googleapis.com/v4/spreadsheets/1FyEGxa6JYTJxDrowfgzAzroTM8L3CWCSY1rgI2DK9KQ/values/POST!1:1","authentication":"predefinedCredentialType","nodeCredentialType":"googleSheetsOAuth2Api","options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[1488,2512],"id":"f7e77e5e-4928-4e0d-a6b3-ed2a2eecbe96","name":"HTTP Request1","credentials":{"googleSheetsOAuth2Api":{"id":"b5DluHDjTyDAsQWd","name":"Google Sheets account"}}},{"parameters":{"jsCode":"const header = $json.values?.[0] ?? [];\nconst idx = header.findIndex(x => String(x).trim().toLowerCase() === 'text');\nif (idx < 0) {\n  throw new Error(`Column 'text' not found in header: ${header.join(', ')}`);\n}\n\nfunction colToA1(n) {\n  // 0 -> A, 1 -> B ...\n  let s = '';\n  let x = n + 1;\n  while (x > 0) {\n    const m = (x - 1) % 26;\n    s = String.fromCharCode(65 + m) + s;\n    x = Math.floor((x - 1) / 26);\n  }\n  return s;\n}\n\nreturn [{ json: { text_col_letter: colToA1(idx) } }];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[1712,2448],"id":"3db0c427-27cc-45ef-82e0-0b567d0c233d","name":"Find text column lette"},{"parameters":{"url":"https://sheets.googleapis.com/v4/spreadsheets/1FyEGxa6JYTJxDrowfgzAzroTM8L3CWCSY1rgI2DK9KQ","authentication":"predefinedCredentialType","nodeCredentialType":"googleSheetsOAuth2Api","sendQuery":true,"queryParameters":{"parameters":[{"name":"includeGridData","value":"true"},{"name":"ranges","value":"={{ \"POST!\" + $json.text_col_letter + \"2:\" + $json.text_col_letter + \"5000\" }}"},{"name":"fields","value":"sheets(data(rowData(values(formattedValue,textFormatRuns,hyperlink))))"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[2080,2240],"id":"46be412f-7a47-4e8e-b4a1-46269cd18ba4","name":"HTTP Request2","executeOnce":true,"credentials":{"googleSheetsOAuth2Api":{"id":"b5DluHDjTyDAsQWd","name":"Google Sheets account"}}},{"parameters":{"jsCode":"// –í—Ö–æ–¥: –æ–¥–∏–Ω item (Execute Once), –≤ –∫–æ—Ç–æ—Ä–æ–º –µ—Å—Ç—å sheets[0].data[0].rowData[]\n// –ù–∞–¥–æ: –≤–µ—Ä–Ω—É—Ç—å –º–Ω–æ–≥–æ items –≤–∏–¥–∞ { row_number, text_html }\n\nfunction esc(s) {\n  return String(s ?? '')\n    .replaceAll('&', '&amp;')\n    .replaceAll('<', '&lt;')\n    .replaceAll('>', '&gt;')\n    .replaceAll('\"', '&quot;');\n}\n\nfunction wrap(segHtml, fmt) {\n  let t = segHtml;\n\n  const link = fmt?.link?.uri || null;\n  const bold = !!fmt?.bold;\n  const italic = !!fmt?.italic;\n  const underline = !!fmt?.underline;\n  const strike = !!fmt?.strikethrough;\n\n  if (bold) t = `<b>${t}</b>`;\n  if (italic) t = `<i>${t}</i>`;\n  if (underline) t = `<u>${t}</u>`;\n  if (strike) t = `<s>${t}</s>`;\n  if (link) t = `<a href=\"${esc(link)}\">${t}</a>`;\n\n  return t;\n}\n\nfunction buildHtml(formattedValue, runs) {\n  const raw = String(formattedValue ?? '');\n  if (!raw) return '';\n\n  // –ï—Å–ª–∏ runs –Ω–µ—Ç ‚Äî –ø—Ä–æ—Å—Ç–æ escape + –ø–µ—Ä–µ–Ω–æ—Å—ã —Å—Ç—Ä–æ–∫\n  if (!Array.isArray(runs) || runs.length === 0) {\n    return esc(raw).replace(/\\n/g, '<br>');\n  }\n\n  const rs = runs\n    .map(r => ({\n      start: Number(r.startIndex ?? 0),\n      format: r.format ?? null,\n    }))\n    .filter(r => Number.isFinite(r.start))\n    .sort((a, b) => a.start - b.start);\n\n  if (!rs.length || rs[0].start !== 0) rs.unshift({ start: 0, format: null });\n\n  let out = '';\n  for (let i = 0; i < rs.length; i++) {\n    const from = rs[i].start;\n    const to = (i + 1 < rs.length) ? rs[i + 1].start : raw.length;\n    const segRaw = raw.slice(from, to);\n\n    const segHtml = esc(segRaw).replace(/\\n/g, '<br>');\n    out += wrap(segHtml, rs[i].format);\n  }\n  return out;\n}\n\n// --- –¥–æ—Å—Ç–∞—ë–º rowData ---\nconst sheet = $json.sheets?.[0];\nconst rowData = sheet?.data?.[0]?.rowData ?? [];\n\n// –ú—ã –∑–∞–ø—Ä–∞—à–∏–≤–∞–ª–∏ –¥–∏–∞–ø–∞–∑–æ–Ω –Ω–∞—á–∏–Ω–∞—è —Å Q2 => –ø–µ—Ä–≤–∞—è rowData —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç row_number=2\nconst startRow = 2;\n\nconst out = [];\nfor (let i = 0; i < rowData.length; i++) {\n  const cell = rowData[i]?.values?.[0] ?? null;\n  const formattedValue = cell?.formattedValue ?? '';\n  const runs = cell?.textFormatRuns ?? null;\n\n  const text_html = buildHtml(formattedValue, runs);\n\n  out.push({\n    json: {\n      row_number: startRow + i,\n      text_html,\n    }\n  });\n}\n\nreturn out;"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[2288,2096],"id":"c9370b7d-66ad-439d-b35f-28cfe5129348","name":"Build text_html map"},{"parameters":{"mode":"combine","fieldsToMatchString":"row_number","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[2512,1984],"id":"8951b59c-7a8c-4fe1-8dbb-94b6b4946e3b","name":"Merge text_html into rows"}],"connections":{"When clicking ‚ÄòExecute workflow‚Äô":{"main":[[{"node":"Get row(s) in sheet","type":"main","index":0},{"node":"HTTP Request1","type":"main","index":0}]]},"Get row(s) in sheet":{"main":[[{"node":"Merge text_html into rows","type":"main","index":0}]]},"Filter":{"main":[[{"node":"Code in JavaScript","type":"main","index":0}]]},"Code in JavaScript":{"main":[[{"node":"Determine due","type":"main","index":0}]]},"Filter1":{"main":[[{"node":"Postgre_store_extract","type":"main","index":0},{"node":"Merge1","type":"main","index":0},{"node":"GS_CoopFact_GetRows","type":"main","index":0}]]},"Code in JavaScript2":{"main":[[{"node":"Filter VK","type":"main","index":0},{"node":"Switch1","type":"main","index":0}]]},"Postgre_store_extract":{"main":[[{"node":"Merge1","type":"main","index":1}]]},"Send a text message":{"main":[[{"node":"Merge","type":"main","index":1}]]},"Edit Fields":{"main":[[{"node":"Switch","type":"main","index":0}]]},"Collect TG results":{"main":[[{"node":"Merge6","type":"main","index":1}]]},"Merge":{"main":[[{"node":"Merge5","type":"main","index":0}]]},"If":{"main":[[{"node":"Update row in sheet","type":"main","index":0}],[{"node":"Update row in sheet1","type":"main","index":0}]]},"Merge1":{"main":[[{"node":"Merge_Facts_Barrier","type":"main","index":1}]]},"Switch":{"main":[[{"node":"Send a text message","type":"main","index":0},{"node":"Merge","type":"main","index":0}],[{"node":"Send a photo message","type":"main","index":0},{"node":"Merge2","type":"main","index":0}],[{"node":"Send a video","type":"main","index":0},{"node":"Merge3","type":"main","index":0}],[{"node":"HTTP Request","type":"main","index":0},{"node":"Merge4","type":"main","index":0}]]},"Send a photo message":{"main":[[{"node":"Merge2","type":"main","index":1}]]},"Merge2":{"main":[[{"node":"Merge5","type":"main","index":1}]]},"Send a video":{"main":[[{"node":"Merge3","type":"main","index":1}]]},"Merge3":{"main":[[{"node":"Merge5","type":"main","index":2}]]},"HTTP Request":{"main":[[{"node":"Merge4","type":"main","index":1}]]},"Merge4":{"main":[[{"node":"Merge5","type":"main","index":3}]]},"Merge5":{"main":[[{"node":"Collect TG results","type":"main","index":0}]]},"GS_CoopFact_GetRows":{"main":[[{"node":"Merge_Facts_Barrier","type":"main","index":0}]]},"Merge_Facts_Barrier":{"main":[[{"node":"Code in JavaScript2","type":"main","index":0}]]},"Determine due":{"main":[[{"node":"Filter1","type":"main","index":0}]]},"Schedule Trigger":{"main":[[{"node":"Get row(s) in sheet","type":"main","index":0},{"node":"HTTP Request1","type":"main","index":0}]]},"Filter VK":{"main":[[{"node":"VK Edit Fields","type":"main","index":0}]]},"VK wall.post":{"main":[[{"node":"Merge VK","type":"main","index":0}]]},"VK Edit Fields":{"main":[[{"node":"VK wall.post","type":"main","index":0},{"node":"Merge VK","type":"main","index":1}]]},"Merge VK":{"main":[[{"node":"Collect VK results","type":"main","index":0}]]},"Collect VK results":{"main":[[{"node":"Code in JavaScript1","type":"main","index":0}]]},"Code in JavaScript1":{"main":[[{"node":"Merge6","type":"main","index":0}]]},"Merge6":{"main":[[{"node":"Final Collect","type":"main","index":0}]]},"Final Collect":{"main":[[{"node":"If","type":"main","index":0}]]},"Switch1":{"main":[[{"node":"Edit Fields","type":"main","index":0}],[{"node":"MAX code after switch","type":"main","index":0}]]},"–£–∑–µ–ª A1":{"main":[[{"node":"Code in JavaScript3","type":"main","index":0}]]},"–£–∑–µ–ª C1":{"main":[[{"node":"Code in JavaScript4","type":"main","index":0}]]},"–£–∑–µ–ª B1":{"main":[[{"node":"Merge7","type":"main","index":1}]]},"Merge7":{"main":[[{"node":"–£–∑–µ–ª C1","type":"main","index":0}]]},"Code in JavaScript4":{"main":[[{"node":"Code in JavaScript5","type":"main","index":0}]]},"Edit Fields1":{"main":[[{"node":"Merge7","type":"main","index":0}]]},"Code in JavaScript5":{"main":[[{"node":"Send Message1","type":"main","index":0},{"node":"Merge8","type":"main","index":0}]]},"MAX code after switch":{"main":[[{"node":"–£–∑–µ–ª B1","type":"main","index":0},{"node":"–£–∑–µ–ª A1","type":"main","index":0}]]},"Send Message1":{"main":[[{"node":"Merge8","type":"main","index":1}]]},"Collect MAX results":{"main":[[{"node":"Merge6","type":"main","index":2}]]},"Merge8":{"main":[[{"node":"Collect MAX results","type":"main","index":0}]]},"Code in JavaScript3":{"main":[[{"node":"Edit Fields1","type":"main","index":0}]]},"HTTP Request1":{"main":[[{"node":"Find text column lette","type":"main","index":0}]]},"Find text column lette":{"main":[[{"node":"HTTP Request2","type":"main","index":0}]]},"HTTP Request2":{"main":[[{"node":"Build text_html map","type":"main","index":0}]]},"Build text_html map":{"main":[[{"node":"Merge text_html into rows","type":"main","index":1}]]},"Merge text_html into rows":{"main":[[{"node":"Filter","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","availableInMCP":false,"timeSavedMode":"fixed","callerPolicy":"workflowsFromSameOwner"},"staticData":{"node:Schedule Trigger":{"recurrenceRules":[]}},"meta":{"templateCredsSetupCompleted":true},"pinData":{},"versionId":"9283875a-12b3-4f62-817a-851d0d5ce098","activeVersionId":null,"versionCounter":130,"triggerCount":1,"tags":[],"shared":[{"updatedAt":"2026-02-15T06:39:42.564Z","createdAt":"2026-02-15T06:39:42.564Z","role":"workflow:owner","workflowId":"uIvq2iDo93iByPmt","projectId":"pN1dQC2QTiUB8OxN","project":{"updatedAt":"2026-01-03T09:50:23.589Z","createdAt":"2026-01-02T11:57:57.457Z","id":"pN1dQC2QTiUB8OxN","name":"Ilya Sukharev <retail.sukharev@yandex.ru>","type":"personal","icon":null,"description":null,"creatorId":"a8327288-747a-47c3-9f5f-b2070eff6d8c"}}]}