[{"updatedAt":"2026-02-09T13:56:37.094Z","createdAt":"2026-01-03T11:38:42.863Z","id":"poTupu2jfIU7WPUA","name":"My workflow","description":null,"active":true,"isArchived":false,"nodes":[{"parameters":{},"type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[2496,1936],"id":"f10f9c59-ed30-4501-a101-8643792bf745","name":"When clicking ‘Execute workflow’"},{"parameters":{"documentId":{"__rl":true,"mode":"id","value":"1FyEGxa6JYTJxDrowfgzAzroTM8L3CWCSY1rgI2DK9KQ"},"sheetName":{"__rl":true,"value":"POST","mode":"name"},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[2816,2064],"id":"8fce66ca-b2a7-4814-9ab5-961f616e6a0f","name":"Get row(s) in sheet","credentials":{"googleSheetsOAuth2Api":{"id":"b5DluHDjTyDAsQWd","name":"Google Sheets account"}}},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"id":"7ba9d3b4-0e56-48ca-bb39-4bd86db3fa75","leftValue":"={{ $json.status }}","rightValue":1,"operator":{"type":"number","operation":"equals"}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.filter","typeVersion":2.3,"position":[3024,2064],"id":"3803c035-3d76-4acf-a6e7-fbddcd8210e1","name":"Filter"},{"parameters":{"jsCode":"return items.map(item => {\n  const d = item.json;\n\n  const num = (v) => {\n    if (v === null || v === undefined || v === '') return null;\n    const n = Number(v);\n    return Number.isFinite(n) ? n : null;\n  };\n\n  const bool1 = (v) => num(v) === 1;\n\n  const strOrNull = (v) => {\n    const s = (v ?? '').toString().trim();\n    return s ? s : null;\n  };\n\n  const titleStr = (d.title ?? '').toString();\n  const titleNorm = titleStr.trim().toUpperCase();\n\n  // NEW: marker for \"GOODMORNING\" posts (text will be taken from COOP_FACT later in Expand per store)\n  const isGoodMorning = titleNorm === 'GOODMORNING';\n\n  return {\n    json: {\n      id: num(d.id),\n      status: num(d.status),\n      region: num(d.region),\n      post_type: num(d.post_type),\n\n      send_tg: bool1(d.send_tg),\n      send_vk: bool1(d.send_vk),\n      send_site: bool1(d.send_site),\n\n      // debug flag for telegram routing (1 = send to test channel)\n      tg_debug: num(d.tg_debug),\n\n      title: titleStr,\n      text: d.text ?? '',\n      parse_mode: num(d.parse_mode) ?? 0,\n\n      media_raw: d.media_url ?? '',\n\n      // старая логика: ссылка на бота (формат \"197_КУПИТЬ\")\n      old_post: strOrNull(d.old_post),\n\n      all_region: bool1(d.all_region),\n      points_note_mode:\n        d.points_note_mode === '' || d.points_note_mode === null || d.points_note_mode === undefined\n          ? null\n          : (num(d.points_note_mode) ?? null),\n\n      schedule: strOrNull(d.schedule),\n      publish_at: strOrNull(d.publish_at),\n\n      // service fields\n      last_run_at_utc: strOrNull(d.last_run_at_utc),\n      last_run_at: strOrNull(d.last_run_at),\n      last_run_key: strOrNull(d.last_run_key),\n\n      error: strOrNull(d.error),\n\n      // NEW: flag for downstream logic\n      _goodmorning: isGoodMorning,\n\n      // исходная строка целиком (включая колонки точек)\n      _raw: d,\n    },\n  };\n});\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[3232,2064],"id":"a378a9e4-e949-481c-af89-26a3ed9c656f","name":"Code in JavaScript"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"id":"a642aa85-b884-4c19-a91b-7222a19570d1","leftValue":"={{ $json._due }}","rightValue":true,"operator":{"type":"boolean","operation":"equals"}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.filter","typeVersion":2.3,"position":[3616,2064],"id":"18768023-7135-4945-b759-0882d3342d5a","name":"Filter1"},{"parameters":{"jsCode":"// === НАСТРОЙКИ ===\nconst TG_TEST_CHAT_ID = '-1003640743827';\n\n// !!! Поставьте реальные имена узлов:\nconst FILTER_NODE_NAME = 'Filter1';\nconst POSTGRES_NODE_NAME = 'Postgre_store_extract';\nconst COOP_FACT_NODE_NAME = 'GS_CoopFact_GetRows'; // NEW\n\n// Telegram deep-link base\nconst TG_OLD_BOT_BASE = 'https://t.me/kooptorg3_start_bot?start=';\n\nfunction regionToStoreTz(region) {\n  if (Number(region) === 54) return 7;\n  if (Number(region) === 82) return 3;\n  return null;\n}\n\nfunction regionToTzName(region) {\n  if (Number(region) === 54) return 'Asia/Novosibirsk';\n  if (Number(region) === 82) return 'Europe/Simferopol';\n  return 'Europe/Moscow';\n}\n\nfunction escapeHtml(s) {\n  return String(s ?? '')\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;');\n}\n\n// минимально достаточное экранирование MarkdownV2\nfunction escapeMarkdownV2(s) {\n  // Telegram MarkdownV2 special chars: _ * [ ] ( ) ~ ` > # + - = | { } . !\n  return String(s ?? '').replace(/[_*[\\]()~`>#+\\-=|{}.!]/g, '\\\\$&');\n}\n\nfunction buildTgTextAndMode(post) {\n  let text = (post.text ?? '').toString();\n  let parseMode = 'HTML';\n\n  if (Number(post.parse_mode) === 1) {\n    parseMode = 'HTML';\n  } else if (Number(post.parse_mode) === 2) {\n    parseMode = 'MarkdownV2';\n  } else {\n    text = escapeHtml(text);\n    parseMode = 'HTML';\n  }\n\n  return { text, parse_mode: parseMode };\n}\n\n// old_post format: \"197_КУПИТЬ\"\nfunction parseOldPost(oldPostValue) {\n  const raw = (oldPostValue ?? '').toString().trim();\n  if (!raw) return null;\n\n  const m = raw.match(/^(\\d{3})_(.+)$/);\n  if (!m) return null;\n\n  const oldId = m[1];\n  const label = (m[2] ?? '').toString().trim();\n  if (!label) return null;\n\n  return { old_id: oldId, label: label.toUpperCase() };\n}\n\nfunction formatDDMMYYYYInTz(dateUtc, tzName) {\n  const parts = new Intl.DateTimeFormat('en-GB', {\n    timeZone: tzName,\n    day: '2-digit',\n    month: '2-digit',\n    year: 'numeric',\n  }).formatToParts(dateUtc);\n\n  const map = {};\n  for (const p of parts) if (p.type !== 'literal') map[p.type] = p.value;\n\n  return `${map.day}${map.month}${map.year}`;\n}\n\n// YYYY-MM-DD in TZ from UTC date\nfunction formatYYYYMMDDInTz(dateUtc, tzName) {\n  const parts = new Intl.DateTimeFormat('en-CA', {\n    timeZone: tzName,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n  }).formatToParts(dateUtc);\n\n  const map = {};\n  for (const p of parts) if (p.type !== 'literal') map[p.type] = p.value;\n\n  return `${map.year}-${map.month}-${map.day}`;\n}\n\nfunction buildOldLink({ old_id, label }, storeId, datePart, parseMode) {\n  const sid = String(storeId ?? '').trim();\n  if (!sid) return null;\n\n  // шаблон как в твоём примере: webapp_<oldId><DDMMYYYY><storeId>_<storeId>\n  const startParam = `webapp_${old_id}${datePart}${sid}_${sid}`;\n  const url = `${TG_OLD_BOT_BASE}${startParam}`;\n\n  if (parseMode === 'MarkdownV2') {\n    const textMd = escapeMarkdownV2(label);\n    // URL в MarkdownV2 лучше тоже экранировать минимум (скобки и т.п.)\n    const urlMd = url.replace(/\\)/g, '\\\\)').replace(/\\(/g, '\\\\(');\n    return `[${textMd}](${urlMd})`;\n  }\n\n  // HTML\n  const textHtml = escapeHtml(label);\n  const urlHtml = escapeHtml(url);\n  return `<a href=\"${urlHtml}\">${textHtml}</a>`;\n}\n\nfunction appendOldLinkToText(text, oldLink) {\n  const base = (text ?? '').toString();\n  if (!oldLink) return base;\n  if (!base.trim()) return oldLink;\n  return `${base}\\n\\n${oldLink}`;\n}\n\n// Ваш формат: store_195_Большевистская\nfunction pickStoreIdsFromRaw(raw) {\n  const ids = [];\n  for (const [k, v] of Object.entries(raw || {})) {\n    const key = String(k ?? '').trim();\n    const m = key.match(/^store_(\\d+)_/); // строго ваш формат\n    if (!m) continue;\n\n    const storeId = Number(m[1]);\n    if (!Number.isFinite(storeId)) continue;\n\n    const vv = (v ?? '').toString().trim();\n    if (vv === '1') ids.push(storeId);\n  }\n  return ids;\n}\n\nfunction cleanLine(s) {\n  return String(s ?? '')\n    .replace(/[\\uFEFF\\u200B\\u200C\\u200D\\u2060\\u00AD]/g, '')\n    .trim();\n}\n\n/**\n * media_raw format (each line):\n *   ф|https://...\n *   в|https://...\n * returns [{type:'photo'|'video', media:'url'}]\n */\nfunction parseMediaLines(mediaRaw) {\n  const raw = (mediaRaw ?? '').toString();\n  const lines = raw.split(/\\r\\n|\\n|\\r/g).map(cleanLine).filter(Boolean);\n\n  const out = [];\n  for (const line of lines) {\n    const m = line.match(/^([фв])\\|(.*)$/i);\n    if (!m) continue;\n\n    const kind = m[1].toLowerCase();\n    const url = cleanLine(m[2] || '');\n    if (!url) continue;\n\n    out.push({\n      type: kind === 'ф' ? 'photo' : 'video',\n      media: url,\n    });\n  }\n  return out;\n}\n\nfunction isCaptionOk(text) {\n  const t = (text ?? '').toString();\n  // caption limit ~1024; keep margin\n  return t.length > 0 && t.length <= 950;\n}\n\n// NEW: normalize COOP_FACT date to YYYY-MM-DD (supports 04/01/2026)\nfunction normalizeFactDate(v) {\n  const s = cleanLine(v);\n  if (!s) return null;\n\n  // YYYY-MM-DD\n  let m = s.match(/^(\\d{4})-(\\d{2})-(\\d{2})$/);\n  if (m) return `${m[1]}-${m[2]}-${m[3]}`;\n\n  // DD.MM.YYYY\n  m = s.match(/^(\\d{2})\\.(\\d{2})\\.(\\d{4})$/);\n  if (m) return `${m[3]}-${m[2]}-${m[1]}`;\n\n  // DD/MM/YYYY  (your format: 04/01/2026)\n  m = s.match(/^(\\d{2})\\/(\\d{2})\\/(\\d{4})$/);\n  if (m) {\n    const dd = Number(m[1]);\n    const mm = Number(m[2]);\n    const yyyy = Number(m[3]);\n    if (dd >= 1 && dd <= 31 && mm >= 1 && mm <= 12) {\n      const dds = String(dd).padStart(2, '0');\n      const mms = String(mm).padStart(2, '0');\n      return `${yyyy}-${mms}-${dds}`;\n    }\n  }\n\n  // Try Date.parse for ISO-ish values (not reliable for 04/01/2026, but ok for other strings)\n  const t = Date.parse(s);\n  if (!Number.isNaN(t)) {\n    const d = new Date(t);\n    const y = d.getUTCFullYear();\n    const mo = String(d.getUTCMonth() + 1).padStart(2, '0');\n    const da = String(d.getUTCDate()).padStart(2, '0');\n    return `${y}-${mo}-${da}`;\n  }\n\n  return null;\n}\n\n// get publish date (YYYY-MM-DD) in region TZ for GOODMORNING\nfunction getGoodMorningDateKey(post, tzName) {\n  // Prefer _occurrence_utc (for recurring). For one-time it will also be present in your Determine due.\n  const occIso = cleanLine(post._occurrence_utc);\n  if (occIso) {\n    const d = new Date(occIso);\n    if (!Number.isNaN(d.getTime())) return formatYYYYMMDDInTz(d, tzName);\n  }\n\n  // Fallback: parse from _occurrence_local / _publish_at_parsed (strings like \"YYYY-MM-DD ... (TZ)\")\n  const s1 = cleanLine(post._occurrence_local);\n  if (s1) {\n    const m = s1.match(/^(\\d{4}-\\d{2}-\\d{2})\\b/);\n    if (m) return m[1];\n  }\n\n  const s2 = cleanLine(post._publish_at_parsed);\n  if (s2) {\n    const m = s2.match(/^(\\d{4}-\\d{2}-\\d{2})\\b/);\n    if (m) return m[1];\n  }\n\n  // Last resort: if publish_at exists as \"YYYY-MM-DD ...\" without TZ\n  const s3 = cleanLine(post.publish_at);\n  if (s3) {\n    const m = s3.match(/^(\\d{4}-\\d{2}-\\d{2})\\b/);\n    if (m) return m[1];\n  }\n\n  return null;\n}\n\n// --- Забираем данные по имени узлов ---\nconst postsInput = $items(FILTER_NODE_NAME).map(x => x.json);\nconst storesInput = $items(POSTGRES_NODE_NAME).map(x => x.json);\nconst factsInput = $items(COOP_FACT_NODE_NAME).map(x => x.json);\n\n// Build facts map: YYYY-MM-DD -> fact\nconst factMap = new Map();\nfor (const row of factsInput) {\n  const dk = normalizeFactDate(row?.date);\n  const fact = cleanLine(row?.fact);\n  if (!dk || !fact) continue;\n  factMap.set(dk, row.fact); // keep last\n}\n\n// Диагностика stores\nconst tzSet = new Set();\nfor (const s of storesInput) {\n  if (s && s.time_zone !== undefined && s.time_zone !== null && s.time_zone !== '') {\n    tzSet.add(String(s.time_zone));\n  }\n}\nconst storesDebug = {\n  stores_count: storesInput.length,\n  stores_time_zones: Array.from(tzSet).sort(),\n  stores_first_keys: storesInput[0] ? Object.keys(storesInput[0]) : [],\n  facts_count: factsInput.length,\n  facts_keys_sample: Array.from(factMap.keys()).slice(0, 10),\n};\n\n// Если stores не пришли — вернём ошибку на каждый пост\nif (storesInput.length === 0) {\n  return postsInput.map(post => ({\n    json: {\n      ...post,\n      _tg_targets_empty: true,\n      _tg_targets_reason: `stores input is empty: $items(\"${POSTGRES_NODE_NAME}\") returned 0 rows`,\n      _stores_debug: storesDebug,\n\n      // важные служебные поля для дальнейшего апдейта Sheets\n      row_number: post?._raw?.row_number ?? null,\n      _now: post._now ?? null,\n      _now_utc: post._now_utc ?? null,\n      _run_key: post._run_key ?? null,\n    },\n  }));\n}\n\n// Map store_id -> storeRow\nconst storeMap = new Map();\nfor (const s of storesInput) {\n  const storeId = Number(s.store_id);\n  if (!Number.isFinite(storeId)) continue;\n  if (!storeMap.has(storeId)) storeMap.set(storeId, s);\n}\n\nconst out = [];\n\nfor (const post of postsInput) {\n  // Раньше тут было: if (!post.send_tg) continue;\n  // Теперь: пропускаем VK/SITE посты дальше одним item, а TG-развёртку делаем только когда send_tg=true\n\n  const hasAnyChannel = Boolean(post.send_tg || post.send_vk || post.send_site);\n  if (!hasAnyChannel) continue;\n\n  // --- протаскиваем row_number (для Update в Sheets) ---\n  const rowNumber = post?._raw?.row_number ?? null;\n\n  // --- протаскиваем служебные поля запуска (для last_run_*) ---\n  const nowLocal = post._now ?? null;      // локальное время региона (строка)\n  const nowUtcIso = post._now_utc ?? null; // ISO UTC\n  const runKey = post._run_key ?? null;\n\n  // --- GOODMORNING text override from COOP_FACT (общий, меняем post.text) ---\n  const tzName = regionToTzName(post.region);\n  let postForText = post;\n\n  if (post._goodmorning === true) {\n    const dateKey = getGoodMorningDateKey(post, tzName);\n    const fact = dateKey ? factMap.get(dateKey) : null;\n\n    if (!dateKey) {\n      out.push({\n        json: {\n          ...post,\n          row_number: rowNumber,\n          _now: nowLocal,\n          _now_utc: nowUtcIso,\n          _run_key: runKey,\n\n          _prepare_error: `GOODMORNING: cannot determine date key from occurrence/publish fields`,\n          _goodmorning_date_key: null,\n          _stores_debug: storesDebug,\n        },\n      });\n      continue;\n    }\n\n    if (!fact || !cleanLine(fact)) {\n      out.push({\n        json: {\n          ...post,\n          row_number: rowNumber,\n          _now: nowLocal,\n          _now_utc: nowUtcIso,\n          _run_key: runKey,\n\n          _prepare_error: `GOODMORNING: no fact found for date=${dateKey} in COOP_FACT`,\n          _goodmorning_date_key: dateKey,\n          _stores_debug: storesDebug,\n        },\n      });\n      continue;\n    }\n\n    postForText = {\n      ...post,\n      text: `${fact}\\n!!Навигация`,\n      _goodmorning_date_key: dateKey,\n    };\n  }\n  // --- /GOODMORNING ---\n\n  // === Если TG не нужен — просто пробрасываем item дальше (для VK/SITE) ===\n  if (!postForText.send_tg) {\n    out.push({\n      json: {\n        ...postForText,\n        row_number: rowNumber,\n        _now: nowLocal,\n        _now_utc: nowUtcIso,\n        _run_key: runKey,\n        _stores_debug: storesDebug,\n      },\n    });\n    continue;\n  }\n\n  // === TG часть (как было) ===\n  const tzNeed = regionToStoreTz(postForText.region);\n  if (tzNeed === null) {\n    out.push({\n      json: {\n        ...postForText,\n        row_number: rowNumber,\n        _now: nowLocal,\n        _now_utc: nowUtcIso,\n        _run_key: runKey,\n\n        _tg_targets_empty: true,\n        _tg_targets_reason: `unknown region=${postForText.region}`,\n        _stores_debug: storesDebug,\n      },\n    });\n    continue;\n  }\n\n  // store_id цели\n  let targetStoreIds = [];\n  if (postForText.all_region) {\n    for (const s of storesInput) {\n      if (Number(s.time_zone) === tzNeed) {\n        const id = Number(s.store_id);\n        if (Number.isFinite(id)) targetStoreIds.push(id);\n      }\n    }\n  } else {\n    targetStoreIds = pickStoreIdsFromRaw(postForText._raw);\n  }\n\n  targetStoreIds = Array.from(new Set(targetStoreIds));\n\n  if (targetStoreIds.length === 0) {\n    out.push({\n      json: {\n        ...postForText,\n        row_number: rowNumber,\n        _now: nowLocal,\n        _now_utc: nowUtcIso,\n        _run_key: runKey,\n\n        _tg_targets_empty: true,\n        _tg_targets_reason: postForText.all_region\n          ? `no stores found for time_zone=${tzNeed} (stores_count=${storesInput.length}, tzs=${storesDebug.stores_time_zones.join(',')})`\n          : 'no store columns selected in sheet row (no store_* = 1)',\n        _stores_debug: storesDebug,\n      },\n    });\n    continue;\n  }\n\n  const tgBase = buildTgTextAndMode(postForText);\n  const debugMode = Number(postForText.tg_debug) === 1;\n\n  // ---- parse media ----\n  const mediaRaw = (postForText.media_raw ?? postForText.media_url ?? postForText._raw?.media_raw ?? postForText._raw?.media_url ?? '').toString();\n  const mediaArr = parseMediaLines(mediaRaw);\n\n  // old_post parsing (only if present)\n  const oldParsed = parseOldPost(postForText.old_post ?? postForText._raw?.old_post);\n\n  // date part for old_link in region tz\n  const nowUtcObj = nowUtcIso ? new Date(nowUtcIso) : new Date();\n  const datePart = formatDDMMYYYYInTz(nowUtcObj, tzName);\n\n  // базовое решение по типу отправки (без учета caption длины — это сделаем per-store)\n  let baseOp = 'message'; // message | photo | video | media_group\n  let baseMedia = null;\n\n  if (mediaArr.length === 0) {\n    baseOp = 'message';\n  } else if (mediaArr.length === 1) {\n    baseOp = mediaArr[0].type === 'photo' ? 'photo' : 'video';\n    baseMedia = mediaArr[0].media;\n  } else {\n    baseOp = 'media_group';\n  }\n\n  const seenChat = new Set();\n  let produced = 0;\n\n  for (const storeId of targetStoreIds) {\n    const s = storeMap.get(storeId);\n    if (!s) continue;\n    if (Number(s.time_zone) !== tzNeed) continue;\n\n    const chatId = debugMode ? TG_TEST_CHAT_ID : s.channel_chat_id;\n    const chatKey = String(chatId);\n    if (seenChat.has(chatKey)) continue;\n    seenChat.add(chatKey);\n\n    // --- old link for this store (depends on storeId) ---\n    const oldLink = oldParsed ? buildOldLink(oldParsed, storeId, datePart, tgBase.parse_mode) : null;\n    const tgTextFinal = appendOldLinkToText(tgBase.text, oldLink);\n\n    // --- per-store media decision for albums: caption may be too long ---\n    let tgOp = baseOp;\n    let tgMedia = baseMedia;\n    let tgMediaGroup = null;\n    let needExtraTextMessage = false;\n\n    if (baseOp === 'media_group') {\n      tgMediaGroup = mediaArr;\n\n      if (isCaptionOk(tgTextFinal)) {\n        tgMediaGroup = tgMediaGroup.map((m, idx) => {\n          if (idx === 0) {\n            return {\n              ...m,\n              caption: tgTextFinal,\n              parse_mode: tgBase.parse_mode,\n            };\n          }\n          return m;\n        });\n      } else if (tgTextFinal.trim()) {\n        // caption слишком длинный — альбом без caption, а текст отдельным сообщением\n        needExtraTextMessage = true;\n      }\n    }\n\n    // 1) основной item\n    out.push({\n      json: {\n        ...postForText,\n\n        // служебные поля для апдейта Sheets\n        row_number: rowNumber,\n        _now: nowLocal,\n        _now_utc: nowUtcIso,\n        _run_key: runKey,\n\n        // данные цели\n        store_id: storeId,\n        store_description: s.store_description ?? null,\n\n        // routing for telegram\n        tg_op: tgOp,\n        tg_media: tgMedia,\n        tg_media_group: tgMediaGroup,\n\n        // old link debug\n        _old_post_parsed: oldParsed,\n        _old_post_date_ddmmyyyy: datePart,\n        _old_post_link: oldLink,\n\n        tg: {\n          chat_id: chatId,\n          text: tgTextFinal,\n          parse_mode: tgBase.parse_mode,\n          debug: debugMode,\n        },\n\n        _run_key_channel: runKey ? `${runKey}|store:${storeId}` : null,\n        _stores_debug: storesDebug,\n      },\n    });\n\n    produced++;\n\n    // 2) если альбом и текст длинный — отдельное сообщение текстом после альбома\n    if (tgOp === 'media_group' && needExtraTextMessage) {\n      out.push({\n        json: {\n          ...postForText,\n\n          row_number: rowNumber,\n          _now: nowLocal,\n          _now_utc: nowUtcIso,\n          _run_key: runKey,\n\n          store_id: storeId,\n          store_description: s.store_description ?? null,\n\n          tg_op: 'message',\n          tg_media: null,\n          tg_media_group: null,\n\n          // old link debug\n          _old_post_parsed: oldParsed,\n          _old_post_date_ddmmyyyy: datePart,\n          _old_post_link: oldLink,\n\n          tg: {\n            chat_id: chatId,\n            text: tgTextFinal,\n            parse_mode: tgBase.parse_mode,\n            debug: debugMode,\n          },\n\n          _run_key_channel: runKey ? `${runKey}|store:${storeId}|text_after_album` : null,\n          _stores_debug: storesDebug,\n        },\n      });\n    }\n  }\n\n  if (produced === 0) {\n    out.push({\n      json: {\n        ...postForText,\n        row_number: rowNumber,\n        _now: nowLocal,\n        _now_utc: nowUtcIso,\n        _run_key: runKey,\n\n        _tg_targets_empty: true,\n        _tg_targets_reason: `stores selected but none matched mapping for time_zone=${tzNeed} (stores_count=${storesInput.length}, tzs=${storesDebug.stores_time_zones.join(',')})`,\n        _stores_debug: storesDebug,\n      },\n    });\n  }\n}\n\nreturn out;\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[4176,2160],"id":"617eb794-ad1d-44d7-8378-e3e1f0985222","name":"Code in JavaScript2","onError":"continueRegularOutput"},{"parameters":{"chatId":"={{ $json.tg_chat_id }}","text":"={{ $json.tg_text }}","additionalFields":{"appendAttribution":false,"parse_mode":"={{ $json.tg_parse_mode }}"}},"type":"n8n-nodes-base.telegram","typeVersion":1.2,"position":[5120,1952],"id":"614c7d54-f62f-4c3a-b8b2-3dff1afb89ba","name":"Send a text message","webhookId":"3d5fc0f2-7e10-4bcb-9f24-3baaed55981d","alwaysOutputData":true,"credentials":{"telegramApi":{"id":"PvtTCKhw5iSNTNjL","name":"Telegram account"}},"onError":"continueRegularOutput"},{"parameters":{"operation":"executeQuery","query":"SELECT\n  s.store_id,\n  s.store_description,\n  s.time_zone,\n  MAX(sc.channel_chat_id) AS channel_chat_id,\n  MAX(sc.discussion_chat_id) AS discussion_chat_id\nFROM coop.order_store s\nJOIN coop.store_channel sc ON sc.store_id = s.store_id\nWHERE sc.channel_chat_id IS NOT NULL\n  AND s.time_zone IN (3, 7)\n  AND s.store_close_date IS NULL\nGROUP BY s.store_id, s.store_description, s.time_zone\nORDER BY s.time_zone, s.store_id;","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[3792,2304],"id":"81a440af-3bda-4a0e-89ba-dbd8d8f5ad5a","name":"Postgre_store_extract","executeOnce":true,"credentials":{"postgres":{"id":"Nn7xJ9wkuFYHFyvT","name":"Postgres account"}}},{"parameters":{"jsCode":"/**\n * Collect TG results per post_id (after Merge Combine/Position)\n * Supports:\n *  - Telegram nodes (they often return { ok:true, result:... } or set p.error on continueRegularOutput)\n *  - HTTP Request node (sendMediaGroup) which may return:\n *      - { statusCode: 200, body: { ok:true, result:[...] } }  (when JSON)\n *      - { statusCode: 200, body: \"...\" }                      (when string)\n *      - errors in p.error / p.message / p.response / p.body\n *\n * Output: one item per post_id with aggregation + Sheets update fields\n */\n\nconst items = $input.all();\n\nfunction safeStr(v) {\n  if (v === null || v === undefined) return '';\n  return String(v);\n}\n\nfunction toNumOrNull(v) {\n  if (v === null || v === undefined || v === '') return null;\n  const n = Number(v);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction appendLog(existing, line) {\n  const base = (existing ?? '').toString().trim();\n  if (!base) return line;\n  return base + '\\n' + line;\n}\n\nfunction tryJsonParse(s) {\n  try {\n    return JSON.parse(s);\n  } catch (e) {\n    return null;\n  }\n}\n\n// --- Detect ok for both Telegram node and HTTP Request node ---\nfunction detectOk(p) {\n  if (!p) return false;\n\n  // Telegram node common\n  if (p.ok === true || p.success === true) return true;\n\n  // HTTP Request node common shapes\n  // 1) response object\n  if (p.response && (p.response.ok === true || p.response.success === true)) return true;\n\n  // 2) body may be object or stringified json\n  const body = p.body ?? p.response?.body ?? null;\n  if (body && typeof body === 'object') {\n    if (body.ok === true) return true;\n    // sometimes nested\n    if (body.data?.ok === true) return true;\n  }\n  if (typeof body === 'string') {\n    const j = tryJsonParse(body);\n    if (j && j.ok === true) return true;\n  }\n\n  // 3) n8n httpRequest often exposes statusCode\n  const sc = p.statusCode ?? p.status ?? p.response?.statusCode ?? null;\n  if (typeof sc === 'number' && sc >= 200 && sc < 300) {\n    // If Telegram returns non-ok with 200, we'd have body.ok=false.\n    // But if we can't see body, treat 2xx as ok to avoid false FAIL logs.\n    return true;\n  }\n\n  return false;\n}\n\nfunction extractErrorText(p) {\n  if (!p) return 'unknown error';\n\n  // Telegram node error object\n  if (typeof p.error === 'string') return p.error;\n  if (p.error?.message) return safeStr(p.error.message);\n\n  // httpRequest node sometimes exposes errorMessage / message\n  if (p.errorMessage) return safeStr(p.errorMessage);\n  if (p.message) return safeStr(p.message);\n  if (p.description) return safeStr(p.description);\n  if (p.cause) return safeStr(p.cause);\n\n  // response/body shapes\n  const body = p.body ?? p.response?.body ?? p.responseBody ?? null;\n\n  if (body && typeof body === 'object') {\n    if (body.description) return safeStr(body.description);\n    if (body.error) return safeStr(body.error);\n    if (body.message) return safeStr(body.message);\n    if (body.ok === false && body.description) return safeStr(body.description);\n    try {\n      return JSON.stringify(body);\n    } catch (e) {\n      return 'unstringifiable body';\n    }\n  }\n\n  if (typeof body === 'string') {\n    const j = tryJsonParse(body);\n    if (j) {\n      if (j.description) return safeStr(j.description);\n      if (j.error) return safeStr(j.error);\n      if (j.message) return safeStr(j.message);\n      if (j.ok === false && j.description) return safeStr(j.description);\n      try {\n        return JSON.stringify(j);\n      } catch (e) {}\n    }\n    // raw string body\n    const s = body.trim();\n    if (s) return s.slice(0, 500);\n  }\n\n  // fallback stringify whole p.error if exists\n  if (p.error) {\n    try {\n      return JSON.stringify(p.error);\n    } catch (e) {\n      return 'unstringifiable error';\n    }\n  }\n\n  return 'unknown error';\n}\n\n// group per post_id\nconst byPost = new Map();\n\nfor (const item of items) {\n  const p = item.json || {};\n\n  const postId = p.post_id ?? p.id ?? null;\n  if (!postId) continue;\n\n  if (!byPost.has(postId)) {\n    byPost.set(postId, {\n      post_id: postId,\n      row_number: toNumOrNull(p.row_number),\n\n      last_run_key: p._run_key ?? null,\n      now_utc: p._now_utc ?? new Date().toISOString(),\n      now_local: p._now ?? null,\n\n      plan_run_at: p._plan_run_at ?? null,\n      prev_error: p.error_prev ?? null,\n\n      total: 0,\n      ok: 0,\n      fail: 0,\n      fails: [],\n    });\n  }\n\n  const agg = byPost.get(postId);\n\n  if (!agg.plan_run_at && p._plan_run_at) agg.plan_run_at = p._plan_run_at;\n\n  agg.total += 1;\n\n  const ok = detectOk(p);\n\n  const storeId = p.store_id ?? null;\n  const chatId = p.tg_chat_id ?? p.chat_id ?? null;\n\n  if (ok) {\n    agg.ok += 1;\n  } else {\n    agg.fail += 1;\n    const desc = extractErrorText(p);\n    agg.fails.push({\n      store_id: storeId,\n      chat_id: chatId,\n      desc: safeStr(desc),\n    });\n  }\n}\n\nconst out = [];\n\nfor (const agg of byPost.values()) {\n  // success only if at least one ok and no fails\n  const allOk = agg.fail === 0 && agg.ok > 0;\n\n  let newError = agg.prev_error;\n\n  if (allOk) {\n    newError = appendLog(\n      newError,\n      `[OK TG] ${agg.now_utc} key=${safeStr(agg.last_run_key)} sent=${agg.ok}/${agg.total}`\n    );\n  } else {\n    const failLines = agg.fails\n      .slice(0, 20)\n      .map(f => `store=${safeStr(f.store_id)} chat=${safeStr(f.chat_id)} err=${safeStr(f.desc)}`)\n      .join(' | ');\n\n    newError = appendLog(\n      newError,\n      `[FAIL TG] ${agg.now_utc} key=${safeStr(agg.last_run_key)} ok=${agg.ok}/${agg.total} fails=${agg.fail}` +\n        (failLines ? ` :: ${failLines}` : '')\n    );\n  }\n\n  out.push({\n    json: {\n      post_id: agg.post_id,\n      row_number: agg.row_number,\n\n      _all_ok: allOk,\n      _sent_ok: agg.ok,\n      _sent_fail: agg.fail,\n      _sent_total: agg.total,\n\n      update_last_run_at_utc: allOk ? agg.now_utc : null,\n      update_last_run_at: allOk ? agg.now_local : null,\n      update_last_run_key: allOk ? agg.last_run_key : null,\n\n      // write plan_run_at only on success\n      update_plan_run_at: allOk ? (agg.plan_run_at ?? null) : null,\n\n      update_error: newError,\n    },\n  });\n}\n\nreturn out;\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[5760,2032],"id":"98d40e8b-1228-40b7-b8b6-e9554671a83b","name":"Collect TG results"},{"parameters":{"assignments":{"assignments":[{"id":"1f3d5cad-548c-48bd-a374-ccdde7c4314f","name":"row_number","value":"={{$json.row_number}}","type":"number"},{"id":"254b0c02-3d0b-49ad-a8ca-7458f17209c3","name":"=post_id","value":"={{$json.id}}","type":"number"},{"id":"9afe30be-bf19-4af9-80fa-87e2353d83cc","name":"=_run_key","value":"={{$json._run_key}}","type":"string"},{"id":"1af1f314-8f5a-4a78-a072-f8d807c68e4d","name":"_now","value":"={{$json._now}}","type":"string"},{"id":"0aa65ec9-dd1e-4222-be13-933718236ee1","name":"_now_utc","value":"={{$json._now_utc}}","type":"string"},{"id":"640a3f9b-df58-45a7-8fbe-f29fa198bf8a","name":"store_id","value":"={{$json.store_id}}","type":"number"},{"id":"c02060fc-02fd-43b4-9c21-5b2a0a1f439b","name":"tg_chat_id","value":"={{$json.tg.chat_id}}","type":"string"},{"id":"6ab1367a-f53c-46cc-a263-d88103dbcc96","name":"tg_text","value":"={{$json.tg.text}}","type":"string"},{"id":"2b04009d-0cf0-47df-83fe-3209c35bf1ee","name":"tg_parse_mode","value":"={{$json.tg.parse_mode}}","type":"string"},{"id":"b9c1c913-0000-4295-88b0-9f32cd8d6d6b","name":"error_prev","value":"={{$json.error}}","type":"string"},{"id":"077dde57-5614-483b-afbe-504eec04fb67","name":"tg_op","value":"={{$json.tg_op}}","type":"string"},{"id":"2e21132e-99ed-4797-b9a9-373ab5b8ec2b","name":"tg_media","value":"={{$json.tg_media}}","type":"string"},{"id":"4fe678fe-b144-40d8-89d9-7037ede12a83","name":"tg_media_group_json","value":"={{ JSON.stringify($json.tg_media_group) }}","type":"string"},{"id":"f3930a07-f3c3-4722-a6e6-0bbb3ecddb35","name":"_old_post_link","value":"={{$json._old_post_link}}","type":"string"},{"id":"e0106ac8-b2bf-455d-81e8-ee4bfe5cd40a","name":"_plan_run_at","value":"={{$json._plan_run_at}}","type":"string"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[4480,2192],"id":"3fd86191-ec11-4da6-8192-1db3f790edfb","name":"Edit Fields"},{"parameters":{"mode":"combine","combineBy":"combineByPosition","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5280,1968],"id":"3266d860-5900-47bb-bbe2-84a9e5a691c0","name":"Merge"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"loose","version":3},"conditions":[{"id":"1de16de6-60be-47d0-85bb-be106d58e7e2","leftValue":"={{$json._all_ok}}","rightValue":"true","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"looseTypeValidation":true,"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.3,"position":[6672,2032],"id":"52ed79ce-4188-442b-9ec8-1db69e538f30","name":"If"},{"parameters":{"operation":"update","documentId":{"__rl":true,"value":"1FyEGxa6JYTJxDrowfgzAzroTM8L3CWCSY1rgI2DK9KQ","mode":"id"},"sheetName":{"__rl":true,"value":"POST","mode":"name"},"columns":{"mappingMode":"defineBelow","value":{"row_number":"={{$json.row_number}}","last_run_at_utc":"={{$json.update_last_run_at_utc}}","last_run_at":"={{$json.update_last_run_at}}","last_run_key":"={{$json.update_last_run_key}}","error":"={{$json.update_error}}","plan_run_at":"={{$json.update_plan_run_at}}"},"matchingColumns":["row_number"],"schema":[{"id":"id","displayName":"id","required":false,"defaultMatch":true,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"status","displayName":"status","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"region","displayName":"region","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"post_type","displayName":"post_type","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"tg_debug","displayName":"tg_debug","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"send_tg","displayName":"send_tg","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"send_vk","displayName":"send_vk","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"send_site","displayName":"send_site","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"old_post","displayName":"old_post","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"title","displayName":"title","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"media_url","displayName":"media_url","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"parse_mode","displayName":"parse_mode","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"text","displayName":"text","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"points_note_mode","displayName":"points_note_mode","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"all_region","displayName":"all_region","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_195_Большевистская","displayName":"store_195_Большевистская","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_191_Рябиновая","displayName":"store_191_Рябиновая","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_190_Золотодолинская","displayName":"store_190_Золотодолинская","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_174_Онега","displayName":"store_174_Онега","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_166_Станиславского","displayName":"store_166_Станиславского","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_186_Краснообск","displayName":"store_186_Краснообск","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_193_БердскВокзальная","displayName":"store_193_БердскВокзальная","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_160_Декабристов41","displayName":"store_160_Декабристов41","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_189_Ялта","displayName":"store_189_Ялта","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_211_Симферополь","displayName":"store_211_Симферополь","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"schedule","displayName":"schedule","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"publish_at","displayName":"publish_at","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"last_run_at_utc","displayName":"last_run_at_utc","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":false},{"id":"last_run_at","displayName":"last_run_at","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":false},{"id":"last_run_key","displayName":"last_run_key","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":false},{"id":"plan_run_at","displayName":"plan_run_at","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":false},{"id":"error","displayName":"error","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":false},{"id":"row_number","displayName":"row_number","required":false,"defaultMatch":false,"display":true,"type":"number","canBeUsedToMatch":true,"readOnly":true,"removed":false}],"attemptToConvertTypes":false,"convertFieldsToString":false},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[6944,1792],"id":"004c762c-9b70-46cd-a66e-13e8c0ca5690","name":"Update row in sheet","credentials":{"googleSheetsOAuth2Api":{"id":"b5DluHDjTyDAsQWd","name":"Google Sheets account"}}},{"parameters":{"operation":"update","documentId":{"__rl":true,"value":"1FyEGxa6JYTJxDrowfgzAzroTM8L3CWCSY1rgI2DK9KQ","mode":"id"},"sheetName":{"__rl":true,"value":"POST","mode":"name"},"columns":{"mappingMode":"defineBelow","value":{"row_number":"={{$json.row_number}}","error":"={{$json.update_error}}"},"matchingColumns":["row_number"],"schema":[{"id":"id","displayName":"id","required":false,"defaultMatch":true,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"status","displayName":"status","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"region","displayName":"region","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"post_type","displayName":"post_type","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"tg_debug","displayName":"tg_debug","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"send_tg","displayName":"send_tg","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"send_vk","displayName":"send_vk","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"send_site","displayName":"send_site","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"title","displayName":"title","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"media_url","displayName":"media_url","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"parse_mode","displayName":"parse_mode","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"text","displayName":"text","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"points_note_mode","displayName":"points_note_mode","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"all_region","displayName":"all_region","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_195_Большевистская","displayName":"store_195_Большевистская","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_191_Рябиновая","displayName":"store_191_Рябиновая","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_190_Золотодолинская","displayName":"store_190_Золотодолинская","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_174_Онега","displayName":"store_174_Онега","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_166_Станиславского","displayName":"store_166_Станиславского","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_186_Краснообск","displayName":"store_186_Краснообск","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_193_БердскВокзальная","displayName":"store_193_БердскВокзальная","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_160_Декабристов41","displayName":"store_160_Декабристов41","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_189_Ялта","displayName":"store_189_Ялта","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_211_Симферополь","displayName":"store_211_Симферополь","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"schedule","displayName":"schedule","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"last_run_at_utc","displayName":"last_run_at_utc","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"last_run_at","displayName":"last_run_at","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"last_run_key","displayName":"last_run_key","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"error","displayName":"error","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":false},{"id":"publish_at","displayName":"publish_at","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"row_number","displayName":"row_number","required":false,"defaultMatch":false,"display":true,"type":"number","canBeUsedToMatch":true,"readOnly":true,"removed":false}],"attemptToConvertTypes":false,"convertFieldsToString":false},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[6944,2224],"id":"4f393853-6ac9-436d-b2fe-6b8c5bf7277d","name":"Update row in sheet1","credentials":{"googleSheetsOAuth2Api":{"id":"b5DluHDjTyDAsQWd","name":"Google Sheets account"}}},{"parameters":{},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[3920,2080],"id":"9e196fa1-8e18-4929-b100-244ea48ed062","name":"Merge1"},{"parameters":{"rules":{"values":[{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"leftValue":"={{$json.tg_op}}","rightValue":"message","operator":{"type":"string","operation":"equals"},"id":"a889ad03-e512-413d-afc6-cb13b4d06e20"}],"combinator":"and"},"renameOutput":true,"outputKey":"Output 1"},{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"id":"3b373903-657f-4d1c-b292-d7e347a05ecb","leftValue":"={{$json.tg_op}}","rightValue":"photo","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"renameOutput":true,"outputKey":"Output 2"},{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"id":"ec2bd0f8-d963-46e1-b215-dac61c822773","leftValue":"={{$json.tg_op}}","rightValue":"video","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"renameOutput":true,"outputKey":"Output 3"},{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"id":"b0a65edb-b26b-43f5-a746-8ef43cc19e0c","leftValue":"={{$json.tg_op}}","rightValue":"media_group","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"renameOutput":true,"outputKey":"Output 4"}]},"options":{}},"type":"n8n-nodes-base.switch","typeVersion":3.4,"position":[4800,2176],"id":"0cd08b6e-7afe-4a0f-bd00-892229bc070c","name":"Switch"},{"parameters":{"operation":"sendPhoto","chatId":"={{$json.tg_chat_id}}","file":"={{$json.tg_media}}","additionalFields":{"caption":"={{$json.tg_text}}","parse_mode":"={{$json.tg_parse_mode}}"}},"type":"n8n-nodes-base.telegram","typeVersion":1.2,"position":[5136,2224],"id":"0e4f3a69-ada7-42df-a2cb-323936a8d4e0","name":"Send a photo message","webhookId":"34492d88-1440-48ed-a829-05e172507a26","alwaysOutputData":true,"notesInFlow":false,"credentials":{"telegramApi":{"id":"PvtTCKhw5iSNTNjL","name":"Telegram account"}},"onError":"continueRegularOutput"},{"parameters":{"mode":"combine","combineBy":"combineByPosition","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5296,2240],"id":"9c92626d-c533-4c5f-bb84-aa79165573fe","name":"Merge2"},{"parameters":{"operation":"sendVideo","chatId":"={{$json.tg_chat_id}}","file":"={{$json.tg_media}}","additionalFields":{"caption":"={{$json.tg_text}}","parse_mode":"={{$json.tg_parse_mode}}"}},"type":"n8n-nodes-base.telegram","typeVersion":1.2,"position":[5152,2432],"id":"ab32457d-188d-4f3c-bb27-e59a0ff616d5","name":"Send a video","webhookId":"e91b41a6-2e07-48f5-ad91-fdd4872f2b71","credentials":{"telegramApi":{"id":"PvtTCKhw5iSNTNjL","name":"Telegram account"}},"onError":"continueRegularOutput"},{"parameters":{"mode":"combine","combineBy":"combineByPosition","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5312,2448],"id":"06297003-0ed5-4028-9cab-070c1e22b659","name":"Merge3"},{"parameters":{"method":"POST","url":"https://api.telegram.org/bot8207832455:AAGzn7aGpClD91WdqE5Mcx6nhVw8R5tLXCk/sendMediaGroup","sendBody":true,"bodyParameters":{"parameters":[{"name":"chat_id","value":"={{$json.tg_chat_id}}"},{"name":"media","value":"={{$json.tg_media_group_json}}"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[5152,2784],"id":"671ca97a-6937-434f-b197-ba32d2691ecb","name":"HTTP Request","onError":"continueRegularOutput"},{"parameters":{"mode":"combine","combineBy":"combineByPosition","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5296,2784],"id":"8b5fe576-4ad6-4ef1-9534-5701145e20e9","name":"Merge4"},{"parameters":{"numberInputs":4},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5536,2048],"id":"7f0144ff-dffb-42e3-837f-5a7e54eaf3bf","name":"Merge5"},{"parameters":{"documentId":{"__rl":true,"value":"1FyEGxa6JYTJxDrowfgzAzroTM8L3CWCSY1rgI2DK9KQ","mode":"id"},"sheetName":{"__rl":true,"value":"COOP_FACT","mode":"name"},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[3792,1776],"id":"c1abfdda-a464-4648-a18a-20e7c6d4e1b9","name":"GS_CoopFact_GetRows","executeOnce":true,"credentials":{"googleSheetsOAuth2Api":{"id":"b5DluHDjTyDAsQWd","name":"Google Sheets account"}}},{"parameters":{},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[4048,1904],"id":"1113f9ed-5b68-4b8e-b34f-a836ef68ca15","name":"Merge_Facts_Barrier"},{"parameters":{"jsCode":"function regionToTz(region) {\n  if (region === 54) return 'Asia/Novosibirsk';\n  if (region === 82) return 'Europe/Simferopol';\n  return 'Europe/Moscow';\n}\n\nfunction cleanLine(s) {\n  return String(s ?? '')\n    .replace(/[\\uFEFF\\u200B\\u200C\\u200D\\u2060\\u00AD]/g, '')\n    .trim();\n}\n\nfunction formatLocalHuman(utcDate, tz) {\n  const dtf = new Intl.DateTimeFormat('en-CA', {\n    timeZone: tz,\n    hour12: false,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n  });\n\n  const parts = dtf.formatToParts(utcDate);\n  const map = {};\n  for (const p of parts) if (p.type !== 'literal') map[p.type] = p.value;\n\n  // пробел вместо T — людям проще\n  return `${map.year}-${map.month}-${map.day} ${map.hour}:${map.minute}:${map.second} (${tz})`;\n}\n\n// FIX: принимаем 1-2 цифры для часа (и для minutes/seconds тоже позволим 1-2 на всякий случай)\nfunction parseLocal(value) {\n  const s = cleanLine(value);\n  if (!s) return null;\n\n  // 0) YYYYMMDDTHHMMSS или YYYYMMDDTHHMM\n  let m = s.match(/^(\\d{4})(\\d{2})(\\d{2})T(\\d{1,2})(\\d{1,2})(\\d{1,2})?$/);\n  if (m) {\n    const [_, Y, M, D, h, min, sec] = m;\n    const hh = Number(h);\n    const mm = Number(min);\n    const ss = sec ? Number(sec) : 0;\n    if (!Number.isFinite(hh) || !Number.isFinite(mm) || !Number.isFinite(ss)) return null;\n    if (hh < 0 || hh > 23 || mm < 0 || mm > 59 || ss < 0 || ss > 59) return null;\n    return { Y: +Y, M: +M, D: +D, h: hh, min: mm, s: ss };\n  }\n\n  // 1) YYYY-MM-DD HH:mm(:ss)\n  m = s.match(/^(\\d{4})-(\\d{2})-(\\d{2})[ T](\\d{1,2}):(\\d{1,2})(?::(\\d{1,2}))?$/);\n  if (m) {\n    const [_, Y, M, D, h, min, sec] = m;\n    const hh = Number(h);\n    const mm = Number(min);\n    const ss = sec ? Number(sec) : 0;\n    if (!Number.isFinite(hh) || !Number.isFinite(mm) || !Number.isFinite(ss)) return null;\n    if (hh < 0 || hh > 23 || mm < 0 || mm > 59 || ss < 0 || ss > 59) return null;\n    return { Y: +Y, M: +M, D: +D, h: hh, min: mm, s: ss };\n  }\n\n  // 2) DD.MM.YYYY HH:mm(:ss)\n  m = s.match(/^(\\d{2})\\.(\\d{2})\\.(\\d{4})[ T](\\d{1,2}):(\\d{1,2})(?::(\\d{1,2}))?$/);\n  if (m) {\n    const [_, D, M, Y, h, min, sec] = m;\n    const hh = Number(h);\n    const mm = Number(min);\n    const ss = sec ? Number(sec) : 0;\n    if (!Number.isFinite(hh) || !Number.isFinite(mm) || !Number.isFinite(ss)) return null;\n    if (hh < 0 || hh > 23 || mm < 0 || mm > 59 || ss < 0 || ss > 59) return null;\n    return { Y: +Y, M: +M, D: +D, h: hh, min: mm, s: ss };\n  }\n\n  return null;\n}\n\nfunction isIsoLike(value) {\n  const s = cleanLine(value);\n  return /T/.test(s) || /Z$/.test(s) || /[+-]\\d{2}:\\d{2}$/.test(s);\n}\n\nfunction tzOffsetMinutesAt(utcDate, timeZone) {\n  const dtf = new Intl.DateTimeFormat('en-US', {\n    timeZone,\n    hour12: false,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n  });\n\n  const parts = dtf.formatToParts(utcDate);\n  const map = {};\n  for (const p of parts) if (p.type !== 'literal') map[p.type] = p.value;\n\n  const asIfUtc = Date.UTC(\n    Number(map.year),\n    Number(map.month) - 1,\n    Number(map.day),\n    Number(map.hour),\n    Number(map.minute),\n    Number(map.second),\n  );\n\n  const offsetMs = asIfUtc - utcDate.getTime();\n  return Math.round(offsetMs / 60000);\n}\n\nfunction dateFromLocalInTz(local, timeZone) {\n  const approxUtc = new Date(Date.UTC(local.Y, local.M - 1, local.D, local.h, local.min, local.s, 0));\n\n  const offsetMin1 = tzOffsetMinutesAt(approxUtc, timeZone);\n\n  let utcMs = approxUtc.getTime() - offsetMin1 * 60000;\n  let utcDate = new Date(utcMs);\n\n  const offsetMin2 = tzOffsetMinutesAt(utcDate, timeZone);\n  if (offsetMin2 !== offsetMin1) {\n    utcMs = approxUtc.getTime() - offsetMin2 * 60000;\n    utcDate = new Date(utcMs);\n  }\n\n  return utcDate;\n}\n\nfunction parseDateTimeByTz(value, timeZone) {\n  const v = cleanLine(value);\n  if (!v) return null;\n\n  // ISO со смещением/UTC — парсим напрямую\n  if (isIsoLike(v)) {\n    const iso = Date.parse(v);\n    return Number.isNaN(iso) ? null : new Date(iso);\n  }\n\n  // Иначе — локальное время TZ\n  const local = parseLocal(v);\n  if (!local) return null;\n\n  return dateFromLocalInTz(local, timeZone);\n}\n\nfunction parseDateTimeByRegion(value, region) {\n  const tz = regionToTz(region);\n  return parseDateTimeByTz(value, tz);\n}\n\n// ---------------- schedule mini DSL ----------------\n\n/**\n * IMPORTANT FIX:\n * Раньше мы \"расщепляли\" весь schedule по ';', из-за чего RRULE разваливался,\n * и BYDAY часто терялся (становился null).\n *\n * Теперь:\n * - НИКОГДА не делим весь текст по ';'\n * - Ищем строки DTSTART / RRULE / TZ / UNTIL по всему тексту\n * - ';' используем только внутри rruleRaw (rruleRaw.split(';'))\n */\nfunction parseSchedule(scheduleText) {\n  const raw0 = (scheduleText ?? '').toString();\n  const raw = raw0.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n  if (!cleanLine(raw)) return { ok: false, error: 'schedule empty' };\n\n  const findVal = (key) => {\n    const re = new RegExp(`(?:^|\\\\n)\\\\s*${key}(?:;[^:=]*)?\\\\s*[:=]\\\\s*(.+?)\\\\s*(?=\\\\n|$)`, 'i');\n    const m = raw.match(re);\n    return m ? cleanLine(m[1]) : null;\n  };\n\n  const tz = findVal('TZ');\n  const dtstartRaw = findVal('DTSTART');\n  const rruleRaw = findVal('RRULE');\n  const untilRaw = findVal('UNTIL');\n\n  if (!dtstartRaw) return { ok: false, error: 'DTSTART missing' };\n  if (!rruleRaw) return { ok: false, error: 'RRULE missing' };\n\n  const props = {};\n  for (const part0 of rruleRaw.split(';')) {\n    const part = cleanLine(part0);\n    if (!part) continue;\n\n    const eq = part.indexOf('=');\n    if (eq <= 0) continue;\n\n    const k = cleanLine(part.slice(0, eq)).toUpperCase();\n    const v = cleanLine(part.slice(eq + 1));\n    if (!k || v == null) continue;\n\n    props[k] = v;\n  }\n\n  const freq = (props.FREQ || '').toUpperCase();\n  if (!['DAILY', 'WEEKLY', 'MONTHLY'].includes(freq)) {\n    return { ok: false, error: `Unsupported FREQ=${props.FREQ || ''}` };\n  }\n\n  const interval = props.INTERVAL ? Math.max(1, Number(props.INTERVAL)) : 1;\n  const count = props.COUNT ? Math.max(1, Number(props.COUNT)) : null;\n  const untilStr = props.UNTIL || untilRaw || null;\n\n  const byday = props.BYDAY\n    ? props.BYDAY.split(',').map(s => cleanLine(s).toUpperCase()).filter(Boolean)\n    : null;\n\n  const byhour = props.BYHOUR != null\n    ? props.BYHOUR.split(',').map(x => Number(cleanLine(x)))\n    : null;\n\n  const byminute = props.BYMINUTE != null\n    ? props.BYMINUTE.split(',').map(x => Number(cleanLine(x)))\n    : null;\n\n  return { ok: true, tz, dtstartRaw, freq, interval, count, untilStr, byday, byhour, byminute, raw: { rruleRaw, scheduleRaw: raw } };\n}\n\nfunction formatPartsYMDInTz(utcDate, tz) {\n  const parts = new Intl.DateTimeFormat('en-US', {\n    timeZone: tz,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n  }).formatToParts(utcDate);\n\n  const map = {};\n  for (const p of parts) if (p.type !== 'literal') map[p.type] = p.value;\n\n  return { y: Number(map.year), m: Number(map.month), d: Number(map.day) };\n}\n\nfunction localYmdHmsToUtc(y, m, d, hh, mm, ss, tz) {\n  return dateFromLocalInTz({ Y: y, M: m, D: d, h: hh, min: mm, s: ss }, tz);\n}\n\nfunction addDaysUtc(date, days) {\n  return new Date(date.getTime() + days * 86400000);\n}\n\nfunction addWeeksUtc(date, weeks) {\n  return addDaysUtc(date, weeks * 7);\n}\n\nfunction addMonthsUtc(date, months) {\n  const y = date.getUTCFullYear();\n  const m = date.getUTCMonth();\n  const d = date.getUTCDate();\n  const hh = date.getUTCHours();\n  const mm = date.getUTCMinutes();\n  const ss = date.getUTCSeconds();\n\n  const targetMonthIndex = m + months;\n  const targetY = y + Math.floor(targetMonthIndex / 12);\n  const targetM = ((targetMonthIndex % 12) + 12) % 12;\n\n  const lastDay = new Date(Date.UTC(targetY, targetM + 1, 0)).getUTCDate();\n  const clampedD = Math.min(d, lastDay);\n\n  return new Date(Date.UTC(targetY, targetM, clampedD, hh, mm, ss));\n}\n\nfunction makeRunKeyLocal(postId, tz, occurrenceUtc) {\n  const id = (postId ?? 'unknown').toString();\n  const local = new Intl.DateTimeFormat('en-CA', {\n    timeZone: tz,\n    hour12: false,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n  }).format(occurrenceUtc).replace(', ', ' ');\n  return `post:${id}|${tz}|${local}`;\n}\n\n/**\n * Stable weekday for a LOCAL date (y,m,d) in timezone tz.\n * We convert local noon to UTC and then format weekday in tz.\n * Noon avoids boundary issues around midnight and DST.\n * Returns two-letter codes: MO,TU,WE,TH,FR,SA,SU.\n */\nfunction weekdayFromLocalYmd(y, m, d, tz) {\n  const probeUtc = localYmdHmsToUtc(y, m, d, 12, 0, 0, tz);\n  const w = new Intl.DateTimeFormat('en-US', { timeZone: tz, weekday: 'short' })\n    .format(probeUtc)\n    .slice(0, 2)\n    .toUpperCase();\n  return w;\n}\n\nfunction findLastOccurrenceUtc({ tz, dtstartUtc, dtstartLocalParts, rule, untilUtc, nowUtc }) {\n  let windowStartUtc;\n  if (rule.freq === 'DAILY') windowStartUtc = new Date(nowUtc.getTime() - 40 * 86400000);\n  else if (rule.freq === 'WEEKLY') windowStartUtc = new Date(nowUtc.getTime() - 26 * 7 * 86400000);\n  else windowStartUtc = new Date(nowUtc.getTime() - 24 * 31 * 86400000);\n\n  if (windowStartUtc < dtstartUtc) windowStartUtc = dtstartUtc;\n  const windowEndUtc = nowUtc;\n\n  const defaultH = dtstartLocalParts.h;\n  const defaultM = dtstartLocalParts.min;\n  const defaultS = dtstartLocalParts.s;\n\n  const hours = rule.byhour && rule.byhour.length ? rule.byhour : [defaultH];\n  const minutes = rule.byminute && rule.byminute.length ? rule.byminute : [defaultM];\n\n  let last = null;\n  let produced = 0;\n  const maxProduced = 5000;\n\n  if (rule.freq === 'DAILY') {\n    let cursor = new Date(Date.UTC(\n      windowStartUtc.getUTCFullYear(),\n      windowStartUtc.getUTCMonth(),\n      windowStartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    const dt0 = new Date(Date.UTC(\n      dtstartUtc.getUTCFullYear(),\n      dtstartUtc.getUTCMonth(),\n      dtstartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    let diffDays = Math.floor((cursor.getTime() - dt0.getTime()) / 86400000);\n    if (diffDays < 0) diffDays = 0;\n    const mod = diffDays % rule.interval;\n    if (mod !== 0) cursor = addDaysUtc(cursor, rule.interval - mod);\n\n    while (cursor <= windowEndUtc && produced < maxProduced) {\n      const ymd = formatPartsYMDInTz(cursor, tz);\n\n      if (rule.byday && rule.byday.length) {\n        const localWday = weekdayFromLocalYmd(ymd.y, ymd.m, ymd.d, tz);\n        if (!rule.byday.includes(localWday)) {\n          cursor = addDaysUtc(cursor, rule.interval);\n          continue;\n        }\n      }\n\n      for (const hh of hours) {\n        for (const mm of minutes) {\n          const occUtc = localYmdHmsToUtc(ymd.y, ymd.m, ymd.d, hh, mm, defaultS, tz);\n          if (occUtc < dtstartUtc) continue;\n          if (untilUtc && occUtc > untilUtc) continue;\n          if (occUtc < windowStartUtc || occUtc > windowEndUtc) continue;\n\n          produced++;\n          if (rule.count && produced > rule.count) return last;\n\n          if (!last || occUtc > last) last = occUtc;\n          if (produced >= maxProduced) break;\n        }\n        if (produced >= maxProduced) break;\n      }\n\n      cursor = addDaysUtc(cursor, rule.interval);\n    }\n  }\n\n  if (rule.freq === 'WEEKLY') {\n    const dtLocalWday = weekdayFromLocalYmd(dtstartLocalParts.Y, dtstartLocalParts.M, dtstartLocalParts.D, tz);\n    const days = (rule.byday && rule.byday.length) ? rule.byday : [dtLocalWday];\n\n    let cursorWeekStart = new Date(Date.UTC(\n      windowStartUtc.getUTCFullYear(),\n      windowStartUtc.getUTCMonth(),\n      windowStartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    const dt0 = new Date(Date.UTC(\n      dtstartUtc.getUTCFullYear(),\n      dtstartUtc.getUTCMonth(),\n      dtstartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    let diffDays = Math.floor((cursorWeekStart.getTime() - dt0.getTime()) / 86400000);\n    if (diffDays < 0) diffDays = 0;\n    const diffWeeks = Math.floor(diffDays / 7);\n    const mod = diffWeeks % rule.interval;\n    if (mod !== 0) cursorWeekStart = addWeeksUtc(cursorWeekStart, rule.interval - mod);\n\n    while (cursorWeekStart <= windowEndUtc && produced < maxProduced) {\n      for (let i = 0; i < 7; i++) {\n        const dayUtc = addDaysUtc(cursorWeekStart, i);\n        const ymd = formatPartsYMDInTz(dayUtc, tz);\n        const localWday = weekdayFromLocalYmd(ymd.y, ymd.m, ymd.d, tz);\n\n        if (!days.includes(localWday)) continue;\n\n        for (const hh of hours) {\n          for (const mm of minutes) {\n            const occUtc = localYmdHmsToUtc(ymd.y, ymd.m, ymd.d, hh, mm, defaultS, tz);\n            if (occUtc < dtstartUtc) continue;\n            if (untilUtc && occUtc > untilUtc) continue;\n            if (occUtc < windowStartUtc || occUtc > windowEndUtc) continue;\n\n            produced++;\n            if (rule.count && produced > rule.count) return last;\n\n            if (!last || occUtc > last) last = occUtc;\n            if (produced >= maxProduced) break;\n          }\n          if (produced >= maxProduced) break;\n        }\n      }\n\n      cursorWeekStart = addWeeksUtc(cursorWeekStart, rule.interval);\n    }\n  }\n\n  if (rule.freq === 'MONTHLY') {\n    let cursor = dtstartUtc;\n    let iterations = 0;\n    const maxIter = 300;\n\n    while (cursor < windowStartUtc && iterations < maxIter) {\n      cursor = addMonthsUtc(cursor, rule.interval);\n      iterations++;\n    }\n\n    while (cursor <= windowEndUtc && iterations < maxIter && produced < maxProduced) {\n      const ymd = formatPartsYMDInTz(cursor, tz);\n\n      for (const hh of hours) {\n        for (const mm of minutes) {\n          const occUtc = localYmdHmsToUtc(ymd.y, ymd.m, ymd.d, hh, mm, defaultS, tz);\n          if (occUtc < dtstartUtc) continue;\n          if (untilUtc && occUtc > untilUtc) continue;\n          if (occUtc < windowStartUtc || occUtc > windowEndUtc) continue;\n\n          produced++;\n          if (rule.count && produced > rule.count) return last;\n\n          if (!last || occUtc > last) last = occUtc;\n          if (produced >= maxProduced) break;\n        }\n        if (produced >= maxProduced) break;\n      }\n\n      cursor = addMonthsUtc(cursor, rule.interval);\n      iterations++;\n    }\n  }\n\n  return last;\n}\n\n// NEW: find next occurrence strictly after nowUtc\nfunction findNextOccurrenceUtc({ tz, dtstartUtc, dtstartLocalParts, rule, untilUtc, nowUtc }) {\n  const windowStartUtc = nowUtc;\n  let windowEndUtc;\n  if (rule.freq === 'DAILY') windowEndUtc = new Date(nowUtc.getTime() + 60 * 86400000);\n  else if (rule.freq === 'WEEKLY') windowEndUtc = new Date(nowUtc.getTime() + 60 * 7 * 86400000);\n  else windowEndUtc = new Date(nowUtc.getTime() + 24 * 31 * 86400000);\n\n  if (untilUtc && untilUtc < windowEndUtc) windowEndUtc = untilUtc;\n\n  const defaultH = dtstartLocalParts.h;\n  const defaultM = dtstartLocalParts.min;\n  const defaultS = dtstartLocalParts.s;\n\n  const hours = rule.byhour && rule.byhour.length ? rule.byhour : [defaultH];\n  const minutes = rule.byminute && rule.byminute.length ? rule.byminute : [defaultM];\n\n  let best = null;\n  let produced = 0;\n  const maxProduced = 5000;\n\n  if (rule.freq === 'DAILY') {\n    let cursor = new Date(Date.UTC(\n      windowStartUtc.getUTCFullYear(),\n      windowStartUtc.getUTCMonth(),\n      windowStartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    const dt0 = new Date(Date.UTC(\n      dtstartUtc.getUTCFullYear(),\n      dtstartUtc.getUTCMonth(),\n      dtstartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    let diffDays = Math.floor((cursor.getTime() - dt0.getTime()) / 86400000);\n    if (diffDays < 0) diffDays = 0;\n    const mod = diffDays % rule.interval;\n    if (mod !== 0) cursor = addDaysUtc(cursor, rule.interval - mod);\n\n    while (cursor <= windowEndUtc && produced < maxProduced) {\n      const ymd = formatPartsYMDInTz(cursor, tz);\n\n      if (rule.byday && rule.byday.length) {\n        const localWday = weekdayFromLocalYmd(ymd.y, ymd.m, ymd.d, tz);\n        if (!rule.byday.includes(localWday)) {\n          cursor = addDaysUtc(cursor, rule.interval);\n          continue;\n        }\n      }\n\n      for (const hh of hours) {\n        for (const mm of minutes) {\n          const occUtc = localYmdHmsToUtc(ymd.y, ymd.m, ymd.d, hh, mm, defaultS, tz);\n          if (occUtc < dtstartUtc) continue;\n          if (untilUtc && occUtc > untilUtc) continue;\n          if (occUtc <= windowStartUtc) continue;\n          if (occUtc > windowEndUtc) continue;\n\n          produced++;\n          if (rule.count && produced > rule.count) return best;\n\n          if (!best || occUtc < best) best = occUtc;\n          if (best) return best;\n        }\n      }\n\n      cursor = addDaysUtc(cursor, rule.interval);\n    }\n  }\n\n  if (rule.freq === 'WEEKLY') {\n    const dtLocalWday = weekdayFromLocalYmd(dtstartLocalParts.Y, dtstartLocalParts.M, dtstartLocalParts.D, tz);\n    const days = (rule.byday && rule.byday.length) ? rule.byday : [dtLocalWday];\n\n    let cursorWeekStart = new Date(Date.UTC(\n      windowStartUtc.getUTCFullYear(),\n      windowStartUtc.getUTCMonth(),\n      windowStartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    const dt0 = new Date(Date.UTC(\n      dtstartUtc.getUTCFullYear(),\n      dtstartUtc.getUTCMonth(),\n      dtstartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    let diffDays = Math.floor((cursorWeekStart.getTime() - dt0.getTime()) / 86400000);\n    if (diffDays < 0) diffDays = 0;\n    const diffWeeks = Math.floor(diffDays / 7);\n    const mod = diffWeeks % rule.interval;\n    if (mod !== 0) cursorWeekStart = addWeeksUtc(cursorWeekStart, rule.interval - mod);\n\n    while (cursorWeekStart <= windowEndUtc && produced < maxProduced) {\n      for (let i = 0; i < 7; i++) {\n        const dayUtc = addDaysUtc(cursorWeekStart, i);\n        const ymd = formatPartsYMDInTz(dayUtc, tz);\n        const localWday = weekdayFromLocalYmd(ymd.y, ymd.m, ymd.d, tz);\n\n        if (!days.includes(localWday)) continue;\n\n        for (const hh of hours) {\n          for (const mm of minutes) {\n            const occUtc = localYmdHmsToUtc(ymd.y, ymd.m, ymd.d, hh, mm, defaultS, tz);\n            if (occUtc < dtstartUtc) continue;\n            if (untilUtc && occUtc > untilUtc) continue;\n            if (occUtc <= windowStartUtc) continue;\n            if (occUtc > windowEndUtc) continue;\n\n            produced++;\n            if (rule.count && produced > rule.count) return best;\n\n            if (!best || occUtc < best) best = occUtc;\n            if (best) return best;\n          }\n        }\n      }\n\n      cursorWeekStart = addWeeksUtc(cursorWeekStart, rule.interval);\n    }\n  }\n\n  if (rule.freq === 'MONTHLY') {\n    let cursor = dtstartUtc;\n    let iterations = 0;\n    const maxIter = 300;\n\n    while (cursor <= windowStartUtc && iterations < maxIter) {\n      cursor = addMonthsUtc(cursor, rule.interval);\n      iterations++;\n    }\n\n    while (cursor <= windowEndUtc && iterations < maxIter && produced < maxProduced) {\n      const ymd = formatPartsYMDInTz(cursor, tz);\n\n      for (const hh of hours) {\n        for (const mm of minutes) {\n          const occUtc = localYmdHmsToUtc(ymd.y, ymd.m, ymd.d, hh, mm, defaultS, tz);\n          if (occUtc < dtstartUtc) continue;\n          if (untilUtc && occUtc > untilUtc) continue;\n          if (occUtc <= windowStartUtc) continue;\n          if (occUtc > windowEndUtc) continue;\n\n          produced++;\n          if (rule.count && produced > rule.count) return best;\n\n          if (!best || occUtc < best) best = occUtc;\n          if (best) return best;\n        }\n      }\n\n      cursor = addMonthsUtc(cursor, rule.interval);\n      iterations++;\n    }\n  }\n\n  return best;\n}\n\n// ---------------- main ----------------\n\nconst items = $input.all();\nconst nowUtc = new Date();\n\nreturn items.map(item => {\n  const p = item.json;\n\n  const tzRegion = regionToTz(p.region);\n\n  let due = false;\n  let reason = null;\n\n  // наружные поля\n  const nowLocal = formatLocalHuman(nowUtc, tzRegion);\n\n  let publishUtc = null;\n  let publishLocal = null;\n\n  let occurrenceUtc = null;\n  let occurrenceLocal = null;\n\n  let runKey = null;\n  let scheduleParsed = null;\n\n  // NEW plan\n  let planRunUtc = null;\n  let planRunLocal = null;\n\n  if (p.post_type === 2) {\n    publishUtc = parseDateTimeByRegion(p.publish_at, p.region);\n    publishLocal = publishUtc ? formatLocalHuman(publishUtc, tzRegion) : null;\n\n    if (!publishUtc) {\n      reason = 'one-time post without valid publish_at';\n    } else {\n      // для разового поста occurrence = publish_at\n      occurrenceUtc = publishUtc;\n      occurrenceLocal = formatLocalHuman(occurrenceUtc, tzRegion);\n\n      // формируем ключ заранее (антидубль как у регулярных)\n      runKey = makeRunKeyLocal(p.id, tzRegion, occurrenceUtc);\n\n      const alreadyKey = (p.last_run_key ?? '').toString().trim();\n      if (alreadyKey === runKey) {\n        due = false;\n        reason = 'one-time: already executed (last_run_key match)';\n      } else {\n        // запасной стопор по last_run_at_utc (если ключ почему-то не писался)\n        const lastRunAtUtc = p.last_run_at_utc ? new Date(p.last_run_at_utc) : null;\n        if (lastRunAtUtc && !isNaN(lastRunAtUtc.getTime())) {\n          if (lastRunAtUtc.getTime() >= occurrenceUtc.getTime() - 30 * 1000) {\n            due = false;\n            reason = 'one-time: already executed (last_run_at_utc >= publish_at)';\n          } else if (publishUtc <= nowUtc) {\n            due = true;\n            reason = 'due now (publish_at <= now) in region tz';\n          } else {\n            due = false;\n            reason = 'not yet (publish_at in future) in region tz';\n          }\n        } else {\n          if (publishUtc <= nowUtc) {\n            due = true;\n            reason = 'due now (publish_at <= now) in region tz';\n          } else {\n            due = false;\n            reason = 'not yet (publish_at in future) in region tz';\n          }\n        }\n      }\n    }\n  } else if (p.post_type === 1) {\n    if (!p.schedule) {\n      reason = 'regular post without schedule';\n    } else {\n      const parsed = parseSchedule(p.schedule);\n      if (!parsed.ok) {\n        reason = `schedule parse error: ${parsed.error}`;\n      } else {\n        const tz = parsed.tz || tzRegion;\n\n        const dtstartLocal = parseLocal(parsed.dtstartRaw);\n        if (!dtstartLocal) {\n          reason = 'DTSTART parse error';\n        } else {\n          const dtstartUtc = dateFromLocalInTz(dtstartLocal, tz);\n\n          let untilUtc = null;\n          if (parsed.untilStr) {\n            const u = parseDateTimeByTz(parsed.untilStr, tz);\n            if (!u) reason = 'UNTIL parse error';\n            else untilUtc = u;\n          }\n\n          if (!reason) {\n            const rule = {\n              freq: parsed.freq,\n              interval: parsed.interval,\n              count: parsed.count,\n              byday: parsed.byday,\n              byhour: parsed.byhour,\n              byminute: parsed.byminute,\n            };\n\n            scheduleParsed = {\n              tz,\n              dtstart_local: parsed.dtstartRaw,\n              dtstart_utc: dtstartUtc.toISOString(),\n              rule,\n              until_utc: untilUtc ? untilUtc.toISOString() : null,\n              raw: parsed.raw, // чтобы видеть rruleRaw/scheduleRaw в дебаге\n            };\n\n            const lastOcc = findLastOccurrenceUtc({\n              tz,\n              dtstartUtc,\n              dtstartLocalParts: dtstartLocal,\n              rule,\n              untilUtc,\n              nowUtc,\n            });\n\n            const nextOcc = findNextOccurrenceUtc({\n              tz,\n              dtstartUtc,\n              dtstartLocalParts: dtstartLocal,\n              rule,\n              untilUtc,\n              nowUtc,\n            });\n\n            if (nextOcc) {\n              planRunUtc = nextOcc;\n              planRunLocal = formatLocalHuman(nextOcc, tz);\n            } else {\n              planRunUtc = null;\n              planRunLocal = null;\n            }\n\n            if (!lastOcc) {\n              // FIX: корректная причина, когда DTSTART ещё не наступил (в будущем)\n              if (dtstartUtc > nowUtc) {\n                due = false;\n                reason = 'recurring: not yet started (DTSTART in future)';\n              } else {\n                // если DTSTART уже был в прошлом, но в lookback ничего не нашли\n                due = false;\n                reason = 'recurring: no occurrence found in lookback window';\n              }\n            } else {\n              occurrenceUtc = lastOcc;\n              occurrenceLocal = formatLocalHuman(occurrenceUtc, tz);\n              runKey = makeRunKeyLocal(p.id, tz, occurrenceUtc);\n\n              const alreadyKey = (p.last_run_key ?? '').toString().trim();\n              if (alreadyKey === runKey) {\n                due = false;\n                reason = 'recurring: already executed (last_run_key match)';\n              } else {\n                // secondary: last_run_at_utc (надежно парсится)\n                const lastRunAtUtc = p.last_run_at_utc ? new Date(p.last_run_at_utc) : null;\n                if (lastRunAtUtc && !isNaN(lastRunAtUtc.getTime())) {\n                  if (lastRunAtUtc.getTime() >= occurrenceUtc.getTime() - 30 * 1000) {\n                    due = false;\n                    reason = 'recurring: already executed (last_run_at_utc >= occurrence)';\n                  } else {\n                    due = true;\n                    reason = 'recurring: occurrence <= now and not executed';\n                  }\n                } else {\n                  due = true;\n                  reason = 'recurring: occurrence <= now and not executed';\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } else {\n    reason = 'unknown post_type';\n  }\n\n  return {\n    json: {\n      ...p,\n      _due: due,\n      _due_reason: reason,\n\n      // локальное отображение\n      _now: nowLocal,\n      _publish_at_parsed: publishLocal,\n      _occurrence_local: occurrenceLocal,\n\n      // UTC техничка (для записи)\n      _now_utc: nowUtc.toISOString(),\n      _occurrence_utc: occurrenceUtc ? occurrenceUtc.toISOString() : null,\n\n      _run_key: runKey,\n      _schedule_parsed: scheduleParsed,\n\n      // NEW: next planned run (for regular posts)\n      _plan_run_at: planRunLocal,\n      _plan_run_at_utc: planRunUtc ? planRunUtc.toISOString() : null,\n    },\n  };\n});\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[3440,2064],"id":"da9dc91f-4454-4b2c-abae-e8081ffea5dd","name":"Determine due"},{"parameters":{"rule":{"interval":[{"field":"minutes"}]}},"type":"n8n-nodes-base.scheduleTrigger","typeVersion":1.3,"position":[2480,2288],"id":"54277a7a-f068-4c15-8955-a83466390e99","name":"Schedule Trigger"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"loose","version":3},"conditions":[{"id":"d7859595-c40c-40cf-9885-a94c7a7296ba","leftValue":"={{$json.send_vk}}","rightValue":"true","operator":{"type":"boolean","operation":"true","singleValue":true}}],"combinator":"and"},"looseTypeValidation":true,"options":{}},"type":"n8n-nodes-base.filter","typeVersion":2.3,"position":[4448,1504],"id":"48ae628c-a97f-4dbf-905f-c17f7c0d4022","name":"Filter VK"},{"parameters":{"method":"POST","url":"https://api.vk.com/method/wall.post","sendBody":true,"contentType":"form-urlencoded","bodyParameters":{"parameters":[{"name":"owner_id","value":"=-114286850"},{"name":"from_group","value":"1"},{"name":"message","value":"={{$json.vk_message}}"},{"name":"access_token","value":"vk1.a.9nMQFYamjyb6V0wTTCDK_pi4ehFyFKa5c3ZLsizknn-4Vl0blAibzoQIy04vhvKoUmbOhVu7sKox2btvhT0ltZFsd5k97BjMGmlxSqb5YZnHc-_S6HN-o2XlkZQcM5lh5jmYRLupjGqKo2KfrO0EGLxgdEJrK6OeEp4NRcN0wDqVlWuAfUCGFZnBPUNbbbDq7kWuvJ4BmoLzbP8ZRzEHYQ"},{"name":"v","value":"5.131"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[5008,1392],"id":"23327244-ec97-41ef-b383-e2e0bb6349fd","name":"VK wall.post","onError":"continueRegularOutput"},{"parameters":{"jsCode":"/**\n * Collect VK results per post_id (after Merge Combine/Position)\n *\n * Supports VK API responses from HTTP Request node (wall.post), which typically return:\n *  - Success: { response: { post_id: 123, ... } }\n *  - Error:   { error: { error_code: 214, error_msg: \"...\", error_text: \"...\", request_params: [...] } }\n *\n * But n8n can wrap HTTP responses as:\n *  - { statusCode: 200, body: { response:{...} } }  (when Response Format = JSON)\n *  - { statusCode: 200, body: \"...\" }              (string)\n *  - errors in p.error / p.message / p.response / p.body\n *\n * Output: one item per post_id with aggregation + Sheets update-like fields\n * (Note: do NOT write last_run_* here if you plan to require TG+VK together;\n *        you can still output vk_ok/vk_fail counts and update_error here.)\n */\n\nconst items = $input.all();\n\nfunction safeStr(v) {\n  if (v === null || v === undefined) return '';\n  return String(v);\n}\n\nfunction toNumOrNull(v) {\n  if (v === null || v === undefined || v === '') return null;\n  const n = Number(v);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction appendLog(existing, line) {\n  const base = (existing ?? '').toString().trim();\n  if (!base) return line;\n  return base + '\\n' + line;\n}\n\nfunction tryJsonParse(s) {\n  try {\n    return JSON.parse(s);\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction unwrapBody(p) {\n  // n8n HTTP Request may expose body at top-level or nested\n  const body = p?.body ?? p?.response?.body ?? p?.responseBody ?? null;\n\n  if (body && typeof body === 'object') return body;\n\n  if (typeof body === 'string') {\n    const j = tryJsonParse(body);\n    if (j && typeof j === 'object') return j;\n  }\n\n  // Sometimes response itself is the VK json\n  if (p && typeof p === 'object') {\n    if (p.response && typeof p.response === 'object') return p.response;\n    // if p has response/error at top-level, return p itself\n    if (p.response || p.error) return p;\n  }\n\n  return null;\n}\n\nfunction detectOk(p) {\n  if (!p) return false;\n\n  // Direct VK shape\n  if (p.response && typeof p.response === 'object' && (p.response.post_id || p.response.post_id === 0)) {\n    return true;\n  }\n\n  const b = unwrapBody(p);\n  if (b) {\n    if (b.response && typeof b.response === 'object' && (b.response.post_id || b.response.post_id === 0)) {\n      return true;\n    }\n    // VK sometimes returns \"response\": 1 for some methods, but wall.post should return object\n    if (typeof b.response === 'number' && b.response > 0) return true;\n  }\n\n  // Fallback: if statusCode is 2xx but VK error not visible, treat as ok (avoid false FAIL)\n  const sc = p.statusCode ?? p.status ?? p.response?.statusCode ?? null;\n  if (typeof sc === 'number' && sc >= 200 && sc < 300) {\n    const bb = b;\n    if (bb && bb.error) return false;\n    return true;\n  }\n\n  return false;\n}\n\nfunction extractErrorText(p) {\n  if (!p) return 'unknown error';\n\n  // n8n error object\n  if (typeof p.error === 'string') return p.error;\n  if (p.error?.message) return safeStr(p.error.message);\n  if (p.errorMessage) return safeStr(p.errorMessage);\n  if (p.message) return safeStr(p.message);\n  if (p.description) return safeStr(p.description);\n  if (p.cause) return safeStr(p.cause);\n\n  // VK error shape\n  const b = unwrapBody(p);\n  const errObj = b?.error ?? p?.error ?? null;\n\n  if (errObj && typeof errObj === 'object') {\n    const code = errObj.error_code ?? errObj.code ?? null;\n    const msg = errObj.error_msg ?? errObj.message ?? errObj.error_text ?? null;\n    if (code !== null || msg) {\n      return `vk_error${code !== null ? `#${safeStr(code)}` : ''}: ${safeStr(msg || 'unknown')}`.trim();\n    }\n    try {\n      return JSON.stringify(errObj);\n    } catch (e) {\n      return 'unstringifiable vk error';\n    }\n  }\n\n  // Raw body as string\n  const rawBody = p.body ?? p.response?.body ?? p.responseBody ?? null;\n  if (typeof rawBody === 'string') {\n    const s = rawBody.trim();\n    if (s) return s.slice(0, 500);\n  }\n\n  // Last resort\n  try {\n    return JSON.stringify(p).slice(0, 500);\n  } catch (e) {\n    return 'unknown error';\n  }\n}\n\nfunction extractVkPostId(p) {\n  const b = unwrapBody(p);\n  const direct = p?.response?.post_id ?? null;\n  if (direct !== null && direct !== undefined) return direct;\n\n  const pid = b?.response?.post_id ?? null;\n  if (pid !== null && pid !== undefined) return pid;\n\n  return null;\n}\n\n// group per post_id\nconst byPost = new Map();\n\nfor (const item of items) {\n  const p = item.json || {};\n\n  const postId = p.post_id ?? p.id ?? null;\n  if (!postId) continue;\n\n  if (!byPost.has(postId)) {\n    byPost.set(postId, {\n      post_id: postId,\n      row_number: toNumOrNull(p.row_number),\n\n      last_run_key: p._run_key ?? null,\n      now_utc: p._now_utc ?? new Date().toISOString(),\n      now_local: p._now ?? null,\n\n      plan_run_at: p._plan_run_at ?? null,\n      prev_error: p.error_prev ?? null,\n\n      total: 0,\n      ok: 0,\n      fail: 0,\n      fails: [],\n      vk_post_ids: [],\n    });\n  }\n\n  const agg = byPost.get(postId);\n\n  if (!agg.plan_run_at && p._plan_run_at) agg.plan_run_at = p._plan_run_at;\n\n  agg.total += 1;\n\n  const ok = detectOk(p);\n\n  if (ok) {\n    agg.ok += 1;\n    const vkPid = extractVkPostId(p);\n    if (vkPid !== null && vkPid !== undefined) agg.vk_post_ids.push(vkPid);\n  } else {\n    agg.fail += 1;\n    const desc = extractErrorText(p);\n    agg.fails.push({ desc: safeStr(desc) });\n  }\n}\n\nconst out = [];\n\nfor (const agg of byPost.values()) {\n  // success only if at least one ok and no fails\n  const allOk = agg.fail === 0 && agg.ok > 0;\n\n  let newError = agg.prev_error;\n\n  if (allOk) {\n    const vkInfo = agg.vk_post_ids.length ? ` vk_post_id=${safeStr(agg.vk_post_ids[0])}` : '';\n    newError = appendLog(\n      newError,\n      `[OK VK] ${agg.now_utc} key=${safeStr(agg.last_run_key)} sent=${agg.ok}/${agg.total}${vkInfo}`\n    );\n  } else {\n    const failLines = agg.fails\n      .slice(0, 20)\n      .map(f => `err=${safeStr(f.desc)}`)\n      .join(' | ');\n\n    newError = appendLog(\n      newError,\n      `[FAIL VK] ${agg.now_utc} key=${safeStr(agg.last_run_key)} ok=${agg.ok}/${agg.total} fails=${agg.fail}` +\n        (failLines ? ` :: ${failLines}` : '')\n    );\n  }\n\n  out.push({\n    json: {\n      post_id: agg.post_id,\n      row_number: agg.row_number,\n\n      _vk_all_ok: allOk,\n      _vk_sent_ok: agg.ok,\n      _vk_sent_fail: agg.fail,\n      _vk_sent_total: agg.total,\n\n      // Keep these in case you want final aggregator to decide.\n      update_last_run_at_utc: allOk ? agg.now_utc : null,\n      update_last_run_at: allOk ? agg.now_local : null,\n      update_last_run_key: allOk ? agg.last_run_key : null,\n\n      // write plan_run_at only on success\n      update_plan_run_at: allOk ? (agg.plan_run_at ?? null) : null,\n\n      update_error: newError,\n\n      // optional: useful for debugging\n      vk_post_ids: agg.vk_post_ids,\n    },\n  });\n}\n\nreturn out;\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[5712,1584],"id":"e635290b-7068-4a59-b45f-a1ae9afad1a4","name":"Collect VK results"},{"parameters":{"assignments":{"assignments":[{"id":"40cb9769-3d4e-4419-ba2d-1f2a143fc134","name":"row_number","value":"={{$json.row_number}}","type":"number"},{"id":"4a693b1b-a451-4be0-804e-dcea42cce4f1","name":"_run_key","value":"={{$json._run_key}}","type":"string"},{"id":"263354fa-7b27-48e5-b64f-e9782fe9f1c1","name":"_now","value":"{{$json._now}}","type":"string"},{"id":"800fee7f-bd57-43da-a970-c201ffd9f0d8","name":"error_prev","value":"={{$json.error}}","type":"string"},{"id":"d11608cf-910a-411d-86a7-b8de74c810b0","name":"vk_message","value":"={{$json.text}}","type":"string"},{"id":"a07aa251-a83a-4292-a9f6-c2791dcb2e72","name":"vk_owner_id","value":-114286850,"type":"number"},{"id":"c1320c28-2609-4d0a-81aa-a8913fd7433e","name":"_now_utc","value":"={{$json._now_utc}}","type":"string"},{"id":"e0226193-b507-45ff-8837-b96011bef7fb","name":"send_vk","value":"={{$json.send_vk}}","type":"boolean"},{"id":"6d495acc-0a1d-46cc-ba04-7a4b2f9b0cc6","name":"post_id","value":"={{$json.id}}","type":"number"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[4672,1360],"id":"70ba86bf-5bf0-44eb-a4c4-f8af42a5190c","name":"VK Edit Fields","onError":"continueRegularOutput"},{"parameters":{"mode":"combine","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5216,1568],"id":"4658838c-f52a-4b8a-868d-abe51f008109","name":"Merge VK"},{"parameters":{"jsCode":"// Loop over input items and add a new field called 'myNewField' to the JSON of each one\nfor (const item of $input.all()) {\n  item.json.myNewField = 1;\n}\n\nreturn $input.all();"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[5920,1584],"id":"359afbd4-caa0-4521-8727-d75a3c856528","name":"Code in JavaScript1"},{"parameters":{},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[6144,1872],"id":"095c68bc-584b-455a-a3c3-116cbf9c7865","name":"Merge6"},{"parameters":{"jsCode":"/**\n * Final Collect (TG + VK) per post_id\n *\n * Input: mixed items from:\n *  - Collect TG results (your existing code)\n *  - Collect VK results (code we added)\n *\n * Goal:\n *  - decide final _all_ok ONLY when all enabled channels succeeded\n *  - build one aggregated update_error log per post\n *  - output ONE item per post_id with fields for Google Sheets update:\n *      - update_last_run_at_utc / update_last_run_at / update_last_run_key / update_plan_run_at (ONLY if _all_ok)\n *      - update_error (always)\n *\n * IMPORTANT:\n *  - This node expects send_tg / send_vk to be present on at least one of incoming items.\n *    If they are missing, it will infer requirements from presence of TG/VK collector items.\n *    (Recommended: add send_tg and send_vk to both TG Edit Fields and VK Edit Fields so they survive to collectors.)\n */\n\nconst items = $input.all();\n\nfunction safeStr(v) {\n  if (v === null || v === undefined) return '';\n  return String(v);\n}\n\nfunction toBoolOrNull(v) {\n  if (v === null || v === undefined) return null;\n  if (typeof v === 'boolean') return v;\n  if (typeof v === 'number') return v !== 0;\n  const s = String(v).trim().toLowerCase();\n  if (s === '') return null;\n  if (s === '1' || s === 'true' || s === 'yes' || s === 'y') return true;\n  if (s === '0' || s === 'false' || s === 'no' || s === 'n') return false;\n  return null;\n}\n\nfunction toNumOrNull(v) {\n  if (v === null || v === undefined || v === '') return null;\n  const n = Number(v);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction appendLog(existing, line) {\n  const base = (existing ?? '').toString().trim();\n  if (!base) return line;\n  return base + '\\n' + line;\n}\n\nfunction isTgCollectorItem(p) {\n  // Your TG collector outputs: _sent_ok/_sent_fail/_sent_total and _all_ok\n  return p && (p._sent_total !== undefined || p._sent_ok !== undefined || p._sent_fail !== undefined);\n}\n\nfunction isVkCollectorItem(p) {\n  // VK collector outputs: _vk_sent_total/_vk_sent_ok/_vk_sent_fail and _vk_all_ok\n  return p && (p._vk_sent_total !== undefined || p._vk_sent_ok !== undefined || p._vk_sent_fail !== undefined);\n}\n\nfunction pickFirstNonEmpty(...vals) {\n  for (const v of vals) {\n    if (v === null || v === undefined) continue;\n    if (typeof v === 'string' && v.trim() === '') continue;\n    return v;\n  }\n  return null;\n}\n\n// Group per post_id\nconst byPost = new Map();\n\nfor (const item of items) {\n  const p = item.json || {};\n  const postId = p.post_id ?? p.id ?? null;\n  if (!postId) continue;\n\n  if (!byPost.has(postId)) {\n    byPost.set(postId, {\n      post_id: postId,\n\n      // common context\n      row_number: toNumOrNull(p.row_number),\n      now_utc: p.update_last_run_at_utc ?? p._now_utc ?? null,\n      now_local: p.update_last_run_at ?? p._now ?? null,\n      last_run_key: p.update_last_run_key ?? p._run_key ?? null,\n      plan_run_at: p.update_plan_run_at ?? p._plan_run_at ?? null,\n\n      // flags\n      send_tg: toBoolOrNull(p.send_tg),\n      send_vk: toBoolOrNull(p.send_vk),\n\n      // collector results\n      tg_seen: false,\n      tg_ok: null,\n      tg_ok_count: null,\n      tg_fail_count: null,\n      tg_total: null,\n\n      vk_seen: false,\n      vk_ok: null,\n      vk_ok_count: null,\n      vk_fail_count: null,\n      vk_total: null,\n\n      // logs\n      prev_error: p.error_prev ?? null,\n      tg_update_error: null,\n      vk_update_error: null,\n\n      // final error assembled later\n      final_error: null,\n    });\n  }\n\n  const agg = byPost.get(postId);\n\n  // keep row_number if missing\n  if (agg.row_number === null || agg.row_number === undefined) {\n    agg.row_number = toNumOrNull(p.row_number);\n  }\n\n  // keep best timestamps/keys/plan\n  agg.now_utc = pickFirstNonEmpty(agg.now_utc, p.update_last_run_at_utc, p._now_utc);\n  agg.now_local = pickFirstNonEmpty(agg.now_local, p.update_last_run_at, p._now);\n  agg.last_run_key = pickFirstNonEmpty(agg.last_run_key, p.update_last_run_key, p._run_key);\n  agg.plan_run_at = pickFirstNonEmpty(agg.plan_run_at, p.update_plan_run_at, p._plan_run_at);\n\n  // capture send flags if present anywhere\n  const st = toBoolOrNull(p.send_tg);\n  const sv = toBoolOrNull(p.send_vk);\n  if (st !== null) agg.send_tg = st;\n  if (sv !== null) agg.send_vk = sv;\n\n  // capture prev_error if present\n  if (p.error_prev !== undefined && p.error_prev !== null) agg.prev_error = p.error_prev;\n\n  // Determine if this is TG or VK collector item\n  if (isTgCollectorItem(p) || p._all_ok !== undefined) {\n    agg.tg_seen = true;\n    if (typeof p._all_ok === 'boolean') agg.tg_ok = p._all_ok;\n    agg.tg_ok_count = toNumOrNull(p._sent_ok);\n    agg.tg_fail_count = toNumOrNull(p._sent_fail);\n    agg.tg_total = toNumOrNull(p._sent_total);\n\n    // Collect TG log line from update_error (it includes prev + appended line)\n    // We'll extract the *new* TG line by taking the last line, but safest is to just keep update_error and\n    // later build final by appending BOTH TG and VK last lines if we can.\n    if (p.update_error) agg.tg_update_error = safeStr(p.update_error);\n  }\n\n  if (isVkCollectorItem(p) || p._vk_all_ok !== undefined) {\n    agg.vk_seen = true;\n    if (typeof p._vk_all_ok === 'boolean') agg.vk_ok = p._vk_all_ok;\n    agg.vk_ok_count = toNumOrNull(p._vk_sent_ok);\n    agg.vk_fail_count = toNumOrNull(p._vk_sent_fail);\n    agg.vk_total = toNumOrNull(p._vk_sent_total);\n\n    if (p.update_error) agg.vk_update_error = safeStr(p.update_error);\n  }\n\n  // If item isn't clearly TG/VK collector, but has update_error, still keep it as prev_error fallback\n  if (!agg.tg_update_error && !agg.vk_update_error && p.update_error) {\n    // Could be a prior step; treat as base log\n    agg.prev_error = p.update_error;\n  }\n}\n\n// Helper to get last line of a log string\nfunction lastLine(s) {\n  if (!s) return '';\n  const lines = String(s).split('\\n').map(x => x.trim()).filter(Boolean);\n  return lines.length ? lines[lines.length - 1] : '';\n}\n\nconst out = [];\n\nfor (const agg of byPost.values()) {\n  // Decide requirements:\n  // If send_tg/send_vk are unknown, infer from presence of collector items.\n  const reqTg = (agg.send_tg === null || agg.send_tg === undefined) ? agg.tg_seen : agg.send_tg;\n  const reqVk = (agg.send_vk === null || agg.send_vk === undefined) ? agg.vk_seen : agg.send_vk;\n\n  // Determine per-channel ok:\n  // If required but no collector result -> fail.\n  const tgOk = reqTg ? (agg.tg_ok === true) : true;\n  const vkOk = reqVk ? (agg.vk_ok === true) : true;\n\n  const allOk = tgOk && vkOk;\n\n  // Build final error:\n  // Start with prev_error, then append last TG line and last VK line if present.\n  // We use lastLine(...) because collector update_error already includes previous history.\n  let newError = agg.prev_error;\n\n  const tgLine = lastLine(agg.tg_update_error);\n  const vkLine = lastLine(agg.vk_update_error);\n\n  if (tgLine) newError = appendLog(newError, tgLine);\n  if (vkLine) newError = appendLog(newError, vkLine);\n\n  // If no prev_error and collectors didn't provide anything, still provide a minimal diagnostic.\n  if (!newError) {\n    newError = `[INFO] ${safeStr(agg.now_utc || new Date().toISOString())} no logs from collectors`;\n  }\n\n  out.push({\n    json: {\n      post_id: agg.post_id,\n      row_number: agg.row_number,\n\n      // final success only if all required channels succeeded\n      _all_ok: allOk,\n\n      // expose channel statuses for debugging\n      _req_tg: reqTg,\n      _req_vk: reqVk,\n      _tg_ok: agg.tg_ok,\n      _vk_ok: agg.vk_ok,\n\n      // optionally counts (may be null if not present)\n      _tg_sent_ok: agg.tg_ok_count,\n      _tg_sent_fail: agg.tg_fail_count,\n      _tg_sent_total: agg.tg_total,\n      _vk_sent_ok: agg.vk_ok_count,\n      _vk_sent_fail: agg.vk_fail_count,\n      _vk_sent_total: agg.vk_total,\n\n      // Sheets update fields (write only on final success)\n      update_last_run_at_utc: allOk ? (agg.now_utc ?? null) : null,\n      update_last_run_at: allOk ? (agg.now_local ?? null) : null,\n      update_last_run_key: allOk ? (agg.last_run_key ?? null) : null,\n      update_plan_run_at: allOk ? (agg.plan_run_at ?? null) : null,\n\n      update_error: newError,\n    },\n  });\n}\n\nreturn out;\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[6336,1872],"id":"92e91ea2-c9a7-4213-a4d6-707d50e1c0bd","name":"Final Collect"}],"connections":{"When clicking ‘Execute workflow’":{"main":[[{"node":"Get row(s) in sheet","type":"main","index":0}]]},"Get row(s) in sheet":{"main":[[{"node":"Filter","type":"main","index":0}]]},"Filter":{"main":[[{"node":"Code in JavaScript","type":"main","index":0}]]},"Code in JavaScript":{"main":[[{"node":"Determine due","type":"main","index":0}]]},"Filter1":{"main":[[{"node":"Postgre_store_extract","type":"main","index":0},{"node":"Merge1","type":"main","index":0},{"node":"GS_CoopFact_GetRows","type":"main","index":0}]]},"Code in JavaScript2":{"main":[[{"node":"Edit Fields","type":"main","index":0},{"node":"Filter VK","type":"main","index":0}]]},"Postgre_store_extract":{"main":[[{"node":"Merge1","type":"main","index":1}]]},"Send a text message":{"main":[[{"node":"Merge","type":"main","index":1}]]},"Edit Fields":{"main":[[{"node":"Switch","type":"main","index":0}]]},"Collect TG results":{"main":[[{"node":"Merge6","type":"main","index":1}]]},"Merge":{"main":[[{"node":"Merge5","type":"main","index":0}]]},"If":{"main":[[{"node":"Update row in sheet","type":"main","index":0}],[{"node":"Update row in sheet1","type":"main","index":0}]]},"Merge1":{"main":[[{"node":"Merge_Facts_Barrier","type":"main","index":1}]]},"Switch":{"main":[[{"node":"Send a text message","type":"main","index":0},{"node":"Merge","type":"main","index":0}],[{"node":"Send a photo message","type":"main","index":0},{"node":"Merge2","type":"main","index":0}],[{"node":"Send a video","type":"main","index":0},{"node":"Merge3","type":"main","index":0}],[{"node":"HTTP Request","type":"main","index":0},{"node":"Merge4","type":"main","index":0}]]},"Send a photo message":{"main":[[{"node":"Merge2","type":"main","index":1}]]},"Merge2":{"main":[[{"node":"Merge5","type":"main","index":1}]]},"Send a video":{"main":[[{"node":"Merge3","type":"main","index":1}]]},"Merge3":{"main":[[{"node":"Merge5","type":"main","index":2}]]},"HTTP Request":{"main":[[{"node":"Merge4","type":"main","index":1}]]},"Merge4":{"main":[[{"node":"Merge5","type":"main","index":3}]]},"Merge5":{"main":[[{"node":"Collect TG results","type":"main","index":0}]]},"GS_CoopFact_GetRows":{"main":[[{"node":"Merge_Facts_Barrier","type":"main","index":0}]]},"Merge_Facts_Barrier":{"main":[[{"node":"Code in JavaScript2","type":"main","index":0}]]},"Determine due":{"main":[[{"node":"Filter1","type":"main","index":0}]]},"Schedule Trigger":{"main":[[{"node":"Get row(s) in sheet","type":"main","index":0}]]},"Filter VK":{"main":[[{"node":"VK Edit Fields","type":"main","index":0}]]},"VK wall.post":{"main":[[{"node":"Merge VK","type":"main","index":0}]]},"VK Edit Fields":{"main":[[{"node":"VK wall.post","type":"main","index":0},{"node":"Merge VK","type":"main","index":1}]]},"Merge VK":{"main":[[{"node":"Collect VK results","type":"main","index":0}]]},"Collect VK results":{"main":[[{"node":"Code in JavaScript1","type":"main","index":0}]]},"Code in JavaScript1":{"main":[[{"node":"Merge6","type":"main","index":0}]]},"Merge6":{"main":[[{"node":"Final Collect","type":"main","index":0}]]},"Final Collect":{"main":[[{"node":"If","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","availableInMCP":false,"timeSavedMode":"fixed","callerPolicy":"workflowsFromSameOwner"},"staticData":{"node:Schedule Trigger":{"recurrenceRules":[]}},"meta":{"templateCredsSetupCompleted":true},"pinData":{},"versionId":"9eaf50ca-748c-4f71-b110-e00d75593428","activeVersionId":"9eaf50ca-748c-4f71-b110-e00d75593428","versionCounter":82,"triggerCount":1,"tags":[],"shared":[{"updatedAt":"2026-01-03T11:38:42.869Z","createdAt":"2026-01-03T11:38:42.869Z","role":"workflow:owner","workflowId":"poTupu2jfIU7WPUA","projectId":"pN1dQC2QTiUB8OxN","project":{"updatedAt":"2026-01-03T09:50:23.589Z","createdAt":"2026-01-02T11:57:57.457Z","id":"pN1dQC2QTiUB8OxN","name":"Ilya Sukharev <retail.sukharev@yandex.ru>","type":"personal","icon":null,"description":null,"creatorId":"a8327288-747a-47c3-9f5f-b2070eff6d8c"}}]},{"updatedAt":"2026-01-21T06:15:01.770Z","createdAt":"2026-01-17T15:57:41.910Z","id":"nYtWLQMPCPdUAsaT","name":"Create Content Plan","description":null,"active":true,"isArchived":false,"nodes":[{"parameters":{},"type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[2960,1776],"id":"436c3709-c0dd-42a0-a928-01c70f07cd10","name":"When clicking ‘Execute workflow’"},{"parameters":{"documentId":{"__rl":true,"value":"1FyEGxa6JYTJxDrowfgzAzroTM8L3CWCSY1rgI2DK9KQ","mode":"id"},"sheetName":{"__rl":true,"value":"POST","mode":"name"},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[3440,1776],"id":"c03bf4e1-2ad7-4a8d-969f-5e196a4c7236","name":"Get row(s) in sheet","credentials":{"googleSheetsOAuth2Api":{"id":"b5DluHDjTyDAsQWd","name":"Google Sheets account"}}},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"id":"f85b46f7-7741-4bef-99c0-a6d3a7648197","leftValue":"={{ $json.status }}","rightValue":1,"operator":{"type":"number","operation":"equals"}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.filter","typeVersion":2.3,"position":[3648,1840],"id":"f13de4b1-a969-43a4-b3d4-4ea21b102ceb","name":"Filter","onError":"continueRegularOutput"},{"parameters":{"jsCode":"// n8n Code node: Build Content Plan\n// Сформировать /smmcontent/content-plan.json (items + stores_catalog + posts_catalog)\n// Поддерживает:\n//  - регулярные посты через schedule (DTSTART + RRULE)\n//  - разовые посты через publish_at (локальное время региона), если schedule пустой\n//  - показывает события начиная с 00:00 сегодняшнего дня (не от текущего времени)\n\n\n// ===== НАСТРОЙКИ =====\nconst DAYS_AHEAD = 14; // максимум 14\nconst REGION_TZ = {\n  54: \"Asia/Novosibirsk\",\n  82: \"Europe/Simferopol\",\n};\nconst REGION_FROM_TZ = {\n  7: 54, // Novosibirsk\n  3: 82, // Crimea\n};\n// =====================\n\n\n// --- parse schedule ---\nfunction parseSchedule(schedule) {\n  if (!schedule) return null;\n\n  const dt = schedule.match(/DTSTART:(\\d{4}-\\d{2}-\\d{2}) (\\d{2}:\\d{2}:\\d{2})/);\n  if (!dt) return null;\n\n  const rrule = schedule.match(/RRULE:([^\\n\\r]+)/);\n  const rule = rrule ? rrule[1].trim() : \"\";\n\n  const freq = (rule.match(/FREQ=([A-Z]+)/)?.[1] || \"\").toUpperCase();\n  const bydayRaw = rule.match(/BYDAY=([A-Z,]+)/)?.[1];\n  const byday = bydayRaw ? bydayRaw.split(\",\").map((s) => s.trim()) : null;\n\n  const dtstartDate = dt[1]; // YYYY-MM-DD\n  const dtstartTime = dt[2]; // HH:MM:SS\n\n  return { freq, byday, dtstartDate, dtstartTime };\n}\n\n\n// --- parse publish_at (локальный datetime) ---\n// Ожидаем: \"YYYY-MM-DD HH:MM:SS\" или \"YYYY-MM-DD HH:MM\"\nfunction parsePublishAtLocal(publish_at) {\n  const s = String(publish_at ?? \"\").trim();\n  if (!s) return null;\n\n  // 2026-01-18 09:00:00\n  let m = s.match(/^(\\d{4}-\\d{2}-\\d{2})\\s+(\\d{2}:\\d{2}:\\d{2})$/);\n  if (m) return { ymd: m[1], time: m[2] };\n\n  // 2026-01-18 09:00\n  m = s.match(/^(\\d{4}-\\d{2}-\\d{2})\\s+(\\d{2}:\\d{2})$/);\n  if (m) return { ymd: m[1], time: m[2] + \":00\" };\n\n  return null;\n}\n\n\n// --- TZ helpers (local-in-tz -> UTC ISO) ---\nfunction tzOffsetMinutesForUtc(utcDate, tz) {\n  const parts = new Intl.DateTimeFormat(\"en-US\", {\n    timeZone: tz,\n    year: \"numeric\",\n    month: \"2-digit\",\n    day: \"2-digit\",\n    hour: \"2-digit\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n    hour12: false,\n  }).formatToParts(utcDate);\n\n  const map = {};\n  for (const p of parts) if (p.type !== \"literal\") map[p.type] = p.value;\n\n  const asUtc = Date.UTC(\n    Number(map.year),\n    Number(map.month) - 1,\n    Number(map.day),\n    Number(map.hour),\n    Number(map.minute),\n    Number(map.second)\n  );\n\n  return Math.round((asUtc - utcDate.getTime()) / 60000);\n}\n\nfunction localInTzToUtcIso(localY, localM, localD, hh, mm, ss, tz) {\n  const guessUtcMs = Date.UTC(localY, localM - 1, localD, hh, mm, ss);\n  const guessUtc = new Date(guessUtcMs);\n  const offMin = tzOffsetMinutesForUtc(guessUtc, tz);\n  const realUtcMs = guessUtcMs - offMin * 60000;\n  return new Date(realUtcMs).toISOString();\n}\n\nfunction ymdInTz(dateUtc, tz) {\n  return new Intl.DateTimeFormat(\"en-CA\", {\n    timeZone: tz,\n    year: \"numeric\",\n    month: \"2-digit\",\n    day: \"2-digit\",\n  }).format(dateUtc); // YYYY-MM-DD\n}\n\nfunction addDaysYmd(ymd, add) {\n  const [y, m, d] = ymd.split(\"-\").map(Number);\n  const dt = new Date(Date.UTC(y, m - 1, d, 0, 0, 0));\n  dt.setUTCDate(dt.getUTCDate() + add);\n  const yy = dt.getUTCFullYear();\n  const mm = String(dt.getUTCMonth() + 1).padStart(2, \"0\");\n  const dd = String(dt.getUTCDate()).padStart(2, \"0\");\n  return `${yy}-${mm}-${dd}`;\n}\n\nfunction splitTime(dtstartTime) {\n  const [hh, mm, ss] = dtstartTime.split(\":\").map(Number);\n  return { hh, mm, ss };\n}\n\nfunction timeHHMM(dtstartTime) {\n  return dtstartTime.slice(0, 5);\n}\n\n\n// --- parse store_* columns from row ---\n// ожидаем колонки: store_195_Большевистская (значение 1 = включено)\nfunction extractSelectedStoreIdsFromRow(post) {\n  const ids = [];\n  for (const k of Object.keys(post)) {\n    const m = k.match(/^store_(\\d+)_/);\n    if (!m) continue;\n    const store_id = Number(m[1]);\n    const v = post[k];\n    const isOn = String(v).trim() === \"1\" || v === 1 || v === true;\n    if (isOn) ids.push(store_id);\n  }\n  ids.sort((a, b) => a - b);\n  return ids;\n}\n\nfunction boolOn(v) {\n  return String(v ?? \"\").trim() === \"1\" || v === 1 || v === true;\n}\n\nfunction safeString(v) {\n  return String(v ?? \"\").trim();\n}\n\nfunction toIntOrNull(v) {\n  const n = Number(v);\n  return Number.isFinite(n) ? n : null;\n}\n\n\n// -------------------- MAIN --------------------\nconst nowUtc = new Date();\n\n// posts берём из Filter (чтобы не путать с Append-барьером)\nconst posts = $items(\"Filter\").map((x) => x.json);\n\n// stores берём из Postgres-ноды\nconst storesRaw = $items(\"PG Stores\").map((x) => x.json);\n\n// Нормализуем stores\nconst storeById = new Map();\nconst storesByRegion = new Map(); // region -> stores[]\nfor (const s of storesRaw) {\n  const store_id = Number(s.store_id);\n  const name = safeString(s.store_description) || (\"#\" + store_id);\n  const time_zone = Number(s.time_zone);\n\n  const region = REGION_FROM_TZ[time_zone] ?? null;\n  const norm = { store_id, name, time_zone, region };\n\n  storeById.set(store_id, norm);\n\n  if (region !== null) {\n    if (!storesByRegion.has(region)) storesByRegion.set(region, []);\n    storesByRegion.get(region).push(norm);\n  }\n}\n\n// сортируем списки\nfor (const [r, arr] of storesByRegion.entries()) {\n  arr.sort((a, b) => a.store_id - b.store_id);\n}\n\n// stores_catalog только из Postgres (это “истина”)\nconst stores_catalog = Array.from(storeById.values())\n  .filter((s) => s.region !== null)\n  .sort((a, b) => a.store_id - b.store_id)\n  .map((s) => ({\n    store_id: s.store_id,\n    name: s.name,\n    region: s.region,\n    time_zone: s.time_zone,\n  }));\n\n// --- posts_catalog: контент постов для Telegram preview ---\nconst posts_catalog = {};\nfor (const p of posts) {\n  const pid = String(p.id ?? p.post_id ?? \"\").trim();\n  if (!pid) continue;\n  if (Number(p.status) !== 1) continue;\n\n  const title = safeString(p.title);\n  const text = String(p.text ?? \"\");\n  const parse_mode = toIntOrNull(p.parse_mode) ?? 0; // 0/plain, 1/HTML, 2/MarkdownV2\n  const media_url = String(p.media_url ?? \"\");\n\n  posts_catalog[pid] = {\n    title,\n    text,\n    parse_mode,\n    media_url,\n  };\n}\n\nconst outItems = [];\n\nfor (const p of posts) {\n  if (Number(p.status) !== 1) continue;\n\n  const region = Number(p.region);\n  const tz = REGION_TZ[region] || \"Europe/Moscow\";\n\n  // Определяем target store_ids для поста\n  let targetStoreIds = [];\n  const allRegionOn = boolOn(p.all_region);\n\n  if (allRegionOn) {\n    const allStores = storesByRegion.get(region) || [];\n    targetStoreIds = allStores.map((s) => s.store_id);\n  } else {\n    const selectedIds = extractSelectedStoreIdsFromRow(p);\n    targetStoreIds = selectedIds.filter((id) => storeById.has(Number(id)));\n  }\n\n  // today in region tz (YYYY-MM-DD) — стартуем от 00:00 сегодняшнего дня\n  const todayYmd = ymdInTz(nowUtc, tz);\n  const endYmd = addDaysYmd(todayYmd, DAYS_AHEAD - 1);\n\n  // --- 1) Регулярные посты по schedule ---\n  if (p.schedule) {\n    const sch = parseSchedule(p.schedule);\n    if (!sch) continue;\n\n    const { freq, byday, dtstartDate, dtstartTime } = sch;\n    const dtStartYmd = dtstartDate;\n    const { hh, mm, ss } = splitTime(dtstartTime);\n\n    for (let i = 0; i < DAYS_AHEAD; i++) {\n      const dayYmd = addDaysYmd(todayYmd, i);\n\n      // Skip days before DTSTART date\n      if (dayYmd < dtStartYmd) continue;\n\n      // Weekly filter\n      if (freq === \"WEEKLY\" && byday && byday.length) {\n        const noonUtc = new Date(\n          Date.UTC(\n            Number(dayYmd.slice(0, 4)),\n            Number(dayYmd.slice(5, 7)) - 1,\n            Number(dayYmd.slice(8, 10)),\n            12,\n            0,\n            0\n          )\n        );\n        const wd = new Intl.DateTimeFormat(\"en-US\", {\n          timeZone: tz,\n          weekday: \"short\",\n        })\n          .format(noonUtc)\n          .toUpperCase()\n          .slice(0, 2);\n        if (!byday.includes(wd)) continue;\n      } else if (freq === \"DAILY\") {\n        // ok\n      } else {\n        continue;\n      }\n\n      const [Y, M, D] = dayYmd.split(\"-\").map(Number);\n      const utcIso = localInTzToUtcIso(Y, M, D, hh, mm, ss, tz);\n\n      outItems.push({\n        kind: \"rrule\", // NEW\n        region,\n        tz,\n        post_id: p.id,\n        title: p.title,\n        local_dt: `${dayYmd} ${dtstartTime}`,\n        hhmm: timeHHMM(dtstartTime),\n        utc_iso: utcIso,\n        store_ids: targetStoreIds,\n      });\n    }\n\n    continue;\n  }\n\n  // --- 2) Разовые посты по publish_at (локальный datetime) ---\n  const pa = parsePublishAtLocal(p.publish_at);\n  if (!pa) continue;\n\n  // фильтр периода: только сегодня..+DAYS_AHEAD-1\n  if (pa.ymd < todayYmd || pa.ymd > endYmd) continue;\n\n  const { hh, mm, ss } = splitTime(pa.time);\n  const [Y, M, D] = pa.ymd.split(\"-\").map(Number);\n  const utcIso = localInTzToUtcIso(Y, M, D, hh, mm, ss, tz);\n\n  outItems.push({\n    kind: \"once\", // NEW\n    region,\n    tz,\n    post_id: p.id,\n    title: p.title,\n    local_dt: `${pa.ymd} ${pa.time}`,\n    hhmm: timeHHMM(pa.time),\n    utc_iso: utcIso,\n    store_ids: targetStoreIds,\n  });\n}\n\n// Sort by utc time\noutItems.sort((a, b) => new Date(a.utc_iso) - new Date(b.utc_iso));\n\nreturn [\n  {\n    json: {\n      generated_at_utc: new Date().toISOString(),\n      days_ahead: DAYS_AHEAD,\n      items: outItems,\n      stores_catalog,\n      posts_catalog,\n    },\n  },\n];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[4208,1744],"id":"4955bdb9-544a-4e50-a51a-d806e34fd038","name":"Build Content Plan"},{"parameters":{"operation":"toJson","options":{"fileName":"content-plan.json"}},"type":"n8n-nodes-base.convertToFile","typeVersion":1.1,"position":[4512,2016],"id":"1f3f938e-0cce-410e-a2df-71c43262515a","name":"Convert to File"},{"parameters":{"operation":"write","fileName":"/data/smmcontent/content-plan.json","options":{}},"type":"n8n-nodes-base.readWriteFile","typeVersion":1.1,"position":[5120,2016],"id":"fa0bd474-e89a-425f-aefe-f3d21ae0fff8","name":"Read/Write Files from Disk","onError":"continueRegularOutput"},{"parameters":{"operation":"executeQuery","query":"SELECT\n  s.store_id,\n  s.store_description,\n  s.time_zone,\n  MAX(sc.channel_chat_id) AS channel_chat_id\nFROM coop.order_store s\nJOIN coop.store_channel sc\n  ON sc.store_id = s.store_id\nWHERE sc.channel_chat_id IS NOT NULL\n  AND s.time_zone IN (3, 7)\n  AND s.store_close_date IS NULL\nGROUP BY\n  s.store_id,\n  s.store_description,\n  s.time_zone\nORDER BY\n  s.time_zone,\n  s.store_id;\n","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[3776,2048],"id":"7e7c1e20-a8fe-4de8-98d8-12d1efef2918","name":"PG Stores","credentials":{"postgres":{"id":"Nn7xJ9wkuFYHFyvT","name":"Postgres account"}}},{"parameters":{},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[3984,1840],"id":"ae6a261e-7de4-4160-9e27-ad0b2805b43f","name":"Barrier: Posts + Stores"},{"parameters":{"rule":{"interval":[{"field":"minutes"}]}},"type":"n8n-nodes-base.scheduleTrigger","typeVersion":1.3,"position":[2992,2112],"id":"956d1c41-ee00-4d6b-9cbb-e67381c5a2a3","name":"Schedule Trigger"},{"parameters":{"jsCode":"return [\n  {\n    json: {\n      html: `<!doctype html>\n<html lang=\"ru\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <title>Контент-план</title>\n  <style>\n    :root{\n      --border:#e6e6e6;\n      --head:#f6f6f6;\n      --muted:#666;\n      --bg:#fff;\n      --card:#ffffff;\n      --cardBorder:#efefef;\n      --errorBg:#fff0f0;\n      --errorBorder:#f2bcbc;\n      --errorText:#b00;\n      --chipBg:#f3f3f3;\n      --chipBorder:#e2e2e2;\n      --shadow: 0 10px 24px rgba(0,0,0,0.08);\n      --hoverRing: 0 0 0 3px rgba(0,0,0,0.14);\n\n      --overlay: rgba(0,0,0,0.46);\n      --tgBg: #0b141b;\n      --tgCard: #17212b;\n      --tgCard2: #1f2c3a;\n      --tgText: #e9eef5;\n      --tgMuted: rgba(233,238,245,0.68);\n      --tgBorder: rgba(255,255,255,0.08);\n    }\n\n    *{box-sizing:border-box;}\n    body{\n      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;\n      margin:16px;\n      background:var(--bg);\n      color:#111;\n    }\n    h2{margin:0 0 12px 0}\n\n    .row{\n      display:flex;\n      gap:12px;\n      flex-wrap:wrap;\n      align-items:center;\n      margin-bottom:12px;\n    }\n    .muted{color:var(--muted); font-size:12px;}\n\n    select,input[type=\"date\"],button{\n      padding:6px 10px;\n      font-size:14px;\n      border:1px solid var(--border);\n      border-radius:10px;\n      background:#fff;\n    }\n    button{cursor:pointer;}\n    button:active{transform:translateY(1px);}\n\n    /* Верхняя панель */\n    .topBar{\n      position:sticky;\n      top:0;\n      z-index:100;\n      background:rgba(255,255,255,0.92);\n      backdrop-filter:saturate(180%) blur(10px);\n      border:1px solid var(--border);\n      border-radius:14px;\n      padding:10px 12px;\n      box-shadow:0 6px 18px rgba(0,0,0,0.04);\n      margin-bottom:12px;\n    }\n    .topBar .row{margin-bottom:0}\n\n    .storesPanel{\n      border:1px solid var(--border);\n      border-radius:14px;\n      padding:10px 12px;\n      margin:8px 0 12px 0;\n      background:#fff;\n    }\n    .storesTop{\n      display:flex;\n      gap:10px;\n      align-items:center;\n      flex-wrap:wrap;\n      margin-bottom:8px;\n    }\n    .storesTitle{font-weight:700;margin-right:6px;}\n    .storesActions{display:flex;gap:8px;flex-wrap:wrap;}\n    .storesList{\n      display:flex;\n      flex-wrap:wrap;\n      gap:10px 14px;\n      max-height:160px;\n      overflow:auto;\n      padding-right:6px;\n    }\n    .storeItem{\n      display:flex;\n      align-items:center;\n      gap:8px;\n      white-space:nowrap;\n      font-size:13px;\n    }\n    .storeItem input{transform:translateY(1px);}\n\n    .tableWrap{\n      overflow-x:auto;\n      border:1px solid var(--border);\n      border-radius:14px;\n      background:#fff;\n      position:relative;\n      z-index:1;\n    }\n    table{\n      border-collapse:separate;\n      border-spacing:0;\n      width:max-content;\n      min-width:100%;\n      table-layout:fixed;\n      background:#fff;\n    }\n    th,td{\n      border-right:1px solid var(--border);\n      border-bottom:1px solid var(--border);\n      vertical-align:top;\n      padding:6px;\n      font-size:13px;\n      min-width:220px;\n    }\n\n    /* ✅ Заголовки дней НЕ липкие */\n    th{\n      background:var(--head);\n      text-align:center;\n      position:static;\n      z-index:auto;\n    }\n\n    /* левый столбец времени остаётся липким */\n    th:first-child, td:first-child{\n      position:sticky;\n      left:0;\n      z-index:6;\n      background:#fff;\n      min-width:72px;\n      width:72px;\n      text-align:center;\n      font-weight:600;\n    }\n    thead th:first-child{\n      background:var(--head);\n      z-index:7;\n      left:0;\n    }\n\n    .colHead{display:flex;flex-direction:column;gap:2px;align-items:center;line-height:1.1;}\n    .colDow{font-weight:800;letter-spacing:0.2px;}\n    .colDate{font-size:12px;color:var(--muted);font-weight:600;}\n\n    .item{\n      margin:0 0 6px 0;\n      padding:8px;\n      border:1px solid var(--cardBorder);\n      border-radius:12px;\n      background:var(--card);\n      position:relative;\n      transition: box-shadow 120ms ease, transform 120ms ease, border-color 120ms ease;\n      cursor:pointer;\n      z-index:1;\n    }\n    .item:last-child{margin-bottom:0}\n    .itemTitle{font-weight:800; line-height:1.2;}\n    .itemMeta{color:var(--muted); font-size:12px; margin-top:2px}\n    .itemChip{\n      display:inline-block;\n      margin-top:8px;\n      padding:3px 9px;\n      font-size:12px;\n      border-radius:999px;\n      background:var(--chipBg);\n      border:1px solid var(--chipBorder);\n      color:#222;\n    }\n    /* Разовые посты: другой вид овала */\n    .itemChip.once{\n      background:transparent;\n      border:1px dashed rgba(0,0,0,0.35);\n      color:#111;\n    }\n\n    .item.pid-colored{\n      background: hsla(var(--pid-h), 85%, 94%, 1);\n      border-color: hsla(var(--pid-h), 50%, 45%, 0.28);\n    }\n\n    .item:hover{\n      z-index:20;\n      box-shadow: var(--hoverRing), 0 10px 24px rgba(0,0,0,0.10);\n      transform: translateY(-1px);\n      border-color: hsla(var(--pid-h), 55%, 35%, 0.55);\n    }\n    .item.pid-hover{\n      z-index:20;\n      box-shadow: var(--hoverRing), 0 10px 24px rgba(0,0,0,0.10);\n      transform: translateY(-1px);\n      border-color: hsla(var(--pid-h), 55%, 35%, 0.55);\n    }\n\n    .error{\n      white-space:pre-wrap;\n      color:var(--errorText);\n      background:var(--errorBg);\n      padding:12px;\n      border:1px solid var(--errorBorder);\n      border-radius:10px;\n    }\n\n    /* === Telegram preview modal === */\n    .modal{\n      position:fixed;\n      inset:0;\n      background:var(--overlay);\n      display:none;\n      align-items:center;\n      justify-content:center;\n      padding:16px;\n      z-index:100000;\n    }\n    .modal.open{display:flex;}\n    .modalCard{\n      width:min(720px, 100%);\n      max-height:min(92vh, 900px);\n      background:var(--tgBg);\n      border:1px solid rgba(255,255,255,0.10);\n      border-radius:18px;\n      box-shadow:0 24px 80px rgba(0,0,0,0.55);\n      overflow:hidden;\n      display:flex;\n      flex-direction:column;\n    }\n    .modalTop{\n      display:flex;\n      align-items:center;\n      justify-content:space-between;\n      padding:10px 12px;\n      background:rgba(255,255,255,0.04);\n      border-bottom:1px solid rgba(255,255,255,0.08);\n    }\n    .modalTitle{\n      color:var(--tgText);\n      font-weight:800;\n      font-size:14px;\n      display:flex;\n      gap:10px;\n      align-items:center;\n      min-width:0;\n    }\n    .modalTitle .sub{\n      color:var(--tgMuted);\n      font-weight:700;\n      font-size:12px;\n      white-space:nowrap;\n      overflow:hidden;\n      text-overflow:ellipsis;\n    }\n    .modalClose{\n      border:1px solid rgba(255,255,255,0.12);\n      background:rgba(255,255,255,0.06);\n      color:var(--tgText);\n      border-radius:10px;\n      padding:6px 10px;\n      cursor:pointer;\n      font-weight:800;\n    }\n    .modalBody{\n      padding:14px;\n      overflow:auto;\n    }\n    .tgMessage{\n      background:var(--tgCard);\n      border:1px solid var(--tgBorder);\n      border-radius:18px;\n      padding:12px;\n      color:var(--tgText);\n      max-width:560px;\n    }\n    .tgMetaRow{\n      display:flex;\n      align-items:center;\n      justify-content:space-between;\n      margin-bottom:8px;\n      gap:10px;\n    }\n    .tgChannel{\n      font-weight:900;\n      font-size:13px;\n      color:#8bd1ff;\n    }\n    .tgTime{\n      font-size:12px;\n      color:var(--tgMuted);\n      font-weight:700;\n      white-space:nowrap;\n    }\n    .tgText{\n      white-space:pre-wrap;\n      word-break:break-word;\n      font-size:14px;\n      line-height:1.35;\n    }\n    .tgMedia{\n      margin-top:10px;\n      display:grid;\n      gap:8px;\n    }\n    .tgMedia.one{grid-template-columns:1fr;}\n    .tgMedia.grid{grid-template-columns:1fr 1fr;}\n    .tgMediaItem{\n      background:var(--tgCard2);\n      border:1px solid var(--tgBorder);\n      border-radius:14px;\n      overflow:hidden;\n      position:relative;\n    }\n    .tgMediaItem img, .tgMediaItem video{\n      display:block;\n      width:100%;\n      height:auto;\n      max-height:360px;\n      object-fit:cover;\n      background:#000;\n    }\n    .tgBadge{\n      position:absolute;\n      left:10px;\n      top:10px;\n      padding:4px 8px;\n      font-size:12px;\n      border-radius:999px;\n      background:rgba(0,0,0,0.55);\n      border:1px solid rgba(255,255,255,0.18);\n      color:var(--tgText);\n      font-weight:900;\n    }\n    .tgErr{\n      margin-top:10px;\n      padding:10px;\n      border-radius:12px;\n      background:rgba(255,0,0,0.12);\n      border:1px solid rgba(255,0,0,0.22);\n      color:var(--tgText);\n      font-size:13px;\n      white-space:pre-wrap;\n    }\n\n    /* Tooltip портальный, без полосы прокрутки */\n    .portalTip{\n      position:fixed;\n      width:min(520px, 86vw);\n      background:#fff;\n      border:1px solid rgba(0,0,0,0.10);\n      border-radius:14px;\n      box-shadow: 0 18px 50px rgba(0,0,0,0.14);\n      padding:12px 12px 10px 12px;\n      z-index:200000;\n      display:none;\n    }\n    .portalTip.show{display:block;}\n    .portalTip::before{\n      content:\"\";\n      position:absolute;\n      top:-7px;\n      left:20px;\n      width:14px;\n      height:14px;\n      background:#fff;\n      border-left:1px solid rgba(0,0,0,0.10);\n      border-top:1px solid rgba(0,0,0,0.10);\n      transform:rotate(45deg);\n    }\n    .portalTipTitle{\n      font-weight:900;\n      margin-bottom:8px;\n      font-size:13px;\n      display:flex;\n      justify-content:space-between;\n      gap:10px;\n      align-items:center;\n    }\n    .portalTipCount{\n      font-size:12px;\n      color:var(--muted);\n      font-weight:700;\n    }\n    .portalTipList{\n      margin:0;\n      padding:0;\n      list-style:none;\n      display:flex;\n      flex-direction:column;\n      gap:6px;\n      /* ✅ без скролла */\n      max-height:none;\n      overflow:visible;\n    }\n    .portalTipList li{\n      font-size:12px;\n      color:#111;\n      line-height:1.35;\n      padding:6px 8px;\n      border:1px solid rgba(0,0,0,0.06);\n      border-radius:10px;\n      background:rgba(0,0,0,0.02);\n    }\n    .portalTipHint{font-size:12px;color:var(--muted);margin-top:10px;}\n\n    @media (max-width: 520px){\n      .topBar{ border-radius:12px; }\n      .tgMessage{ max-width:100%; }\n      .tgMedia.grid{ grid-template-columns:1fr; }\n    }\n  \n    /* === Mobile accordion (days) === */\n    .mobileAcc{display:none;}\n    .accDay{border:1px solid var(--border); border-radius:14px; background:#fff; overflow:hidden; margin:0 0 10px 0;}\n    .accHead{\n      display:flex; align-items:center; justify-content:space-between; gap:10px;\n      padding:12px 12px;\n      cursor:pointer;\n      user-select:none;\n    }\n    .accHeadLeft{display:flex; flex-direction:column; gap:2px; line-height:1.1;}\n    .accDow{font-weight:900; letter-spacing:0.2px;}\n    .accDate{font-size:12px; color:var(--muted); font-weight:700;}\n    .accChevron{\n      width:28px; height:28px;\n      display:flex; align-items:center; justify-content:center;\n      border:1px solid rgba(0,0,0,0.10);\n      border-radius:10px;\n      background:rgba(0,0,0,0.02);\n      transition: transform 160ms ease;\n      flex:0 0 auto;\n    }\n    .accDay.open .accChevron{ transform: rotate(180deg); }\n    .accBody{display:none; padding:10px 10px 12px 10px;}\n    .accDay.open .accBody{display:block;}\n    .accTime{margin:0 0 10px 0;}\n    .accTime:last-child{margin-bottom:0;}\n    .accTimeHead{\n      font-weight:900;\n      font-size:13px;\n      color:#111;\n      padding:4px 6px;\n      border-radius:10px;\n      display:inline-block;\n      background:rgba(0,0,0,0.03);\n      border:1px solid rgba(0,0,0,0.06);\n      margin:2px 0 8px 0;\n    }\n    .accItems{display:flex; flex-direction:column; gap:8px;}\n    .accItems .item{ margin:0; } /* keep existing item style, just remove table spacing */\n\n    @media (max-width: 900px){\n      body{ margin:12px; }\n      .storesList{ max-height: 240px; }\n      .tableWrap{ display:none; }\n      .mobileAcc{ display:block; }\n    }\n\n  </style>\n</head>\n<body>\n\n<div class=\"topBar\">\n  <h2>Контент-план</h2>\n\n  <div class=\"row\">\n    <div class=\"muted\">\n      Обновлено: <span id=\"gen\">—</span>, горизонт файла: <span id=\"daysFile\">—</span> дн.\n    </div>\n\n    <label>\n      Регион:\n      <select id=\"region\"></select>\n    </label>\n\n    <label>\n      Старт:\n      <input id=\"startDate\" type=\"date\" />\n    </label>\n\n    <label>\n      Период:\n      <select id=\"period\"></select>\n    </label>\n\n    <button id=\"btnToday\" type=\"button\">Сегодня</button>\n  </div>\n</div>\n\n<div class=\"storesPanel\">\n  <div class=\"storesTop\">\n    <span class=\"storesTitle\">Пункты выдачи</span>\n    <span class=\"muted\" id=\"storesHint\">—</span>\n    <div class=\"storesActions\">\n      <button type=\"button\" id=\"btnAll\">Выбрать все</button>\n      <button type=\"button\" id=\"btnNone\">Снять все</button>\n    </div>\n  </div>\n  <div class=\"storesList\" id=\"storesList\"></div>\n</div>\n\n<div id=\"wrap\"></div>\n\n<!-- Portal Tooltip -->\n<div class=\"portalTip\" id=\"portalTip\">\n  <div class=\"portalTipTitle\">\n    <span>Пункты выдачи</span>\n    <span class=\"portalTipCount\" id=\"ptCount\">—</span>\n  </div>\n  <ul class=\"portalTipList\" id=\"ptList\"></ul>\n  <div class=\"portalTipHint\">Наведи — подсветятся все такие же посты · клик — откроется превью Telegram</div>\n</div>\n\n<!-- Telegram preview modal -->\n<div class=\"modal\" id=\"modal\">\n  <div class=\"modalCard\" role=\"dialog\" aria-modal=\"true\">\n    <div class=\"modalTop\">\n      <div class=\"modalTitle\">\n        <span id=\"mTitle\">Превью Telegram</span>\n        <span class=\"sub\" id=\"mSub\">—</span>\n      </div>\n      <button class=\"modalClose\" id=\"mClose\" type=\"button\">Закрыть</button>\n    </div>\n    <div class=\"modalBody\">\n      <div class=\"tgMessage\">\n        <div class=\"tgMetaRow\">\n          <div class=\"tgChannel\">Коопторгъ</div>\n          <div class=\"tgTime\" id=\"mTime\">—</div>\n        </div>\n\n        <div class=\"tgText\" id=\"mText\">—</div>\n\n        <div class=\"tgMedia one\" id=\"mMedia\" style=\"display:none;\"></div>\n\n        <div class=\"tgErr\" id=\"mErr\" style=\"display:none;\"></div>\n      </div>\n    </div>\n  </div>\n</div>\n\n<script>\n(async () => {\n  const DAY_TITLES = ['ВС','ПН','ВТ','СР','ЧТ','ПТ','СБ']; // JS: 0=Sun\n  const pad2 = (n) => String(n).padStart(2,'0');\n\n  function escapeHtml(s){\n    return String(s ?? '').replace(/[&<>\"']/g, c =>\n      ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c])\n    );\n  }\n\n  function ymdFromDateLocal(d){\n    return d.getFullYear() + '-' + pad2(d.getMonth()+1) + '-' + pad2(d.getDate());\n  }\n\n  function parseYmdToDateLocal(ymd){\n    const [y,m,d] = ymd.split('-').map(Number);\n    return new Date(y, m-1, d, 0, 0, 0, 0);\n  }\n\n  function addDaysLocal(ymd, add){\n    const dt = parseYmdToDateLocal(ymd);\n    dt.setDate(dt.getDate() + add);\n    return ymdFromDateLocal(dt);\n  }\n\n  function ddmmyyyy(ymd){\n    return ymd.slice(8,10) + '.' + ymd.slice(5,7) + '.' + ymd.slice(0,4);\n  }\n\n  function ddmm(ymd){\n    return ymd.slice(8,10) + '.' + ymd.slice(5,7);\n  }\n\n  function dowRuFromYmd(ymd){\n    const dt = parseYmdToDateLocal(ymd);\n    return DAY_TITLES[dt.getDay()];\n  }\n\n  function getItemDateYmd(it){\n    if (it && typeof it.local_dt === 'string' && it.local_dt.length >= 10) {\n      return it.local_dt.slice(0,10);\n    }\n    const iso = it.utc_iso || it.datetime;\n    if (iso) {\n      const dt = new Date(iso);\n      if (!isNaN(dt)) return ymdFromDateLocal(dt);\n    }\n    return null;\n  }\n\n  function getItemTimeHHMM(it){\n    if (it && typeof it.hhmm === 'string' && it.hhmm.length === 5) return it.hhmm;\n    if (it && typeof it.local_time === 'string' && it.local_time.length >= 5) return it.local_time.slice(0,5);\n    if (it && typeof it.local_dt === 'string' && it.local_dt.length >= 16) return it.local_dt.slice(11,16);\n    const iso = it.utc_iso || it.datetime;\n    if (iso) {\n      const dt = new Date(iso);\n      if (!isNaN(dt)) return pad2(dt.getHours()) + ':' + pad2(dt.getMinutes());\n    }\n    return null;\n  }\n\n  function intersectStoreIds(itemStoreIds, selectedIdsSet){\n    if (!Array.isArray(itemStoreIds) || itemStoreIds.length === 0) return false;\n    for (const id of itemStoreIds) {\n      if (selectedIdsSet.has(Number(id))) return true;\n    }\n    return false;\n  }\n\n  function hueFromPostId(postId){\n    const str = String(postId ?? '');\n    let h = 0;\n    for (let i = 0; i < str.length; i++) h = (h * 31 + str.charCodeAt(i)) >>> 0;\n    return h % 360;\n  }\n\n  function parseMediaLines(mediaUrl){\n    const lines = String(mediaUrl ?? '')\n      .split(/\\\\r?\\\\n/)\n      .map(s => s.trim())\n      .filter(Boolean);\n\n    const out = [];\n    for (const ln of lines) {\n      if (ln.includes('|')) {\n        const [k, ...rest] = ln.split('|');\n        const url = rest.join('|').trim();\n        const key = (k || '').trim().toLowerCase();\n        if (!url) continue;\n        if (key === 'в' || key === 'video') out.push({ type:'video', url });\n        else out.push({ type:'photo', url });\n      } else {\n        out.push({ type:'photo', url: ln });\n      }\n    }\n    return out;\n  }\n\n  function formatTextByParseMode(text, parseMode){\n    return String(text ?? '');\n  }\n\n  // ---- load json\n  let raw;\n  try {\n    raw = await fetch('/smmcontent/content-plan.json?_=' + Date.now(), { cache: 'no-store' }).then(r => r.json());\n  } catch (e) {\n    document.getElementById('wrap').innerHTML =\n      '<div class=\"error\">Не удалось загрузить /smmcontent/content-plan.json\\\\n' + escapeHtml(e) + '</div>';\n    return;\n  }\n\n  const data =\n    Array.isArray(raw) ? (raw[0]?.data ?? raw[0]) : (raw?.data ?? raw);\n\n  if (!data || !data.generated_at_utc || !Array.isArray(data.items)) {\n    document.getElementById('wrap').innerHTML =\n      '<div class=\"error\">' +\n      'Ошибка формата content-plan.json.\\\\n\\\\n' +\n      'Нужно: { generated_at_utc, days_ahead, items[] }\\\\n\\\\n' +\n      'Фактически:\\\\n' +\n      escapeHtml(JSON.stringify(raw, null, 2).slice(0, 1500)) +\n      '</div>';\n    return;\n  }\n\n  document.getElementById('gen').textContent =\n    String(data.generated_at_utc).replace('T',' ').slice(0,19) + ' UTC';\n  document.getElementById('daysFile').textContent = data.days_ahead;\n\n  const itemsAll = data.items;\n  const storesCatalogAll = Array.isArray(data.stores_catalog) ? data.stores_catalog : [];\n  const postsCatalog = (data.posts_catalog && typeof data.posts_catalog === 'object') ? data.posts_catalog : {};\n\n  const storeById = new Map();\n  for (const s of storesCatalogAll) {\n    storeById.set(Number(s.store_id), {\n      store_id: Number(s.store_id),\n      name: String(s.name ?? '').trim() || ('#' + s.store_id),\n      region: Number(s.region),\n    });\n  }\n\n  const regionSel = document.getElementById('region');\n  const startInput = document.getElementById('startDate');\n  const periodSel = document.getElementById('period');\n  const btnToday = document.getElementById('btnToday');\n\n  const storesListEl = document.getElementById('storesList');\n  const storesHintEl = document.getElementById('storesHint');\n  const btnAll = document.getElementById('btnAll');\n  const btnNone = document.getElementById('btnNone');\n\n  // portal tip\n  const portalTip = document.getElementById('portalTip');\n  const ptCount = document.getElementById('ptCount');\n  const ptList = document.getElementById('ptList');\n  let tipHideTimer = null;\n\n  function hidePortalTip(){\n    portalTip.classList.remove('show');\n  }\n  function scheduleHideTip(){\n    clearTimeout(tipHideTimer);\n    tipHideTimer = setTimeout(() => hidePortalTip(), 80);\n  }\n  function cancelHideTip(){\n    clearTimeout(tipHideTimer);\n  }\n  portalTip.addEventListener('mouseenter', cancelHideTip);\n  portalTip.addEventListener('mouseleave', scheduleHideTip);\n\n  // modal\n  const modal = document.getElementById('modal');\n  const mClose = document.getElementById('mClose');\n  const mSub = document.getElementById('mSub');\n  const mTime = document.getElementById('mTime');\n  const mText = document.getElementById('mText');\n  const mMedia = document.getElementById('mMedia');\n  const mErr = document.getElementById('mErr');\n\n  function openModal(){ modal.classList.add('open'); }\n  function closeModal(){ modal.classList.remove('open'); }\n  mClose.addEventListener('click', closeModal);\n  modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });\n  window.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeModal(); });\n\n  periodSel.innerHTML = Array.from({length:14}, (_,i)=>i+1)\n    .map(n => '<option value=\"'+n+'\">'+n+' дн.</option>')\n    .join('');\n  periodSel.value = '14';\n\n  const regions = Array.from(new Set(itemsAll.map(x => x.region))).sort((a,b)=>a-b);\n  regionSel.innerHTML = regions.map(r => '<option value=\"'+r+'\">'+r+'</option>').join('');\n  regionSel.value = String(regions[0] ?? '');\n\n  const todayYmd = ymdFromDateLocal(new Date());\n  startInput.value = todayYmd;\n\n  btnToday.addEventListener('click', () => {\n    startInput.value = ymdFromDateLocal(new Date());\n    render();\n  });\n\n  regionSel.addEventListener('change', () => {\n    rebuildStoresUI();\n    render();\n  });\n\n  startInput.addEventListener('change', render);\n  periodSel.addEventListener('change', render);\n\n  btnAll.addEventListener('click', () => {\n    for (const cb of storesListEl.querySelectorAll('input[type=\"checkbox\"]')) cb.checked = true;\n    render();\n  });\n\n  btnNone.addEventListener('click', () => {\n    for (const cb of storesListEl.querySelectorAll('input[type=\"checkbox\"]')) cb.checked = false;\n    render();\n  });\n\n  storesListEl.addEventListener('change', render);\n\n  function getSelectedStoreIds(){\n    const ids = [];\n    for (const cb of storesListEl.querySelectorAll('input[type=\"checkbox\"]')) {\n      if (cb.checked) ids.push(Number(cb.value));\n    }\n    return ids;\n  }\n\n  function rebuildStoresUI(){\n    const region = Number(regionSel.value);\n\n    const stores = storesCatalogAll\n      .filter(s => Number(s.region) === region)\n      .map(s => ({ store_id: Number(s.store_id), name: String(s.name ?? '').trim() || ('#' + s.store_id) }))\n      .sort((a,b)=>a.store_id-b.store_id);\n\n    storesListEl.innerHTML = stores.map(s => {\n      const id = Number(s.store_id);\n      const name = escapeHtml(s.name);\n      return '<label class=\"storeItem\">' +\n        '<input type=\"checkbox\" value=\"'+id+'\" checked />' +\n        '<span>'+name+'</span>' +\n      '</label>';\n    }).join('');\n\n    storesHintEl.textContent = stores.length ? ('в регионе: ' + stores.length) : 'в регионе: 0';\n  }\n\n  function showPortalTipForItem(itemEl, storeNamesArr){\n    const rect = itemEl.getBoundingClientRect();\n\n    ptCount.textContent = String(storeNamesArr.length);\n\n    ptList.innerHTML = (storeNamesArr.length ? storeNamesArr : ['—'])\n      .map(n => '<li>' + escapeHtml(n) + '</li>')\n      .join('');\n\n    const gap = 10;\n    const vw = window.innerWidth;\n    const vh = window.innerHeight;\n\n    const tipW = Math.min(520, Math.floor(vw * 0.86));\n    portalTip.style.width = tipW + 'px';\n\n    portalTip.style.left = '0px';\n    portalTip.style.top = '0px';\n    portalTip.classList.add('show');\n\n    const tipRect = portalTip.getBoundingClientRect();\n    const tipH = tipRect.height;\n\n    let left = rect.left;\n    left = Math.max(8, Math.min(left, vw - tipW - 8));\n\n    let top = rect.bottom + gap;\n    if (top + tipH > vh - 8) {\n      top = rect.top - gap - tipH;\n      top = Math.max(8, top);\n    }\n\n    portalTip.style.left = left + 'px';\n    portalTip.style.top = top + 'px';\n  }\n\n  function bindPostHoverHighlightsAndTooltip(selectedSet, storeById){\n    const wrap = document.getElementById('wrap');\n\n    wrap.onmouseover = (ev) => {\n      const el = ev.target.closest('.item[data-post-id]');\n      if (!el) return;\n      const pid = el.getAttribute('data-post-id');\n      if (!pid) return;\n\n      const sel = '.item[data-post-id=\"'+CSS.escape(pid)+'\"]';\n      for (const same of wrap.querySelectorAll(sel)) same.classList.add('pid-hover');\n\n      cancelHideTip();\n      const idsJson = el.getAttribute('data-store-ids') || '[]';\n      let ids = [];\n      try { ids = JSON.parse(idsJson); } catch(e) { ids = []; }\n      const shownIds = (Array.isArray(ids) ? ids : []).map(Number).filter(id => selectedSet.has(id));\n      const storeNamesArr = shownIds.map(id => storeById.get(id)?.name || ('#' + id));\n      showPortalTipForItem(el, storeNamesArr);\n    };\n\n    wrap.onmouseout = (ev) => {\n      const el = ev.target.closest('.item[data-post-id]');\n      if (!el) return;\n      const pid = el.getAttribute('data-post-id');\n      if (!pid) return;\n\n      const sel = '.item[data-post-id=\"'+CSS.escape(pid)+'\"]';\n      for (const same of wrap.querySelectorAll(sel)) same.classList.remove('pid-hover');\n\n      scheduleHideTip();\n    };\n\n    wrap.onclick = (ev) => {\n      const el = ev.target.closest('.item[data-post-id]');\n      if (!el) return;\n      const pid = el.getAttribute('data-post-id');\n      if (!pid) return;\n\n      const title = el.getAttribute('data-title') || ('#' + pid);\n      const localdt = el.getAttribute('data-localdt') || '';\n      showPreview(pid, title, localdt);\n    };\n\n    window.addEventListener('scroll', () => hidePortalTip(), true);\n    window.addEventListener('resize', () => hidePortalTip());\n  }\n\n  function showPreview(pid, title, localdt){\n    const p = postsCatalog[String(pid)] || postsCatalog[String(Number(pid))];\n\n    mSub.textContent = (title ? title : ('#' + pid)) + ' · #' + pid;\n    mTime.textContent = localdt || '—';\n\n    mErr.style.display = 'none';\n    mErr.textContent = '';\n\n    if (!p) {\n      mText.textContent = 'Нет данных поста в posts_catalog для post_id=' + pid + '.\\\\n\\\\nПроверь, что Build Content Plan пишет posts_catalog в content-plan.json.';\n      mMedia.style.display = 'none';\n      mMedia.innerHTML = '';\n      openModal();\n      return;\n    }\n\n    mText.textContent = formatTextByParseMode(p.text, p.parse_mode);\n\n    const media = parseMediaLines(p.media_url);\n    mMedia.innerHTML = '';\n    if (!media.length){\n      mMedia.style.display = 'none';\n    } else {\n      mMedia.style.display = 'grid';\n      mMedia.className = 'tgMedia ' + (media.length === 1 ? 'one' : 'grid');\n\n      const show = media;\n      for (const m of show) {\n        const box = document.createElement('div');\n        box.className = 'tgMediaItem';\n\n        const badge = document.createElement('div');\n        badge.className = 'tgBadge';\n        badge.textContent = (m.type === 'video') ? 'Видео' : 'Фото';\n        box.appendChild(badge);\n\n        if (m.type === 'video') {\n          const v = document.createElement('video');\n          v.src = m.url;\n          v.controls = true;\n          v.preload = 'metadata';\n          box.appendChild(v);\n        } else {\n          const img = document.createElement('img');\n          img.src = m.url;\n          img.loading = 'lazy';\n          img.alt = '';\n          box.appendChild(img);\n        }\n\n        mMedia.appendChild(box);\n      }\n    }\n\n    openModal();\n  }\n\n  function render(){\n    const region = Number(regionSel.value);\n    const startYmd = startInput.value || todayYmd;\n\n    let period = Number(periodSel.value || 14);\n    if (!period || period < 1) period = 1;\n    if (period > 14) period = 14;\n\n    const endYmd = addDaysLocal(startYmd, period - 1);\n\n    const colDates = [];\n    for (let i = 0; i < period; i++) colDates.push(addDaysLocal(startYmd, i));\n\n    const selectedStoreIds = getSelectedStoreIds();\n    const selectedSet = new Set(selectedStoreIds);\n\n    const items = itemsAll\n      .filter(it => Number(it.region) === region)\n      .map(it => {\n        const ymd = getItemDateYmd(it);\n        const hhmm = getItemTimeHHMM(it);\n        return { ...it, _ymd: ymd, _hhmm: hhmm };\n      })\n      .filter(it =>\n        it._ymd && it._hhmm &&\n        it._ymd >= startYmd && it._ymd <= endYmd &&\n        (selectedSet.size > 0 ? intersectStoreIds(it.store_ids, selectedSet) : false)\n      );\n\n    const times = Array.from(new Set(items.map(x => x._hhmm))).sort();\n\n    const map = {};\n    for (const t of times) {\n      map[t] = {};\n      for (const d of colDates) map[t][d] = [];\n    }\n\n    for (const it of items) {\n      if (map[it._hhmm] && map[it._hhmm][it._ymd]) {\n        map[it._hhmm][it._ymd].push(it);\n      }\n    }\n\n    for (const t of times) {\n      for (const d of colDates) {\n        map[t][d].sort((a,b) => Number(a.post_id||0) - Number(b.post_id||0));\n      }\n    }\n\n    const headCols = colDates.map(d => {\n      const dow = dowRuFromYmd(d);\n      const dateLabel = ddmm(d);\n      return '<th><div class=\"colHead\"><div class=\"colDow\">'+dow+'</div><div class=\"colDate\">'+dateLabel+'</div></div></th>';\n    }).join('');\n\n    const bodyRows = times.map(t => {\n      const cols = colDates.map(d => {\n        const arr = map[t][d] || [];\n        if (!arr.length) return '<td></td>';\n\n        return '<td>' + arr.map(x => {\n          const title = escapeHtml(x.title ?? '');\n          const pid = String(x.post_id ?? x.id ?? '');\n          const pidEsc = escapeHtml(pid);\n          const localdt = escapeHtml(x.local_dt ?? (x._ymd + ' ' + (x.local_time || (t+':00'))) );\n\n          const ids = Array.isArray(x.store_ids) ? x.store_ids.map(Number) : [];\n          const shownIds = ids.filter(id => selectedSet.has(id));\n          const countStores = shownIds.length;\n\n          const hue = hueFromPostId(pid);\n\n          const isOnce = (x && (x.kind === 'once' || x.source === 'publish_at' || x.is_once === true || x._kind === 'once'));\n          const chipClass = 'itemChip' + (isOnce ? ' once' : '');\n          const chipText = (isOnce ? 'Разовый · ' : '') + countStores + ' пункт(ов)';\n\n          return '<div class=\"item pid-colored\" data-post-id=\"'+pidEsc+'\" data-title=\"'+title+'\" data-localdt=\"'+localdt+'\" data-store-ids=\"'+escapeHtml(JSON.stringify(ids))+'\" style=\"--pid-h:'+hue+'\">' +\n            '<div class=\"itemTitle\">' + title + '</div>' +\n            '<div class=\"itemMeta\">#' + pidEsc + ' · ' + localdt + '</div>' +\n            '<div class=\"'+chipClass+'\">' + chipText + '</div>' +\n          '</div>';\n        }).join('') + '</td>';\n      }).join('');\n\n      return '<tr><td class=\"time\">' + t + '</td>' + cols + '</tr>';\n    }).join('');\n\n    const summary = '<div class=\"muted\" style=\"margin:8px 0 10px 0;\">Период: ' +\n      ddmmyyyy(startYmd) + ' — ' + ddmmyyyy(endYmd) +\n      ' · колонки: ' + period +\n      ' · выбрано пунктов: ' + selectedStoreIds.length +\n      '</div>';\n\n    if (selectedStoreIds.length === 0) {\n      document.getElementById('wrap').innerHTML =\n        summary + '<div class=\"error\">Выберите хотя бы один пункт выдачи.</div>';\n      hidePortalTip();\n      return;\n    }\n    if (!times.length) {\n      document.getElementById('wrap').innerHTML =\n        summary + '<div class=\"error\">Нет событий в выбранном периоде/регионе/пунктах.</div>';\n      hidePortalTip();\n      return;\n    }\n\n    const tableHtml =\n      '<div class=\"tableWrap\">' +\n        '<table>' +\n          '<thead><tr><th>Время</th>' + headCols + '</tr></thead>' +\n          '<tbody>' + (bodyRows || '') + '</tbody>' +\n        '</table>' +\n      '</div>';\n\n    \n    // --- Mobile accordion by days ---\n    const mobileHtml =\n      '<div class=\"mobileAcc\">' +\n        colDates.map(d => {\n          const dow = dowRuFromYmd(d);\n          const dateLabel = ddmm(d);\n\n          // collect times with items for this day\n          const dayTimes = times.filter(t => (map[t] && map[t][d] && map[t][d].length));\n          if (!dayTimes.length) return '';\n\n          const timeBlocks = dayTimes.map(t => {\n            const arr = map[t][d] || [];\n            const itemsHtml = arr.map(x => {\n              const title = escapeHtml(x.title ?? '');\n              const pid = String(x.post_id ?? x.id ?? '');\n              const pidEsc = escapeHtml(pid);\n              const localdt = escapeHtml(x.local_dt ?? (x._ymd + ' ' + (x.local_time || (t+':00'))) );\n\n              const ids = Array.isArray(x.store_ids) ? x.store_ids.map(Number) : [];\n              const shownIds = ids.filter(id => selectedSet.has(id));\n              const countStores = shownIds.length;\n\n              const hue = hueFromPostId(pid);\n\n              const isOnce = (x && (x.kind === 'once' || x.source === 'publish_at' || x.is_once === true || x._kind === 'once'));\n              const chipClass = 'itemChip' + (isOnce ? ' once' : '');\n              const chipText = (isOnce ? 'Разовый · ' : '') + countStores + ' пункт(ов)';\n\n              return '<div class=\"item pid-colored\" data-post-id=\"'+pidEsc+'\" data-title=\"'+title+'\" data-localdt=\"'+localdt+'\" data-store-ids=\"'+escapeHtml(JSON.stringify(ids))+'\" style=\"--pid-h:'+hue+'\">' +\n                '<div class=\"itemTitle\">' + title + '</div>' +\n                '<div class=\"itemMeta\">#' + pidEsc + ' · ' + localdt + '</div>' +\n                '<div class=\"'+chipClass+'\">' + chipText + '</div>' +\n              '</div>';\n            }).join('');\n\n            return '<div class=\"accTime\">' +\n              '<div class=\"accTimeHead\">' + t + '</div>' +\n              '<div class=\"accItems\">' + (itemsHtml || '') + '</div>' +\n            '</div>';\n          }).join('');\n\n          const openClass = (d === startYmd) ? ' open' : '';\n          return '<div class=\"accDay'+openClass+'\" data-day=\"'+escapeHtml(d)+'\">' +\n            '<div class=\"accHead\" role=\"button\" tabindex=\"0\" aria-expanded=\"'+(d===startYmd ? 'true' : 'false')+'\">' +\n              '<div class=\"accHeadLeft\">' +\n                '<div class=\"accDow\">'+dow+'</div>' +\n                '<div class=\"accDate\">'+dateLabel+'</div>' +\n              '</div>' +\n              '<div class=\"accChevron\" aria-hidden=\"true\">▾</div>' +\n            '</div>' +\n            '<div class=\"accBody\">' + (timeBlocks || '') + '</div>' +\n          '</div>';\n        }).join('') +\n      '</div>';\n\n    const wrapEl = document.getElementById('wrap');\n    const isMobile = window.matchMedia && window.matchMedia('(max-width: 900px)').matches;\n\n    wrapEl.innerHTML = summary + (isMobile ? mobileHtml : tableHtml);\n\n    // accordion interactions (mobile)\n    if (isMobile) {\n      const toggle = (dayEl) => {\n        const isOpen = dayEl.classList.toggle('open');\n        const head = dayEl.querySelector('.accHead');\n        if (head) head.setAttribute('aria-expanded', isOpen ? 'true' : 'false');\n      };\n\n      for (const head of wrapEl.querySelectorAll('.accHead')) {\n        head.addEventListener('click', () => {\n          const dayEl = head.closest('.accDay');\n          if (dayEl) toggle(dayEl);\n        });\n        head.addEventListener('keydown', (e) => {\n          if (e.key === 'Enter' || e.key === ' ') {\n            e.preventDefault();\n            const dayEl = head.closest('.accDay');\n            if (dayEl) toggle(dayEl);\n          }\n        });\n      }\n    }\n\n    bindPostHoverHighlightsAndTooltip(selectedSet, storeById);\n}\n\n  rebuildStoresUI();\n  render();\n\n  // Re-render on breakpoint change (desktop <-> mobile) to switch table/accordion\n  if (window.matchMedia) {\n    const mq = window.matchMedia('(max-width: 900px)');\n    const onMq = () => { try { render(); } catch(e){} };\n    if (typeof mq.addEventListener === 'function') mq.addEventListener('change', onMq);\n    else if (typeof mq.addListener === 'function') mq.addListener(onMq);\n  }\n})();\n</script>\n\n</body>\n</html>`\n    }\n  }\n];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[4528,1584],"id":"6280e6fc-5e52-4aab-8fd9-12ba4f2241cd","name":"Build HTML"},{"parameters":{"operation":"write","fileName":"/data/smmcontent/index.html","options":{}},"type":"n8n-nodes-base.readWriteFile","typeVersion":1.1,"position":[5040,1584],"id":"2d335b01-3686-4865-8f56-29b8bb50743c","name":"Read/Write Files from Disk1"},{"parameters":{"jsCode":"const html = $json.html;\n\nconst buffer = Buffer.from(html, 'utf8');\n\nreturn [\n  {\n    binary: {\n      data: {\n        data: buffer,\n        mimeType: 'text/html',\n        fileName: 'index.html',\n      },\n    },\n  },\n];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[4768,1584],"id":"99ebb400-130f-41e6-bca6-62c669e4c825","name":"Code (Text → Binary)","onError":"continueRegularOutput"}],"connections":{"When clicking ‘Execute workflow’":{"main":[[{"node":"Get row(s) in sheet","type":"main","index":0},{"node":"PG Stores","type":"main","index":0}]]},"Get row(s) in sheet":{"main":[[{"node":"Filter","type":"main","index":0}]]},"Filter":{"main":[[{"node":"Barrier: Posts + Stores","type":"main","index":0}]]},"Build Content Plan":{"main":[[{"node":"Convert to File","type":"main","index":0},{"node":"Build HTML","type":"main","index":0}]]},"Convert to File":{"main":[[{"node":"Read/Write Files from Disk","type":"main","index":0}]]},"PG Stores":{"main":[[{"node":"Barrier: Posts + Stores","type":"main","index":1}]]},"Barrier: Posts + Stores":{"main":[[{"node":"Build Content Plan","type":"main","index":0}]]},"Schedule Trigger":{"main":[[{"node":"Get row(s) in sheet","type":"main","index":0},{"node":"PG Stores","type":"main","index":0}]]},"Build HTML":{"main":[[{"node":"Code (Text → Binary)","type":"main","index":0}]]},"Code (Text → Binary)":{"main":[[{"node":"Read/Write Files from Disk1","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","availableInMCP":false},"staticData":{"node:Schedule Trigger":{"recurrenceRules":[]}},"meta":{"templateCredsSetupCompleted":true},"pinData":{},"versionId":"d2dfc90f-bc61-4a5f-a9ea-a5e5ab8e9f4c","activeVersionId":"d2dfc90f-bc61-4a5f-a9ea-a5e5ab8e9f4c","versionCounter":31,"triggerCount":1,"tags":[],"shared":[{"updatedAt":"2026-01-17T15:57:41.916Z","createdAt":"2026-01-17T15:57:41.916Z","role":"workflow:owner","workflowId":"nYtWLQMPCPdUAsaT","projectId":"pN1dQC2QTiUB8OxN","project":{"updatedAt":"2026-01-03T09:50:23.589Z","createdAt":"2026-01-02T11:57:57.457Z","id":"pN1dQC2QTiUB8OxN","name":"Ilya Sukharev <retail.sukharev@yandex.ru>","type":"personal","icon":null,"description":null,"creatorId":"a8327288-747a-47c3-9f5f-b2070eff6d8c"}}]},{"updatedAt":"2026-02-13T15:32:30.000Z","createdAt":"2026-02-11T07:00:51.288Z","id":"ch28aD9cVPTAMGNd","name":"My workflow 2","description":null,"active":false,"isArchived":true,"nodes":[{"parameters":{},"type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[-368,96],"id":"d80c5f98-02c7-4d6b-9557-b1a6edc6f60d","name":"When clicking ‘Execute workflow’"},{"parameters":{"method":"POST","url":"https://platform-api.max.ru/messages","sendQuery":true,"queryParameters":{"parameters":[{"name":"chat_id","value":"-70960394824245"}]},"sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"f9LHodD0cOIrOKvR8Ce9CO249up2b9d1pJ-iF5OieiU3so5i0yTfmAmFw8WdhlFAykn4WfHG7XQHUBuUb6Iq"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"specifyBody":"json","jsonBody":"={{$json}}","options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[1504,208],"id":"a42af0ef-b370-4343-985b-a479cd3cbc8b","name":"Send Message1"},{"parameters":{"method":"POST","url":"https://platform-api.max.ru/uploads","sendQuery":true,"queryParameters":{"parameters":[{"name":"type","value":"image"}]},"sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"f9LHodD0cOIrOKvR8Ce9CO249up2b9d1pJ-iF5OieiU3so5i0yTfmAmFw8WdhlFAykn4WfHG7XQHUBuUb6Iq"}]},"options":{"response":{"response":{"responseFormat":"json"}}}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[464,64],"id":"8a873dab-fff4-4e88-873c-0db100f89f8e","name":"Узел A1","retryOnFail":true,"maxTries":5,"waitBetweenTries":2000},{"parameters":{"method":"POST","url":"={{ $('Узел A1').item.json.url }}","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Expect"}]},"sendBody":true,"contentType":"multipart-form-data","bodyParameters":{"parameters":[{"parameterType":"formBinaryData","name":"data","inputDataFieldName":"data"}]},"options":{"response":{"response":{"responseFormat":"json"}}}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[976,224],"id":"af3cac0c-76b1-4e58-aa60-7f655d4210bd","name":"Узел C1"},{"parameters":{"url":"={{ $json.url }}\n","options":{"redirect":{"redirect":{}},"response":{"response":{"responseFormat":"file"}}}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[480,352],"id":"361906c5-711e-4a28-bca3-e8f6387cd39c","name":"Узел B1"},{"parameters":{"mode":"combine","combineBy":"combineByPosition","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[752,224],"id":"ec330aa6-e5d8-421f-a202-8c6248ff8509","name":"Merge1","onError":"continueRegularOutput"},{"parameters":{"jsCode":"const text = `https://storage.mwsapis.ru/auto-post/%D0%9D%D0%9E%D0%92%D0%9E%D0%A1%D0%98%D0%91%D0%98%D0%A0%D0%A1%D0%9A/%D0%A7%D0%B5%D1%87%D0%B5%D1%82%D0%BA%D0%B0/107%20%D0%BC%D1%80%D0%B0%D0%BC%D0%BE%D1%80%D0%BD%D0%B0%D1%8F%20%D0%B3%D0%BE%D0%B2%D1%8F%D0%B4%D0%B8%D0%BD%D0%B0/%D0%B0%D0%BD%D1%82%D1%80%D0%B5%D0%BA%D0%BE%D1%82%20%D0%B8%20%D0%BB%D0%BE%D0%BF%D0%B0%D1%82%D0%BA%D0%B0.jpg\nhttps://storage.mwsapis.ru/auto-post/%D0%9D%D0%9E%D0%92%D0%9E%D0%A1%D0%98%D0%91%D0%98%D0%A0%D0%A1%D0%9A/%D0%A7%D0%B5%D1%87%D0%B5%D1%82%D0%BA%D0%B0/107%20%D0%BC%D1%80%D0%B0%D0%BC%D0%BE%D1%80%D0%BD%D0%B0%D1%8F%20%D0%B3%D0%BE%D0%B2%D1%8F%D0%B4%D0%B8%D0%BD%D0%B0/%D0%B3%D1%80%D1%83%D0%B4%D0%B8%D0%BD%D0%BA%D0%B0.jpg\nhttps://storage.mwsapis.ru/auto-post/%D0%9D%D0%9E%D0%92%D0%9E%D0%A1%D0%98%D0%91%D0%98%D0%A0%D0%A1%D0%9A/%D0%A7%D0%B5%D1%87%D0%B5%D1%82%D0%BA%D0%B0/107%20%D0%BC%D1%80%D0%B0%D0%BC%D0%BE%D1%80%D0%BD%D0%B0%D1%8F%20%D0%B3%D0%BE%D0%B2%D1%8F%D0%B4%D0%B8%D0%BD%D0%B0/%D0%B4%D1%8B%D0%B5%20%D0%BC%D1%8F%D0%BA%D0%BE%D1%82%D0%B8.jpg`;\n\nconst urls = text\n  .split(/\\r?\\n/)\n  .map(s => s.trim())\n  .filter(Boolean);\n\nreturn urls.map(url => ({ json: { url } }));\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[48,160],"id":"ce542c23-1f4c-4123-a309-d1875e5241cc","name":"Code in JavaScript"},{"parameters":{"jsCode":"const items = $input.all();\n\n// собрали токены картинок из it.json.photos\nconst tokens = [];\n\nfor (const it of items) {\n  const photos = it.json.photos;\n  if (!photos) continue;\n\n  for (const v of Object.values(photos)) {\n    if (v?.token) tokens.push(v.token);\n  }\n}\n\nreturn [{\n  json: {\n    text: \"Отчёт за день 📦\",\n    format: \"markdown\",\n    notify: true,\n    attachments: [\n      ...tokens.map(t => ({\n        type: \"image\",\n        payload: { token: t }\n      })),\n\n      // ✅ кнопки как inline_keyboard\n      {\n        type: \"inline_keyboard\",\n        payload: {\n          buttons: [\n            [{ type: \"link\", text: \"Открыть каталог\", url: \"https://koptorg.ru:7026\" }],\n            [{ type: \"link\", text: \"Сделать заказ\", url: \"https://koptorg.ru:7026\" }],\n          ]\n        }\n      }\n    ]\n  }\n}];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[1184,224],"id":"9e1cbbce-5d63-4f19-9072-716e3209a48a","name":"Code in JavaScript1"},{"parameters":{"method":"POST","url":"https://platform-api.max.ru/messages","sendQuery":true,"queryParameters":{"parameters":[{"name":"chat_id","value":"-70960394824245"}]},"sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"f9LHodD0cOIrOKvR8Ce9CO249up2b9d1pJ-iF5OieiU3so5i0yTfmAmFw8WdhlFAykn4WfHG7XQHUBuUb6Iq"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"specifyBody":"json","jsonBody":"={{$json}}","options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[1344,704],"id":"17a89a83-e8f1-4471-bf8e-78a93553fa76","name":"Send Message"},{"parameters":{"method":"POST","url":"https://platform-api.max.ru/uploads","sendQuery":true,"queryParameters":{"parameters":[{"name":"type","value":"={{$json.uploadType}}\n\n"}]},"sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"f9LHodD0cOIrOKvR8Ce9CO249up2b9d1pJ-iF5OieiU3so5i0yTfmAmFw8WdhlFAykn4WfHG7XQHUBuUb6Iq"}]},"options":{"response":{"response":{"responseFormat":"json"}}}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[304,560],"id":"0149d488-2805-46f2-a2df-e3837f5b50e9","name":"Узел A","retryOnFail":true,"maxTries":5,"waitBetweenTries":2000},{"parameters":{"method":"POST","url":"={{ $('Узел A').item.json.url }}","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Expect"}]},"sendBody":true,"contentType":"multipart-form-data","bodyParameters":{"parameters":[{"parameterType":"formBinaryData","name":"data","inputDataFieldName":"data"}]},"options":{"response":{"response":{"responseFormat":"text"}}}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[816,720],"id":"8dfbc0f7-1e8c-43e5-973d-4154999cffb3","name":"Узел C"},{"parameters":{"url":"={{ $json.url }}\n","options":{"redirect":{"redirect":{}},"response":{"response":{"responseFormat":"file"}}}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[320,848],"id":"3677d3ee-bb6b-4cb2-b869-6ce90ccc2a0c","name":"Узел B"},{"parameters":{"mode":"combine","combineBy":"combineByPosition","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[592,720],"id":"d2dc2fdb-1914-4986-b52f-928ae9541fa7","name":"Merge","onError":"continueRegularOutput"},{"parameters":{"jsCode":"const text = `https://storage.mwsapis.ru/auto-post/%D0%9D%D0%9E%D0%92%D0%9E%D0%A1%D0%98%D0%91%D0%98%D0%A0%D0%A1%D0%9A/%D0%A2%D1%80%D0%B5%D1%82%D1%8C%D1%8F%D0%BA%D0%BE%D0%B2%D0%B0%20%D0%BC%D1%8F%D1%81%D0%BE/117%20%D1%85%D0%BE%D0%BB%D0%BE%D0%B4%D0%B5%D1%86/3%20%D1%85%D0%BE%D0%BB%D0%BE%D0%B4%D0%B5%D1%86%20%D0%B2%D0%B1%D0%BB%D0%B8%D0%B7%D0%B8%202.jpg\nhttps://storage.mwsapis.ru/auto-post/%D0%9D%D0%9E%D0%92%D0%9E%D0%A1%D0%98%D0%91%D0%98%D0%A0%D0%A1%D0%9A/%D0%A2%D1%80%D0%B5%D1%82%D1%8C%D1%8F%D0%BA%D0%BE%D0%B2%D0%B0%20%D0%BC%D1%8F%D1%81%D0%BE/117%20%D1%85%D0%BE%D0%BB%D0%BE%D0%B4%D0%B5%D1%86/4%20%D0%BE%D1%82%D0%B7%D1%8B%D0%B2%D1%8B.jpg\nhttps://storage.mwsapis.ru/auto-post/%D0%9D%D0%9E%D0%92%D0%9E%D0%A1%D0%98%D0%91%D0%98%D0%A0%D0%A1%D0%9A/%D0%A2%D1%80%D0%B5%D1%82%D1%8C%D1%8F%D0%BA%D0%BE%D0%B2%D0%B0%20%D0%BC%D1%8F%D1%81%D0%BE/117%20%D1%85%D0%BE%D0%BB%D0%BE%D0%B4%D0%B5%D1%86/5%D0%B2%D0%B8%D0%B4%D0%B5%D0%BE%D1%85%D0%BE%D0%BB%D0%BE%D0%B4%D0%B5%D1%86.mp4`;\n\nconst urls = text.split(/\\r?\\n/).map(s => s.trim()).filter(Boolean);\n\nfunction detectType(url) {\n  const u = url.toLowerCase();\n  if (u.endsWith('.mp4') || u.endsWith('.mov') || u.endsWith('.webm')) return 'video';\n  if (u.endsWith('.mp3') || u.endsWith('.wav') || u.endsWith('.ogg')) return 'audio';\n  return 'image';\n}\n\nreturn urls.map(url => ({\n  json: {\n    url,\n    uploadType: detectType(url),          // <-- то, что пойдёт в /uploads?type=\n    attachmentType: detectType(url),      // <-- то, что пойдёт в attachments[].type\n  }\n}));\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-112,656],"id":"d46f6550-6bde-44fe-aa77-6f12fb98d7a3","name":"Code in JavaScript2"},{"parameters":{"jsCode":"const items = $input.all();\n\nfunction getUploadType(it) {\n  return (it.json.attachmentType || it.json.uploadType || '').toLowerCase();\n}\n\nfunction extractToken(it) {\n  // ВИДЕО/АУДИО: токен обычно приходит из /uploads (узел A)\n  // после Merge он часто лежит прямо в it.json.token\n  if (it.json.token) return it.json.token;\n\n  // КАРТИНКИ: токен часто лежит в it.json.photos (как у тебя было)\n  if (it.json.photos) {\n    for (const v of Object.values(it.json.photos)) {\n      if (v && v.token) return v.token;\n    }\n  }\n\n  // иногда бывает it.json.payload.token\n  if (it.json.payload?.token) return it.json.payload.token;\n\n  return null;\n}\n\nconst attachments = [];\n\nfor (const it of items) {\n  const type = getUploadType(it) || 'image';\n  const token = extractToken(it);\n  if (!token) continue;\n\n  attachments.push({\n    type,               // image | video | audio\n    payload: { token },\n  });\n}\n\nreturn [{\n  json: {\n    text: \"Отчёт за день 📦\",\n    format: \"markdown\",\n    notify: true,\n    attachments,\n  }\n}];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[1024,720],"id":"b0b3a8cd-f4a8-41af-8089-60462a721794","name":"Code in JavaScript3"}],"connections":{"When clicking ‘Execute workflow’":{"main":[[{"node":"Code in JavaScript","type":"main","index":0}]]},"Узел A1":{"main":[[{"node":"Merge1","type":"main","index":0}]]},"Узел C1":{"main":[[{"node":"Code in JavaScript1","type":"main","index":0}]]},"Узел B1":{"main":[[{"node":"Merge1","type":"main","index":1}]]},"Merge1":{"main":[[{"node":"Узел C1","type":"main","index":0}]]},"Code in JavaScript":{"main":[[{"node":"Узел A1","type":"main","index":0},{"node":"Узел B1","type":"main","index":0}]]},"Code in JavaScript1":{"main":[[{"node":"Send Message1","type":"main","index":0}]]},"Узел A":{"main":[[{"node":"Merge","type":"main","index":0}]]},"Узел C":{"main":[[{"node":"Code in JavaScript3","type":"main","index":0}]]},"Узел B":{"main":[[{"node":"Merge","type":"main","index":1}]]},"Merge":{"main":[[{"node":"Узел C","type":"main","index":0}]]},"Code in JavaScript2":{"main":[[{"node":"Узел A","type":"main","index":0},{"node":"Узел B","type":"main","index":0}]]},"Code in JavaScript3":{"main":[[{"node":"Send Message","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","availableInMCP":false},"staticData":null,"meta":null,"pinData":{},"versionId":"acd1e8a1-f6ce-458b-8fff-ae3b93df39f9","activeVersionId":null,"versionCounter":6,"triggerCount":0,"tags":[],"shared":[{"updatedAt":"2026-02-11T07:00:51.299Z","createdAt":"2026-02-11T07:00:51.299Z","role":"workflow:owner","workflowId":"ch28aD9cVPTAMGNd","projectId":"pN1dQC2QTiUB8OxN","project":{"updatedAt":"2026-01-03T09:50:23.589Z","createdAt":"2026-01-02T11:57:57.457Z","id":"pN1dQC2QTiUB8OxN","name":"Ilya Sukharev <retail.sukharev@yandex.ru>","type":"personal","icon":null,"description":null,"creatorId":"a8327288-747a-47c3-9f5f-b2070eff6d8c"}}]},{"updatedAt":"2026-02-11T18:25:10.499Z","createdAt":"2026-02-11T18:25:10.499Z","id":"TGyXdBFeqCMVQjAc","name":"MAX sending n media","description":null,"active":false,"isArchived":false,"nodes":[{"parameters":{},"type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[-272,-352],"id":"1a3cf000-8845-46b6-8739-c07420abb255","name":"When clicking ‘Execute workflow’"},{"parameters":{"method":"POST","url":"https://platform-api.max.ru/messages","sendQuery":true,"queryParameters":{"parameters":[{"name":"chat_id","value":"-70960394824245"}]},"sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"f9LHodD0cOIrOKvR8Ce9CO249up2b9d1pJ-iF5OieiU3so5i0yTfmAmFw8WdhlFAykn4WfHG7XQHUBuUb6Iq"},{"name":"Content-Type","value":"application/json"}]},"sendBody":true,"specifyBody":"json","jsonBody":"={\n  \"text\": \"Отчёт за день 📦\",\n  \"format\": \"markdown\",\n  \"notify\": true,\n  \"attachments\": [\n    {\n      \"type\": \"image\",\n      \"payload\": {\n        \"token\": \"{{$json.photos.values().last().token }}\"\n      }\n    }\n  ]\n}","options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[960,-336],"id":"b9ef0a7a-851b-406a-b9c8-2b417ee3d6d5","name":"Send Message"},{"parameters":{"method":"POST","url":"https://platform-api.max.ru/uploads","sendQuery":true,"queryParameters":{"parameters":[{"name":"type","value":"image"}]},"sendHeaders":true,"headerParameters":{"parameters":[{"name":"Authorization","value":"f9LHodD0cOIrOKvR8Ce9CO249up2b9d1pJ-iF5OieiU3so5i0yTfmAmFw8WdhlFAykn4WfHG7XQHUBuUb6Iq"}]},"options":{"response":{"response":{"responseFormat":"json"}}}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[144,-400],"id":"ab050fc2-f886-40f3-a270-904390743b92","name":"Узел A","retryOnFail":true,"maxTries":5,"waitBetweenTries":2000},{"parameters":{"method":"POST","url":"={{ $json.url }}","sendHeaders":true,"headerParameters":{"parameters":[{"name":"Expect"}]},"sendBody":true,"contentType":"multipart-form-data","bodyParameters":{"parameters":[{"parameterType":"formBinaryData","name":"data","inputDataFieldName":"data"}]},"options":{"response":{"response":{"responseFormat":"json"}}}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[640,-320],"id":"a559a72e-3984-44bb-83d0-92081bc554fc","name":"Узел C"},{"parameters":{"url":"https://storage.mwsapis.ru/auto-post/%D0%9D%D0%9E%D0%92%D0%9E%D0%A1%D0%98%D0%91%D0%98%D0%A0%D0%A1%D0%9A/%D0%A7%D0%B5%D1%87%D0%B5%D1%82%D0%BA%D0%B0/107%20%D0%BC%D1%80%D0%B0%D0%BC%D0%BE%D1%80%D0%BD%D0%B0%D1%8F%20%D0%B3%D0%BE%D0%B2%D1%8F%D0%B4%D0%B8%D0%BD%D0%B0/%D0%B0%D0%BD%D1%82%D1%80%D0%B5%D0%BA%D0%BE%D1%82%20%D0%B8%20%D0%BB%D0%BE%D0%BF%D0%B0%D1%82%D0%BA%D0%B0.jpg","options":{"redirect":{"redirect":{}},"response":{"response":{"responseFormat":"file"}}}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[144,-192],"id":"0b15da10-6be4-4247-9bdd-466f1f26e0ed","name":"Узел B"},{"parameters":{"mode":"combine","combineBy":"combineByPosition","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[416,-320],"id":"c08ddaa0-ba77-4f2d-a631-73813b7de782","name":"Merge","onError":"continueRegularOutput"}],"connections":{"When clicking ‘Execute workflow’":{"main":[[{"node":"Узел A","type":"main","index":0},{"node":"Узел B","type":"main","index":0}]]},"Send Message":{"main":[[]]},"Узел A":{"main":[[{"node":"Merge","type":"main","index":0}]]},"Узел B":{"main":[[{"node":"Merge","type":"main","index":1}]]},"Merge":{"main":[[{"node":"Узел C","type":"main","index":0}]]},"Узел C":{"main":[[{"node":"Send Message","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","availableInMCP":false},"staticData":null,"meta":null,"pinData":{},"versionId":"82005a7f-fdff-4e44-8083-61efae5298c5","activeVersionId":null,"versionCounter":3,"triggerCount":0,"tags":[],"shared":[{"updatedAt":"2026-02-11T18:25:10.504Z","createdAt":"2026-02-11T18:25:10.504Z","role":"workflow:owner","workflowId":"TGyXdBFeqCMVQjAc","projectId":"pN1dQC2QTiUB8OxN","project":{"updatedAt":"2026-01-03T09:50:23.589Z","createdAt":"2026-01-02T11:57:57.457Z","id":"pN1dQC2QTiUB8OxN","name":"Ilya Sukharev <retail.sukharev@yandex.ru>","type":"personal","icon":null,"description":null,"creatorId":"a8327288-747a-47c3-9f5f-b2070eff6d8c"}}]},{"updatedAt":"2026-02-13T15:32:40.624Z","createdAt":"2026-02-12T02:19:11.127Z","id":"P8k4WUwcsNTmZFFN","name":"MAX autopost with video","description":null,"active":false,"isArchived":false,"nodes":[{"parameters":{},"type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[-576,192],"id":"dfd503de-2206-4362-9a3b-4c94d3970d4a","name":"When clicking ‘Execute workflow’"},{"parameters":{"method":"POST","url":"https://platform-api.max.ru/messages","authentication":"genericCredentialType","genericAuthType":"httpHeaderAuth","sendQuery":true,"queryParameters":{"parameters":[{"name":"chat_id","value":"-70960394824245"}]},"sendBody":true,"specifyBody":"json","jsonBody":"={{$json}}","options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[2096,256],"id":"f4eed65b-26be-4350-a465-1778608bc414","name":"Send Message1","credentials":{"httpHeaderAuth":{"id":"EWKLZldey391MbFm","name":"MAX autopost"}}},{"parameters":{"method":"POST","url":"https://platform-api.max.ru/uploads","authentication":"genericCredentialType","genericAuthType":"httpHeaderAuth","sendQuery":true,"queryParameters":{"parameters":[{"name":"type","value":"={{ $json.mediaType }}"}]},"options":{"response":{"response":{"responseFormat":"json"}}}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[256,-32],"id":"2f5ee008-0def-4700-930d-9cdad352af05","name":"Узел A1","retryOnFail":true,"maxTries":5,"waitBetweenTries":2000,"credentials":{"httpHeaderAuth":{"id":"EWKLZldey391MbFm","name":"MAX autopost"}}},{"parameters":{"method":"POST","url":"={{$json.uploadUrl}}","sendBody":true,"contentType":"multipart-form-data","bodyParameters":{"parameters":[{"parameterType":"formBinaryData","name":"data","inputDataFieldName":"data"}]},"options":{"response":{"response":{"responseFormat":"text"}}}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[1232,240],"id":"db1372a7-edc3-4d88-a464-970e0ccdfa0e","name":"Узел C1"},{"parameters":{"url":"={{ $json.url }}","options":{"redirect":{"redirect":{}},"response":{"response":{"responseFormat":"file"}}}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[448,384],"id":"76b3e514-32f1-4353-8e67-871f987737e5","name":"Узел B1"},{"parameters":{"mode":"combine","combineBy":"combineByPosition","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[960,224],"id":"76b0425e-0f48-490d-bb30-1608f570c64d","name":"Merge1","onError":"continueRegularOutput"},{"parameters":{"jsCode":"// ВСТАВЬ СЮДА СВОЮ СТРОКУ (можно из поля/ячейки, но пока — константой)\nconst text = `в|https://storage.mwsapis.ru/auto-post/%D0%9D%D0%9E%D0%92%D0%9E%D0%A1%D0%98%D0%91%D0%98%D0%A0%D0%A1%D0%9A/%D0%92%D0%B0%D1%80%D0%B2%D1%8F%D0%BD%D1%81%D0%BA%D0%B8%D0%B9%20/102%20%D0%B2%D0%B0%D1%80%D0%B2%D1%8F%D0%BD%D1%81%D0%BA%D0%B8%D0%B9%20%D0%BA%D1%80%D0%BE%D0%BB%D0%B8%D0%BA/2%20otzyv%20lyubi.mp4 ф|https://storage.mwsapis.ru/auto-post/%D0%9D%D0%9E%D0%92%D0%9E%D0%A1%D0%98%D0%91%D0%98%D0%A0%D0%A1%D0%9A/%D0%92%D0%B0%D1%80%D0%B2%D1%8F%D0%BD%D1%81%D0%BA%D0%B8%D0%B9%20/102%20%D0%B2%D0%B0%D1%80%D0%B2%D1%8F%D0%BD%D1%81%D0%BA%D0%B8%D0%B9%20%D0%BA%D1%80%D0%BE%D0%BB%D0%B8%D0%BA/1%20%D1%82%D1%83%D1%88%D0%BA%D0%B0%20%D0%BA%D1%80%D0%BE%D0%BB%D0%B8%D0%BA%D0%B0%20%D1%81%20%D1%86%D0%B5%D0%BD%D0%BE%D0%B9.jpeg в|https://storage.mwsapis.ru/auto-post/%D0%9D%D0%9E%D0%92%D0%9E%D0%A1%D0%98%D0%91%D0%98%D0%A0%D0%A1%D0%9A/%D0%92%D0%B0%D1%80%D0%B2%D1%8F%D0%BD%D1%81%D0%BA%D0%B8%D0%B9%20/102%20%D0%B2%D0%B0%D1%80%D0%B2%D1%8F%D0%BD%D1%81%D0%BA%D0%B8%D0%B9%20%D0%BA%D1%80%D0%BE%D0%BB%D0%B8%D0%BA/3%20%D0%B3%D0%BE%D1%82%D0%BE%D0%B2%D1%8B%D0%B9%20%D0%BA%D1%80%D0%BE%D0%BB%D0%B8%D0%BA.mp4 ф|https://storage.mwsapis.ru/auto-post/%D0%9D%D0%9E%D0%92%D0%9E%D0%A1%D0%98%D0%91%D0%98%D0%A0%D0%A1%D0%9A/%D0%92%D0%B0%D1%80%D0%B2%D1%8F%D0%BD%D1%81%D0%BA%D0%B8%D0%B9%20/102%20%D0%B2%D0%B0%D1%80%D0%B2%D1%8F%D0%BD%D1%81%D0%BA%D0%B8%D0%B9%20%D0%BA%D1%80%D0%BE%D0%BB%D0%B8%D0%BA/4%20%D0%BA%D1%80%D0%BE%D0%BB%D0%B8%D0%BA%20%D0%B2%20%D1%81%D0%BA%D0%BE%D0%B2%D0%BE%D1%80%D0%BE%D0%B4%D0%BA%D0%B5.jpeg`;\n\nconst out = [];\nconst re = /(^|[\\s\\r\\n]+)\\+?\\s*([вфvf])\\|(\\S+)/gi;\n\nlet m;\nlet idx = 0;\nwhile ((m = re.exec(text)) !== null) {\n  const prefix = m[2].toLowerCase();\n  const url = m[3];\n  const mediaType = (prefix === 'в' || prefix === 'v') ? 'video' : 'image';\n  out.push({ json: { idx, mediaType, url } });\n  idx++;\n}\n\nreturn out;"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-256,208],"id":"a53b5c6c-1bb1-4c68-bf76-0f431e2864b8","name":"Code in JavaScript"},{"parameters":{"jsCode":"// 4 ответа из C1 (c1[i].json.data = строка)\nconst c1 = $items('Узел C1');\n\n// 4 строки из Merge1 (idx, mediaType, ...)\nconst m1 = $items('Merge1');\n\n// 4 ответа из A1 (там token для video)\nconst a1 = $items('Узел A1');\n\nreturn c1.map((c, i) => {\n  const resp = String(c.json?.data ?? '');\n  const base = m1[i]?.json ?? {};\n  const a1token = a1[i]?.json?.token ?? null;\n\n  // VIDEO: токен берём из A1\n  if (base.mediaType === 'video') {\n    return {\n      json: {\n        idx: base.idx,\n        mediaType: base.mediaType,\n        token: a1token,\n      }\n    };\n  }\n\n  // IMAGE: токен вытаскиваем из строки ответа C1\n  let token = null;\n  const m = resp.match(/\"token\"\\s*:\\s*\"([^\"]+)\"/);\n  if (m) token = m[1];\n\n  return {\n    json: {\n      idx: base.idx,\n      mediaType: base.mediaType,\n      token,\n    }\n  };\n});\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[1552,256],"id":"284939de-7f37-4bd7-b50d-be8642a59f3e","name":"Code in JavaScript1"},{"parameters":{"assignments":{"assignments":[{"id":"ba4a2eab-fa7e-4cee-864a-25eddcb9b65f","name":"uploadUrl","value":"={{$json.url}}","type":"string"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[640,-32],"id":"20154631-2ace-485f-a53e-3d1033bea136","name":"Edit Fields"},{"parameters":{"jsCode":"const items = $input.all().map(x => x.json);\n\n// порядок как в исходной строке\nitems.sort((a, b) => (a.idx ?? 0) - (b.idx ?? 0));\n\n// медиа-вложения\nconst mediaAttachments = items\n  .filter(x => x.token && x.mediaType)\n  .map(x => ({\n    type: x.mediaType,          // \"image\" или \"video\"\n    payload: { token: x.token }\n  }));\n\nreturn [{\n  json: {\n    text: \"Отчёт за день 📦\",\n    format: \"markdown\",\n    notify: true,\n    attachments: [\n      ...mediaAttachments,\n\n      // кнопки как inline_keyboard (как у тебя раньше)\n      {\n        type: \"inline_keyboard\",\n        payload: {\n          buttons: [\n            [{ type: \"link\", text: \"Открыть каталог\", url: \"https://koptorg.ru:7026\" }],\n            [{ type: \"link\", text: \"Сделать заказ\", url: \"https://koptorg.ru:7026\" }],\n          ]\n        }\n      }\n    ]\n  }\n}];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[1808,256],"id":"cdea60fa-935d-461d-aed0-3492b7f6e81c","name":"Code in JavaScript2"}],"connections":{"When clicking ‘Execute workflow’":{"main":[[{"node":"Code in JavaScript","type":"main","index":0}]]},"Узел A1":{"main":[[{"node":"Edit Fields","type":"main","index":0}]]},"Узел C1":{"main":[[{"node":"Code in JavaScript1","type":"main","index":0}]]},"Узел B1":{"main":[[{"node":"Merge1","type":"main","index":1}]]},"Merge1":{"main":[[{"node":"Узел C1","type":"main","index":0}]]},"Code in JavaScript":{"main":[[{"node":"Узел A1","type":"main","index":0},{"node":"Узел B1","type":"main","index":0}]]},"Code in JavaScript1":{"main":[[{"node":"Code in JavaScript2","type":"main","index":0}]]},"Edit Fields":{"main":[[{"node":"Merge1","type":"main","index":0}]]},"Code in JavaScript2":{"main":[[{"node":"Send Message1","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","availableInMCP":false},"staticData":null,"meta":null,"pinData":{},"versionId":"14c86317-7a60-442a-8c85-fb90c68d6e37","activeVersionId":null,"versionCounter":10,"triggerCount":0,"tags":[],"shared":[{"updatedAt":"2026-02-12T02:19:11.131Z","createdAt":"2026-02-12T02:19:11.131Z","role":"workflow:owner","workflowId":"P8k4WUwcsNTmZFFN","projectId":"pN1dQC2QTiUB8OxN","project":{"updatedAt":"2026-01-03T09:50:23.589Z","createdAt":"2026-01-02T11:57:57.457Z","id":"pN1dQC2QTiUB8OxN","name":"Ilya Sukharev <retail.sukharev@yandex.ru>","type":"personal","icon":null,"description":null,"creatorId":"a8327288-747a-47c3-9f5f-b2070eff6d8c"}}]},{"updatedAt":"2026-02-13T15:34:32.889Z","createdAt":"2026-02-13T15:34:32.889Z","id":"pqVwIgxssVYuC3XM","name":"autopost_main_test_max","description":null,"active":false,"isArchived":false,"nodes":[{"parameters":{},"type":"n8n-nodes-base.manualTrigger","typeVersion":1,"position":[2496,1936],"id":"c8fbebe9-4faf-4ebc-8bb7-ad312fe07e7f","name":"When clicking ‘Execute workflow’"},{"parameters":{"documentId":{"__rl":true,"mode":"id","value":"1FyEGxa6JYTJxDrowfgzAzroTM8L3CWCSY1rgI2DK9KQ"},"sheetName":{"__rl":true,"value":"POST","mode":"name"},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[2816,2064],"id":"6221b95c-bd11-404f-9c06-9fd30348168b","name":"Get row(s) in sheet","credentials":{"googleSheetsOAuth2Api":{"id":"b5DluHDjTyDAsQWd","name":"Google Sheets account"}}},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"id":"7ba9d3b4-0e56-48ca-bb39-4bd86db3fa75","leftValue":"={{ $json.status }}","rightValue":1,"operator":{"type":"number","operation":"equals"}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.filter","typeVersion":2.3,"position":[3024,2064],"id":"88cc7413-497b-4d60-9612-9e9c223ce63b","name":"Filter"},{"parameters":{"jsCode":"return items.map(item => {\n  const d = item.json;\n\n  const num = (v) => {\n    if (v === null || v === undefined || v === '') return null;\n    const n = Number(v);\n    return Number.isFinite(n) ? n : null;\n  };\n\n  const bool1 = (v) => num(v) === 1;\n\n  const strOrNull = (v) => {\n    const s = (v ?? '').toString().trim();\n    return s ? s : null;\n  };\n\n  const titleStr = (d.title ?? '').toString();\n  const titleNorm = titleStr.trim().toUpperCase();\n\n  // NEW: marker for \"GOODMORNING\" posts (text will be taken from COOP_FACT later in Expand per store)\n  const isGoodMorning = titleNorm === 'GOODMORNING';\n\n  return {\n    json: {\n      id: num(d.id),\n      status: num(d.status),\n      region: num(d.region),\n      post_type: num(d.post_type),\n\n      send_tg: bool1(d.send_tg),\n      send_vk: bool1(d.send_vk),\n      send_site: bool1(d.send_site),\n\n      // debug flag for telegram routing (1 = send to test channel)\n      tg_debug: num(d.tg_debug),\n\n      title: titleStr,\n      text: d.text ?? '',\n      parse_mode: num(d.parse_mode) ?? 0,\n\n      media_raw: d.media_url ?? '',\n\n      // старая логика: ссылка на бота (формат \"197_КУПИТЬ\")\n      old_post: strOrNull(d.old_post),\n\n      all_region: bool1(d.all_region),\n      points_note_mode:\n        d.points_note_mode === '' || d.points_note_mode === null || d.points_note_mode === undefined\n          ? null\n          : (num(d.points_note_mode) ?? null),\n\n      schedule: strOrNull(d.schedule),\n      publish_at: strOrNull(d.publish_at),\n\n      // service fields\n      last_run_at_utc: strOrNull(d.last_run_at_utc),\n      last_run_at: strOrNull(d.last_run_at),\n      last_run_key: strOrNull(d.last_run_key),\n\n      error: strOrNull(d.error),\n\n      // NEW: flag for downstream logic\n      _goodmorning: isGoodMorning,\n\n      // исходная строка целиком (включая колонки точек)\n      _raw: d,\n    },\n  };\n});\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[3232,2064],"id":"f4938da4-86c4-4c4c-a72d-3e410d609964","name":"Code in JavaScript"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"id":"a642aa85-b884-4c19-a91b-7222a19570d1","leftValue":"={{ $json._due }}","rightValue":true,"operator":{"type":"boolean","operation":"equals"}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.filter","typeVersion":2.3,"position":[3616,2064],"id":"d389ba72-6216-4e19-99c8-375bfbf24e61","name":"Filter1"},{"parameters":{"jsCode":"// === НАСТРОЙКИ ===\nconst TG_TEST_CHAT_ID = '-1003640743827';\n\n// !!! Поставьте реальные имена узлов:\nconst FILTER_NODE_NAME = 'Filter1';\nconst POSTGRES_NODE_NAME = 'Postgre_store_extract';\nconst COOP_FACT_NODE_NAME = 'GS_CoopFact_GetRows'; // NEW\n\n// Telegram deep-link base\nconst TG_OLD_BOT_BASE = 'https://t.me/kooptorg3_start_bot?start=';\n\nfunction regionToStoreTz(region) {\n  if (Number(region) === 54) return 7;\n  if (Number(region) === 82) return 3;\n  return null;\n}\n\nfunction regionToTzName(region) {\n  if (Number(region) === 54) return 'Asia/Novosibirsk';\n  if (Number(region) === 82) return 'Europe/Simferopol';\n  return 'Europe/Moscow';\n}\n\nfunction escapeHtml(s) {\n  return String(s ?? '')\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;');\n}\n\n// минимально достаточное экранирование MarkdownV2\nfunction escapeMarkdownV2(s) {\n  // Telegram MarkdownV2 special chars: _ * [ ] ( ) ~ ` > # + - = | { } . !\n  return String(s ?? '').replace(/[_*[\\]()~`>#+\\-=|{}.!]/g, '\\\\$&');\n}\n\nfunction buildTgTextAndMode(post) {\n  let text = (post.text ?? '').toString();\n  let parseMode = 'HTML';\n\n  if (Number(post.parse_mode) === 1) {\n    parseMode = 'HTML';\n  } else if (Number(post.parse_mode) === 2) {\n    parseMode = 'MarkdownV2';\n  } else {\n    text = escapeHtml(text);\n    parseMode = 'HTML';\n  }\n\n  return { text, parse_mode: parseMode };\n}\n\n// old_post format: \"197_КУПИТЬ\"\nfunction parseOldPost(oldPostValue) {\n  const raw = (oldPostValue ?? '').toString().trim();\n  if (!raw) return null;\n\n  const m = raw.match(/^(\\d{3})_(.+)$/);\n  if (!m) return null;\n\n  const oldId = m[1];\n  const label = (m[2] ?? '').toString().trim();\n  if (!label) return null;\n\n  return { old_id: oldId, label: label.toUpperCase() };\n}\n\nfunction formatDDMMYYYYInTz(dateUtc, tzName) {\n  const parts = new Intl.DateTimeFormat('en-GB', {\n    timeZone: tzName,\n    day: '2-digit',\n    month: '2-digit',\n    year: 'numeric',\n  }).formatToParts(dateUtc);\n\n  const map = {};\n  for (const p of parts) if (p.type !== 'literal') map[p.type] = p.value;\n\n  return `${map.day}${map.month}${map.year}`;\n}\n\n// YYYY-MM-DD in TZ from UTC date\nfunction formatYYYYMMDDInTz(dateUtc, tzName) {\n  const parts = new Intl.DateTimeFormat('en-CA', {\n    timeZone: tzName,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n  }).formatToParts(dateUtc);\n\n  const map = {};\n  for (const p of parts) if (p.type !== 'literal') map[p.type] = p.value;\n\n  return `${map.year}-${map.month}-${map.day}`;\n}\n\nfunction buildOldLink({ old_id, label }, storeId, datePart, parseMode) {\n  const sid = String(storeId ?? '').trim();\n  if (!sid) return null;\n\n  // шаблон как в твоём примере: webapp_<oldId><DDMMYYYY><storeId>_<storeId>\n  const startParam = `webapp_${old_id}${datePart}${sid}_${sid}`;\n  const url = `${TG_OLD_BOT_BASE}${startParam}`;\n\n  if (parseMode === 'MarkdownV2') {\n    const textMd = escapeMarkdownV2(label);\n    // URL в MarkdownV2 лучше тоже экранировать минимум (скобки и т.п.)\n    const urlMd = url.replace(/\\)/g, '\\\\)').replace(/\\(/g, '\\\\(');\n    return `[${textMd}](${urlMd})`;\n  }\n\n  // HTML\n  const textHtml = escapeHtml(label);\n  const urlHtml = escapeHtml(url);\n  return `<a href=\"${urlHtml}\">${textHtml}</a>`;\n}\n\nfunction appendOldLinkToText(text, oldLink) {\n  const base = (text ?? '').toString();\n  if (!oldLink) return base;\n  if (!base.trim()) return oldLink;\n  return `${base}\\n\\n${oldLink}`;\n}\n\n// Ваш формат: store_195_Большевистская\nfunction pickStoreIdsFromRaw(raw) {\n  const ids = [];\n  for (const [k, v] of Object.entries(raw || {})) {\n    const key = String(k ?? '').trim();\n    const m = key.match(/^store_(\\d+)_/); // строго ваш формат\n    if (!m) continue;\n\n    const storeId = Number(m[1]);\n    if (!Number.isFinite(storeId)) continue;\n\n    const vv = (v ?? '').toString().trim();\n    if (vv === '1') ids.push(storeId);\n  }\n  return ids;\n}\n\nfunction cleanLine(s) {\n  return String(s ?? '')\n    .replace(/[\\uFEFF\\u200B\\u200C\\u200D\\u2060\\u00AD]/g, '')\n    .trim();\n}\n\n/**\n * media_raw format (each line):\n *   ф|https://...\n *   в|https://...\n * returns [{type:'photo'|'video', media:'url'}]\n */\nfunction parseMediaLines(mediaRaw) {\n  const raw = (mediaRaw ?? '').toString();\n  const lines = raw.split(/\\r\\n|\\n|\\r/g).map(cleanLine).filter(Boolean);\n\n  const out = [];\n  for (const line of lines) {\n    const m = line.match(/^([фв])\\|(.*)$/i);\n    if (!m) continue;\n\n    const kind = m[1].toLowerCase();\n    const url = cleanLine(m[2] || '');\n    if (!url) continue;\n\n    out.push({\n      type: kind === 'ф' ? 'photo' : 'video',\n      media: url,\n    });\n  }\n  return out;\n}\n\nfunction isCaptionOk(text) {\n  const t = (text ?? '').toString();\n  // caption limit ~1024; keep margin\n  return t.length > 0 && t.length <= 950;\n}\n\n// NEW: normalize COOP_FACT date to YYYY-MM-DD (supports 04/01/2026)\nfunction normalizeFactDate(v) {\n  const s = cleanLine(v);\n  if (!s) return null;\n\n  // YYYY-MM-DD\n  let m = s.match(/^(\\d{4})-(\\d{2})-(\\d{2})$/);\n  if (m) return `${m[1]}-${m[2]}-${m[3]}`;\n\n  // DD.MM.YYYY\n  m = s.match(/^(\\d{2})\\.(\\d{2})\\.(\\d{4})$/);\n  if (m) return `${m[3]}-${m[2]}-${m[1]}`;\n\n  // DD/MM/YYYY  (your format: 04/01/2026)\n  m = s.match(/^(\\d{2})\\/(\\d{2})\\/(\\d{4})$/);\n  if (m) {\n    const dd = Number(m[1]);\n    const mm = Number(m[2]);\n    const yyyy = Number(m[3]);\n    if (dd >= 1 && dd <= 31 && mm >= 1 && mm <= 12) {\n      const dds = String(dd).padStart(2, '0');\n      const mms = String(mm).padStart(2, '0');\n      return `${yyyy}-${mms}-${dds}`;\n    }\n  }\n\n  // Try Date.parse for ISO-ish values (not reliable for 04/01/2026, but ok for other strings)\n  const t = Date.parse(s);\n  if (!Number.isNaN(t)) {\n    const d = new Date(t);\n    const y = d.getUTCFullYear();\n    const mo = String(d.getUTCMonth() + 1).padStart(2, '0');\n    const da = String(d.getUTCDate()).padStart(2, '0');\n    return `${y}-${mo}-${da}`;\n  }\n\n  return null;\n}\n\n// get publish date (YYYY-MM-DD) in region TZ for GOODMORNING\nfunction getGoodMorningDateKey(post, tzName) {\n  // Prefer _occurrence_utc (for recurring). For one-time it will also be present in your Determine due.\n  const occIso = cleanLine(post._occurrence_utc);\n  if (occIso) {\n    const d = new Date(occIso);\n    if (!Number.isNaN(d.getTime())) return formatYYYYMMDDInTz(d, tzName);\n  }\n\n  // Fallback: parse from _occurrence_local / _publish_at_parsed (strings like \"YYYY-MM-DD ... (TZ)\")\n  const s1 = cleanLine(post._occurrence_local);\n  if (s1) {\n    const m = s1.match(/^(\\d{4}-\\d{2}-\\d{2})\\b/);\n    if (m) return m[1];\n  }\n\n  const s2 = cleanLine(post._publish_at_parsed);\n  if (s2) {\n    const m = s2.match(/^(\\d{4}-\\d{2}-\\d{2})\\b/);\n    if (m) return m[1];\n  }\n\n  // Last resort: if publish_at exists as \"YYYY-MM-DD ...\" without TZ\n  const s3 = cleanLine(post.publish_at);\n  if (s3) {\n    const m = s3.match(/^(\\d{4}-\\d{2}-\\d{2})\\b/);\n    if (m) return m[1];\n  }\n\n  return null;\n}\n\n// --- Забираем данные по имени узлов ---\nconst postsInput = $items(FILTER_NODE_NAME).map(x => x.json);\nconst storesInput = $items(POSTGRES_NODE_NAME).map(x => x.json);\nconst factsInput = $items(COOP_FACT_NODE_NAME).map(x => x.json);\n\n// Build facts map: YYYY-MM-DD -> fact\nconst factMap = new Map();\nfor (const row of factsInput) {\n  const dk = normalizeFactDate(row?.date);\n  const fact = cleanLine(row?.fact);\n  if (!dk || !fact) continue;\n  factMap.set(dk, row.fact); // keep last\n}\n\n// Диагностика stores\nconst tzSet = new Set();\nfor (const s of storesInput) {\n  if (s && s.time_zone !== undefined && s.time_zone !== null && s.time_zone !== '') {\n    tzSet.add(String(s.time_zone));\n  }\n}\nconst storesDebug = {\n  stores_count: storesInput.length,\n  stores_time_zones: Array.from(tzSet).sort(),\n  stores_first_keys: storesInput[0] ? Object.keys(storesInput[0]) : [],\n  facts_count: factsInput.length,\n  facts_keys_sample: Array.from(factMap.keys()).slice(0, 10),\n};\n\n// Если stores не пришли — вернём ошибку на каждый пост\nif (storesInput.length === 0) {\n  return postsInput.map(post => ({\n    json: {\n      ...post,\n      _tg_targets_empty: true,\n      _tg_targets_reason: `stores input is empty: $items(\"${POSTGRES_NODE_NAME}\") returned 0 rows`,\n      _stores_debug: storesDebug,\n\n      // важные служебные поля для дальнейшего апдейта Sheets\n      row_number: post?._raw?.row_number ?? null,\n      _now: post._now ?? null,\n      _now_utc: post._now_utc ?? null,\n      _run_key: post._run_key ?? null,\n    },\n  }));\n}\n\n// Map store_id -> storeRow\nconst storeMap = new Map();\nfor (const s of storesInput) {\n  const storeId = Number(s.store_id);\n  if (!Number.isFinite(storeId)) continue;\n  if (!storeMap.has(storeId)) storeMap.set(storeId, s);\n}\n\nconst out = [];\n\nfor (const post of postsInput) {\n  // Раньше тут было: if (!post.send_tg) continue;\n  // Теперь: пропускаем VK/SITE посты дальше одним item, а TG-развёртку делаем только когда send_tg=true\n\n  const hasAnyChannel = Boolean(post.send_tg || post.send_vk || post.send_site);\n  if (!hasAnyChannel) continue;\n\n  // --- протаскиваем row_number (для Update в Sheets) ---\n  const rowNumber = post?._raw?.row_number ?? null;\n\n  // --- протаскиваем служебные поля запуска (для last_run_*) ---\n  const nowLocal = post._now ?? null;      // локальное время региона (строка)\n  const nowUtcIso = post._now_utc ?? null; // ISO UTC\n  const runKey = post._run_key ?? null;\n\n  // --- GOODMORNING text override from COOP_FACT (общий, меняем post.text) ---\n  const tzName = regionToTzName(post.region);\n  let postForText = post;\n\n  if (post._goodmorning === true) {\n    const dateKey = getGoodMorningDateKey(post, tzName);\n    const fact = dateKey ? factMap.get(dateKey) : null;\n\n    if (!dateKey) {\n      out.push({\n        json: {\n          ...post,\n          row_number: rowNumber,\n          _now: nowLocal,\n          _now_utc: nowUtcIso,\n          _run_key: runKey,\n\n          _prepare_error: `GOODMORNING: cannot determine date key from occurrence/publish fields`,\n          _goodmorning_date_key: null,\n          _stores_debug: storesDebug,\n        },\n      });\n      continue;\n    }\n\n    if (!fact || !cleanLine(fact)) {\n      out.push({\n        json: {\n          ...post,\n          row_number: rowNumber,\n          _now: nowLocal,\n          _now_utc: nowUtcIso,\n          _run_key: runKey,\n\n          _prepare_error: `GOODMORNING: no fact found for date=${dateKey} in COOP_FACT`,\n          _goodmorning_date_key: dateKey,\n          _stores_debug: storesDebug,\n        },\n      });\n      continue;\n    }\n\n    postForText = {\n      ...post,\n      text: `${fact}\\n!!Навигация`,\n      _goodmorning_date_key: dateKey,\n    };\n  }\n  // --- /GOODMORNING ---\n\n  // === Если TG не нужен — просто пробрасываем item дальше (для VK/SITE) ===\n  if (!postForText.send_tg) {\n    out.push({\n      json: {\n        ...postForText,\n        row_number: rowNumber,\n        _now: nowLocal,\n        _now_utc: nowUtcIso,\n        _run_key: runKey,\n        _stores_debug: storesDebug,\n      },\n    });\n    continue;\n  }\n\n  // === TG часть (как было) ===\n  const tzNeed = regionToStoreTz(postForText.region);\n  if (tzNeed === null) {\n    out.push({\n      json: {\n        ...postForText,\n        row_number: rowNumber,\n        _now: nowLocal,\n        _now_utc: nowUtcIso,\n        _run_key: runKey,\n\n        _tg_targets_empty: true,\n        _tg_targets_reason: `unknown region=${postForText.region}`,\n        _stores_debug: storesDebug,\n      },\n    });\n    continue;\n  }\n\n  // store_id цели\n  let targetStoreIds = [];\n  if (postForText.all_region) {\n    for (const s of storesInput) {\n      if (Number(s.time_zone) === tzNeed) {\n        const id = Number(s.store_id);\n        if (Number.isFinite(id)) targetStoreIds.push(id);\n      }\n    }\n  } else {\n    targetStoreIds = pickStoreIdsFromRaw(postForText._raw);\n  }\n\n  targetStoreIds = Array.from(new Set(targetStoreIds));\n\n  if (targetStoreIds.length === 0) {\n    out.push({\n      json: {\n        ...postForText,\n        row_number: rowNumber,\n        _now: nowLocal,\n        _now_utc: nowUtcIso,\n        _run_key: runKey,\n\n        _tg_targets_empty: true,\n        _tg_targets_reason: postForText.all_region\n          ? `no stores found for time_zone=${tzNeed} (stores_count=${storesInput.length}, tzs=${storesDebug.stores_time_zones.join(',')})`\n          : 'no store columns selected in sheet row (no store_* = 1)',\n        _stores_debug: storesDebug,\n      },\n    });\n    continue;\n  }\n\n  const tgBase = buildTgTextAndMode(postForText);\n  const debugMode = Number(postForText.tg_debug) === 1;\n\n  // ---- parse media ----\n  const mediaRaw = (postForText.media_raw ?? postForText.media_url ?? postForText._raw?.media_raw ?? postForText._raw?.media_url ?? '').toString();\n  const mediaArr = parseMediaLines(mediaRaw);\n\n  // old_post parsing (only if present)\n  const oldParsed = parseOldPost(postForText.old_post ?? postForText._raw?.old_post);\n\n  // date part for old_link in region tz\n  const nowUtcObj = nowUtcIso ? new Date(nowUtcIso) : new Date();\n  const datePart = formatDDMMYYYYInTz(nowUtcObj, tzName);\n\n  // базовое решение по типу отправки (без учета caption длины — это сделаем per-store)\n  let baseOp = 'message'; // message | photo | video | media_group\n  let baseMedia = null;\n\n  if (mediaArr.length === 0) {\n    baseOp = 'message';\n  } else if (mediaArr.length === 1) {\n    baseOp = mediaArr[0].type === 'photo' ? 'photo' : 'video';\n    baseMedia = mediaArr[0].media;\n  } else {\n    baseOp = 'media_group';\n  }\n\n  const seenChat = new Set();\n  let produced = 0;\n\n  for (const storeId of targetStoreIds) {\n    const s = storeMap.get(storeId);\n    if (!s) continue;\n    if (Number(s.time_zone) !== tzNeed) continue;\n\n    const chatId = debugMode ? TG_TEST_CHAT_ID : s.channel_chat_id;\n    const chatKey = String(chatId);\n    if (seenChat.has(chatKey)) continue;\n    seenChat.add(chatKey);\n\n    // --- old link for this store (depends on storeId) ---\n    const oldLink = oldParsed ? buildOldLink(oldParsed, storeId, datePart, tgBase.parse_mode) : null;\n    const tgTextFinal = appendOldLinkToText(tgBase.text, oldLink);\n\n    // --- per-store media decision for albums: caption may be too long ---\n    let tgOp = baseOp;\n    let tgMedia = baseMedia;\n    let tgMediaGroup = null;\n    let needExtraTextMessage = false;\n\n    if (baseOp === 'media_group') {\n      tgMediaGroup = mediaArr;\n\n      if (isCaptionOk(tgTextFinal)) {\n        tgMediaGroup = tgMediaGroup.map((m, idx) => {\n          if (idx === 0) {\n            return {\n              ...m,\n              caption: tgTextFinal,\n              parse_mode: tgBase.parse_mode,\n            };\n          }\n          return m;\n        });\n      } else if (tgTextFinal.trim()) {\n        // caption слишком длинный — альбом без caption, а текст отдельным сообщением\n        needExtraTextMessage = true;\n      }\n    }\n\n    // 1) основной item\n    out.push({\n      json: {\n        ...postForText,\n\n        // служебные поля для апдейта Sheets\n        row_number: rowNumber,\n        _now: nowLocal,\n        _now_utc: nowUtcIso,\n        _run_key: runKey,\n\n        // данные цели\n        store_id: storeId,\n        store_description: s.store_description ?? null,\n\n        // routing for telegram\n        tg_op: tgOp,\n        tg_media: tgMedia,\n        tg_media_group: tgMediaGroup,\n\n        // old link debug\n        _old_post_parsed: oldParsed,\n        _old_post_date_ddmmyyyy: datePart,\n        _old_post_link: oldLink,\n\n        tg: {\n          chat_id: chatId,\n          text: tgTextFinal,\n          parse_mode: tgBase.parse_mode,\n          debug: debugMode,\n        },\n\n        _run_key_channel: runKey ? `${runKey}|store:${storeId}` : null,\n        _stores_debug: storesDebug,\n      },\n    });\n\n    produced++;\n\n    // 2) если альбом и текст длинный — отдельное сообщение текстом после альбома\n    if (tgOp === 'media_group' && needExtraTextMessage) {\n      out.push({\n        json: {\n          ...postForText,\n\n          row_number: rowNumber,\n          _now: nowLocal,\n          _now_utc: nowUtcIso,\n          _run_key: runKey,\n\n          store_id: storeId,\n          store_description: s.store_description ?? null,\n\n          tg_op: 'message',\n          tg_media: null,\n          tg_media_group: null,\n\n          // old link debug\n          _old_post_parsed: oldParsed,\n          _old_post_date_ddmmyyyy: datePart,\n          _old_post_link: oldLink,\n\n          tg: {\n            chat_id: chatId,\n            text: tgTextFinal,\n            parse_mode: tgBase.parse_mode,\n            debug: debugMode,\n          },\n\n          _run_key_channel: runKey ? `${runKey}|store:${storeId}|text_after_album` : null,\n          _stores_debug: storesDebug,\n        },\n      });\n    }\n  }\n\n  if (produced === 0) {\n    out.push({\n      json: {\n        ...postForText,\n        row_number: rowNumber,\n        _now: nowLocal,\n        _now_utc: nowUtcIso,\n        _run_key: runKey,\n\n        _tg_targets_empty: true,\n        _tg_targets_reason: `stores selected but none matched mapping for time_zone=${tzNeed} (stores_count=${storesInput.length}, tzs=${storesDebug.stores_time_zones.join(',')})`,\n        _stores_debug: storesDebug,\n      },\n    });\n  }\n}\n\nreturn out;\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[4176,2160],"id":"9da831a6-a5b2-4363-b8da-3f887d1aa501","name":"Code in JavaScript2","onError":"continueRegularOutput"},{"parameters":{"chatId":"={{ $json.tg_chat_id }}","text":"={{ $json.tg_text }}","additionalFields":{"appendAttribution":false,"parse_mode":"={{ $json.tg_parse_mode }}"},"path":"684d51b8-9e35-4eb4-a3f7-8bb6dd3ec3f7"},"type":"n8n-nodes-base.telegram","typeVersion":1.2,"position":[5120,1952],"id":"a7023620-bae0-4ad0-ba23-94f90434978b","name":"Send a text message","webhookId":"684d51b8-9e35-4eb4-a3f7-8bb6dd3ec3f7","alwaysOutputData":true,"credentials":{"telegramApi":{"id":"PvtTCKhw5iSNTNjL","name":"Telegram account"}},"onError":"continueRegularOutput"},{"parameters":{"operation":"executeQuery","query":"SELECT\n  s.store_id,\n  s.store_description,\n  s.time_zone,\n  MAX(sc.channel_chat_id) AS channel_chat_id,\n  MAX(sc.discussion_chat_id) AS discussion_chat_id\nFROM coop.order_store s\nJOIN coop.store_channel sc ON sc.store_id = s.store_id\nWHERE sc.channel_chat_id IS NOT NULL\n  AND s.time_zone IN (3, 7)\n  AND s.store_close_date IS NULL\nGROUP BY s.store_id, s.store_description, s.time_zone\nORDER BY s.time_zone, s.store_id;","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[3792,2304],"id":"b9c5f1a9-fd1a-4c8e-8488-067256854b88","name":"Postgre_store_extract","executeOnce":true,"credentials":{"postgres":{"id":"Nn7xJ9wkuFYHFyvT","name":"Postgres account"}}},{"parameters":{"jsCode":"/**\n * Collect TG results per post_id (after Merge Combine/Position)\n * Supports:\n *  - Telegram nodes (they often return { ok:true, result:... } or set p.error on continueRegularOutput)\n *  - HTTP Request node (sendMediaGroup) which may return:\n *      - { statusCode: 200, body: { ok:true, result:[...] } }  (when JSON)\n *      - { statusCode: 200, body: \"...\" }                      (when string)\n *      - errors in p.error / p.message / p.response / p.body\n *\n * Output: one item per post_id with aggregation + Sheets update fields\n */\n\nconst items = $input.all();\n\nfunction safeStr(v) {\n  if (v === null || v === undefined) return '';\n  return String(v);\n}\n\nfunction toNumOrNull(v) {\n  if (v === null || v === undefined || v === '') return null;\n  const n = Number(v);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction appendLog(existing, line) {\n  const base = (existing ?? '').toString().trim();\n  if (!base) return line;\n  return base + '\\n' + line;\n}\n\nfunction tryJsonParse(s) {\n  try {\n    return JSON.parse(s);\n  } catch (e) {\n    return null;\n  }\n}\n\n// --- Detect ok for both Telegram node and HTTP Request node ---\nfunction detectOk(p) {\n  if (!p) return false;\n\n  // Telegram node common\n  if (p.ok === true || p.success === true) return true;\n\n  // HTTP Request node common shapes\n  // 1) response object\n  if (p.response && (p.response.ok === true || p.response.success === true)) return true;\n\n  // 2) body may be object or stringified json\n  const body = p.body ?? p.response?.body ?? null;\n  if (body && typeof body === 'object') {\n    if (body.ok === true) return true;\n    // sometimes nested\n    if (body.data?.ok === true) return true;\n  }\n  if (typeof body === 'string') {\n    const j = tryJsonParse(body);\n    if (j && j.ok === true) return true;\n  }\n\n  // 3) n8n httpRequest often exposes statusCode\n  const sc = p.statusCode ?? p.status ?? p.response?.statusCode ?? null;\n  if (typeof sc === 'number' && sc >= 200 && sc < 300) {\n    // If Telegram returns non-ok with 200, we'd have body.ok=false.\n    // But if we can't see body, treat 2xx as ok to avoid false FAIL logs.\n    return true;\n  }\n\n  return false;\n}\n\nfunction extractErrorText(p) {\n  if (!p) return 'unknown error';\n\n  // Telegram node error object\n  if (typeof p.error === 'string') return p.error;\n  if (p.error?.message) return safeStr(p.error.message);\n\n  // httpRequest node sometimes exposes errorMessage / message\n  if (p.errorMessage) return safeStr(p.errorMessage);\n  if (p.message) return safeStr(p.message);\n  if (p.description) return safeStr(p.description);\n  if (p.cause) return safeStr(p.cause);\n\n  // response/body shapes\n  const body = p.body ?? p.response?.body ?? p.responseBody ?? null;\n\n  if (body && typeof body === 'object') {\n    if (body.description) return safeStr(body.description);\n    if (body.error) return safeStr(body.error);\n    if (body.message) return safeStr(body.message);\n    if (body.ok === false && body.description) return safeStr(body.description);\n    try {\n      return JSON.stringify(body);\n    } catch (e) {\n      return 'unstringifiable body';\n    }\n  }\n\n  if (typeof body === 'string') {\n    const j = tryJsonParse(body);\n    if (j) {\n      if (j.description) return safeStr(j.description);\n      if (j.error) return safeStr(j.error);\n      if (j.message) return safeStr(j.message);\n      if (j.ok === false && j.description) return safeStr(j.description);\n      try {\n        return JSON.stringify(j);\n      } catch (e) {}\n    }\n    // raw string body\n    const s = body.trim();\n    if (s) return s.slice(0, 500);\n  }\n\n  // fallback stringify whole p.error if exists\n  if (p.error) {\n    try {\n      return JSON.stringify(p.error);\n    } catch (e) {\n      return 'unstringifiable error';\n    }\n  }\n\n  return 'unknown error';\n}\n\n// group per post_id\nconst byPost = new Map();\n\nfor (const item of items) {\n  const p = item.json || {};\n\n  const postId = p.post_id ?? p.id ?? null;\n  if (!postId) continue;\n\n  if (!byPost.has(postId)) {\n    byPost.set(postId, {\n      post_id: postId,\n      row_number: toNumOrNull(p.row_number),\n\n      last_run_key: p._run_key ?? null,\n      now_utc: p._now_utc ?? new Date().toISOString(),\n      now_local: p._now ?? null,\n\n      plan_run_at: p._plan_run_at ?? null,\n      prev_error: p.error_prev ?? null,\n\n      total: 0,\n      ok: 0,\n      fail: 0,\n      fails: [],\n    });\n  }\n\n  const agg = byPost.get(postId);\n\n  if (!agg.plan_run_at && p._plan_run_at) agg.plan_run_at = p._plan_run_at;\n\n  agg.total += 1;\n\n  const ok = detectOk(p);\n\n  const storeId = p.store_id ?? null;\n  const chatId = p.tg_chat_id ?? p.chat_id ?? null;\n\n  if (ok) {\n    agg.ok += 1;\n  } else {\n    agg.fail += 1;\n    const desc = extractErrorText(p);\n    agg.fails.push({\n      store_id: storeId,\n      chat_id: chatId,\n      desc: safeStr(desc),\n    });\n  }\n}\n\nconst out = [];\n\nfor (const agg of byPost.values()) {\n  // success only if at least one ok and no fails\n  const allOk = agg.fail === 0 && agg.ok > 0;\n\n  let newError = agg.prev_error;\n\n  if (allOk) {\n    newError = appendLog(\n      newError,\n      `[OK TG] ${agg.now_utc} key=${safeStr(agg.last_run_key)} sent=${agg.ok}/${agg.total}`\n    );\n  } else {\n    const failLines = agg.fails\n      .slice(0, 20)\n      .map(f => `store=${safeStr(f.store_id)} chat=${safeStr(f.chat_id)} err=${safeStr(f.desc)}`)\n      .join(' | ');\n\n    newError = appendLog(\n      newError,\n      `[FAIL TG] ${agg.now_utc} key=${safeStr(agg.last_run_key)} ok=${agg.ok}/${agg.total} fails=${agg.fail}` +\n        (failLines ? ` :: ${failLines}` : '')\n    );\n  }\n\n  out.push({\n    json: {\n      post_id: agg.post_id,\n      row_number: agg.row_number,\n\n      _all_ok: allOk,\n      _sent_ok: agg.ok,\n      _sent_fail: agg.fail,\n      _sent_total: agg.total,\n\n      update_last_run_at_utc: allOk ? agg.now_utc : null,\n      update_last_run_at: allOk ? agg.now_local : null,\n      update_last_run_key: allOk ? agg.last_run_key : null,\n\n      // write plan_run_at only on success\n      update_plan_run_at: allOk ? (agg.plan_run_at ?? null) : null,\n\n      update_error: newError,\n    },\n  });\n}\n\nreturn out;\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[5760,2032],"id":"6241f795-3d35-40d7-8c1e-4d54b64d9a3d","name":"Collect TG results"},{"parameters":{"assignments":{"assignments":[{"id":"1f3d5cad-548c-48bd-a374-ccdde7c4314f","name":"row_number","value":"={{$json.row_number}}","type":"number"},{"id":"254b0c02-3d0b-49ad-a8ca-7458f17209c3","name":"=post_id","value":"={{$json.id}}","type":"number"},{"id":"9afe30be-bf19-4af9-80fa-87e2353d83cc","name":"=_run_key","value":"={{$json._run_key}}","type":"string"},{"id":"1af1f314-8f5a-4a78-a072-f8d807c68e4d","name":"_now","value":"={{$json._now}}","type":"string"},{"id":"0aa65ec9-dd1e-4222-be13-933718236ee1","name":"_now_utc","value":"={{$json._now_utc}}","type":"string"},{"id":"640a3f9b-df58-45a7-8fbe-f29fa198bf8a","name":"store_id","value":"={{$json.store_id}}","type":"number"},{"id":"c02060fc-02fd-43b4-9c21-5b2a0a1f439b","name":"tg_chat_id","value":"={{$json.tg.chat_id}}","type":"string"},{"id":"6ab1367a-f53c-46cc-a263-d88103dbcc96","name":"tg_text","value":"={{$json.tg.text}}","type":"string"},{"id":"2b04009d-0cf0-47df-83fe-3209c35bf1ee","name":"tg_parse_mode","value":"={{$json.tg.parse_mode}}","type":"string"},{"id":"b9c1c913-0000-4295-88b0-9f32cd8d6d6b","name":"error_prev","value":"={{$json.error}}","type":"string"},{"id":"077dde57-5614-483b-afbe-504eec04fb67","name":"tg_op","value":"={{$json.tg_op}}","type":"string"},{"id":"2e21132e-99ed-4797-b9a9-373ab5b8ec2b","name":"tg_media","value":"={{$json.tg_media}}","type":"string"},{"id":"4fe678fe-b144-40d8-89d9-7037ede12a83","name":"tg_media_group_json","value":"={{ JSON.stringify($json.tg_media_group) }}","type":"string"},{"id":"f3930a07-f3c3-4722-a6e6-0bbb3ecddb35","name":"_old_post_link","value":"={{$json._old_post_link}}","type":"string"},{"id":"e0106ac8-b2bf-455d-81e8-ee4bfe5cd40a","name":"_plan_run_at","value":"={{$json._plan_run_at}}","type":"string"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[4480,2192],"id":"06de09d1-6856-44b1-aacb-3e95b17f7889","name":"Edit Fields"},{"parameters":{"mode":"combine","combineBy":"combineByPosition","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5280,1968],"id":"0846f5eb-bc53-40f6-8bd9-3b2adb4cdc41","name":"Merge"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"loose","version":3},"conditions":[{"id":"1de16de6-60be-47d0-85bb-be106d58e7e2","leftValue":"={{$json._all_ok}}","rightValue":"true","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"looseTypeValidation":true,"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.3,"position":[6672,2032],"id":"719b77d0-6e01-47ef-a534-e33ca781d59a","name":"If"},{"parameters":{"operation":"update","documentId":{"__rl":true,"value":"1FyEGxa6JYTJxDrowfgzAzroTM8L3CWCSY1rgI2DK9KQ","mode":"id"},"sheetName":{"__rl":true,"value":"POST","mode":"name"},"columns":{"mappingMode":"defineBelow","value":{"row_number":"={{$json.row_number}}","last_run_at_utc":"={{$json.update_last_run_at_utc}}","last_run_at":"={{$json.update_last_run_at}}","last_run_key":"={{$json.update_last_run_key}}","error":"={{$json.update_error}}","plan_run_at":"={{$json.update_plan_run_at}}"},"matchingColumns":["row_number"],"schema":[{"id":"id","displayName":"id","required":false,"defaultMatch":true,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"status","displayName":"status","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"region","displayName":"region","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"post_type","displayName":"post_type","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"tg_debug","displayName":"tg_debug","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"send_tg","displayName":"send_tg","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"send_vk","displayName":"send_vk","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"send_site","displayName":"send_site","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"old_post","displayName":"old_post","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"title","displayName":"title","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"media_url","displayName":"media_url","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"parse_mode","displayName":"parse_mode","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"text","displayName":"text","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"points_note_mode","displayName":"points_note_mode","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"all_region","displayName":"all_region","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_195_Большевистская","displayName":"store_195_Большевистская","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_191_Рябиновая","displayName":"store_191_Рябиновая","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_190_Золотодолинская","displayName":"store_190_Золотодолинская","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_174_Онега","displayName":"store_174_Онега","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_166_Станиславского","displayName":"store_166_Станиславского","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_186_Краснообск","displayName":"store_186_Краснообск","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_193_БердскВокзальная","displayName":"store_193_БердскВокзальная","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_160_Декабристов41","displayName":"store_160_Декабристов41","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_189_Ялта","displayName":"store_189_Ялта","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_211_Симферополь","displayName":"store_211_Симферополь","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"schedule","displayName":"schedule","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"publish_at","displayName":"publish_at","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"last_run_at_utc","displayName":"last_run_at_utc","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":false},{"id":"last_run_at","displayName":"last_run_at","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":false},{"id":"last_run_key","displayName":"last_run_key","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":false},{"id":"plan_run_at","displayName":"plan_run_at","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":false},{"id":"error","displayName":"error","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":false},{"id":"row_number","displayName":"row_number","required":false,"defaultMatch":false,"display":true,"type":"number","canBeUsedToMatch":true,"readOnly":true,"removed":false}],"attemptToConvertTypes":false,"convertFieldsToString":false},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[6944,1792],"id":"eb31ae75-610e-461a-ac98-090ea1fccaa5","name":"Update row in sheet","credentials":{"googleSheetsOAuth2Api":{"id":"b5DluHDjTyDAsQWd","name":"Google Sheets account"}}},{"parameters":{"operation":"update","documentId":{"__rl":true,"value":"1FyEGxa6JYTJxDrowfgzAzroTM8L3CWCSY1rgI2DK9KQ","mode":"id"},"sheetName":{"__rl":true,"value":"POST","mode":"name"},"columns":{"mappingMode":"defineBelow","value":{"row_number":"={{$json.row_number}}","error":"={{$json.update_error}}"},"matchingColumns":["row_number"],"schema":[{"id":"id","displayName":"id","required":false,"defaultMatch":true,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"status","displayName":"status","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"region","displayName":"region","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"post_type","displayName":"post_type","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"tg_debug","displayName":"tg_debug","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"send_tg","displayName":"send_tg","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"send_vk","displayName":"send_vk","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"send_site","displayName":"send_site","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"title","displayName":"title","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"media_url","displayName":"media_url","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"parse_mode","displayName":"parse_mode","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"text","displayName":"text","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"points_note_mode","displayName":"points_note_mode","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"all_region","displayName":"all_region","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_195_Большевистская","displayName":"store_195_Большевистская","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_191_Рябиновая","displayName":"store_191_Рябиновая","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_190_Золотодолинская","displayName":"store_190_Золотодолинская","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_174_Онега","displayName":"store_174_Онега","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_166_Станиславского","displayName":"store_166_Станиславского","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_186_Краснообск","displayName":"store_186_Краснообск","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_193_БердскВокзальная","displayName":"store_193_БердскВокзальная","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_160_Декабристов41","displayName":"store_160_Декабристов41","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_189_Ялта","displayName":"store_189_Ялта","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"store_211_Симферополь","displayName":"store_211_Симферополь","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"schedule","displayName":"schedule","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"last_run_at_utc","displayName":"last_run_at_utc","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"last_run_at","displayName":"last_run_at","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"last_run_key","displayName":"last_run_key","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"error","displayName":"error","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":false},{"id":"publish_at","displayName":"publish_at","required":false,"defaultMatch":false,"display":true,"type":"string","canBeUsedToMatch":true,"removed":true},{"id":"row_number","displayName":"row_number","required":false,"defaultMatch":false,"display":true,"type":"number","canBeUsedToMatch":true,"readOnly":true,"removed":false}],"attemptToConvertTypes":false,"convertFieldsToString":false},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[6944,2224],"id":"d865c1c8-b333-4d88-a892-a9f4ce80efc2","name":"Update row in sheet1","credentials":{"googleSheetsOAuth2Api":{"id":"b5DluHDjTyDAsQWd","name":"Google Sheets account"}}},{"parameters":{},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[3920,2080],"id":"ae33e077-d3f9-4c0f-9569-85a7059f3bdd","name":"Merge1"},{"parameters":{"rules":{"values":[{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"leftValue":"={{$json.tg_op}}","rightValue":"message","operator":{"type":"string","operation":"equals"},"id":"a889ad03-e512-413d-afc6-cb13b4d06e20"}],"combinator":"and"},"renameOutput":true,"outputKey":"Output 1"},{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"id":"3b373903-657f-4d1c-b292-d7e347a05ecb","leftValue":"={{$json.tg_op}}","rightValue":"photo","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"renameOutput":true,"outputKey":"Output 2"},{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"id":"ec2bd0f8-d963-46e1-b215-dac61c822773","leftValue":"={{$json.tg_op}}","rightValue":"video","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"renameOutput":true,"outputKey":"Output 3"},{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":3},"conditions":[{"id":"b0a65edb-b26b-43f5-a746-8ef43cc19e0c","leftValue":"={{$json.tg_op}}","rightValue":"media_group","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"renameOutput":true,"outputKey":"Output 4"}]},"options":{}},"type":"n8n-nodes-base.switch","typeVersion":3.4,"position":[4800,2176],"id":"d4889358-444c-4c2b-9c95-0109d06107ed","name":"Switch"},{"parameters":{"operation":"sendPhoto","chatId":"={{$json.tg_chat_id}}","file":"={{$json.tg_media}}","additionalFields":{"caption":"={{$json.tg_text}}","parse_mode":"={{$json.tg_parse_mode}}"},"path":"bf65af50-4ca7-4507-afa1-a10a6e4d5ad1"},"type":"n8n-nodes-base.telegram","typeVersion":1.2,"position":[5136,2224],"id":"f6d8bb79-dbe9-41b0-b86a-a1b0d8bfca42","name":"Send a photo message","webhookId":"bf65af50-4ca7-4507-afa1-a10a6e4d5ad1","alwaysOutputData":true,"notesInFlow":false,"credentials":{"telegramApi":{"id":"PvtTCKhw5iSNTNjL","name":"Telegram account"}},"onError":"continueRegularOutput"},{"parameters":{"mode":"combine","combineBy":"combineByPosition","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5296,2240],"id":"80d841e3-6695-4f4a-a76e-b8c6c93a2c80","name":"Merge2"},{"parameters":{"operation":"sendVideo","chatId":"={{$json.tg_chat_id}}","file":"={{$json.tg_media}}","additionalFields":{"caption":"={{$json.tg_text}}","parse_mode":"={{$json.tg_parse_mode}}"},"path":"0ef85870-4c9b-4d3c-a35e-c26f52f345fd"},"type":"n8n-nodes-base.telegram","typeVersion":1.2,"position":[5152,2432],"id":"65cd74fc-eaa5-43ca-bb30-5a3bbbc21fe8","name":"Send a video","webhookId":"0ef85870-4c9b-4d3c-a35e-c26f52f345fd","credentials":{"telegramApi":{"id":"PvtTCKhw5iSNTNjL","name":"Telegram account"}},"onError":"continueRegularOutput"},{"parameters":{"mode":"combine","combineBy":"combineByPosition","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5312,2448],"id":"0bdc8aaf-9854-485f-84c8-c3300974a797","name":"Merge3"},{"parameters":{"method":"POST","url":"https://api.telegram.org/bot8207832455:AAGzn7aGpClD91WdqE5Mcx6nhVw8R5tLXCk/sendMediaGroup","sendBody":true,"bodyParameters":{"parameters":[{"name":"chat_id","value":"={{$json.tg_chat_id}}"},{"name":"media","value":"={{$json.tg_media_group_json}}"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[5152,2784],"id":"062873ef-f398-477f-ae82-4c3c925d841a","name":"HTTP Request","onError":"continueRegularOutput"},{"parameters":{"mode":"combine","combineBy":"combineByPosition","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5296,2784],"id":"8c9d27bf-2e31-4206-9321-6a8d8324a967","name":"Merge4"},{"parameters":{"numberInputs":4},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5536,2048],"id":"10f0484d-ad54-45b8-b4ae-b290240ae043","name":"Merge5"},{"parameters":{"documentId":{"__rl":true,"value":"1FyEGxa6JYTJxDrowfgzAzroTM8L3CWCSY1rgI2DK9KQ","mode":"id"},"sheetName":{"__rl":true,"value":"COOP_FACT","mode":"name"},"options":{}},"type":"n8n-nodes-base.googleSheets","typeVersion":4.7,"position":[3792,1776],"id":"001122f2-b00c-4b64-9e8b-9a30df48a2ec","name":"GS_CoopFact_GetRows","executeOnce":true,"credentials":{"googleSheetsOAuth2Api":{"id":"b5DluHDjTyDAsQWd","name":"Google Sheets account"}}},{"parameters":{},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[4048,1904],"id":"8152c001-dd6a-441a-beaa-89beaca2c0f9","name":"Merge_Facts_Barrier"},{"parameters":{"jsCode":"function regionToTz(region) {\n  if (region === 54) return 'Asia/Novosibirsk';\n  if (region === 82) return 'Europe/Simferopol';\n  return 'Europe/Moscow';\n}\n\nfunction cleanLine(s) {\n  return String(s ?? '')\n    .replace(/[\\uFEFF\\u200B\\u200C\\u200D\\u2060\\u00AD]/g, '')\n    .trim();\n}\n\nfunction formatLocalHuman(utcDate, tz) {\n  const dtf = new Intl.DateTimeFormat('en-CA', {\n    timeZone: tz,\n    hour12: false,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n  });\n\n  const parts = dtf.formatToParts(utcDate);\n  const map = {};\n  for (const p of parts) if (p.type !== 'literal') map[p.type] = p.value;\n\n  // пробел вместо T — людям проще\n  return `${map.year}-${map.month}-${map.day} ${map.hour}:${map.minute}:${map.second} (${tz})`;\n}\n\n// FIX: принимаем 1-2 цифры для часа (и для minutes/seconds тоже позволим 1-2 на всякий случай)\nfunction parseLocal(value) {\n  const s = cleanLine(value);\n  if (!s) return null;\n\n  // 0) YYYYMMDDTHHMMSS или YYYYMMDDTHHMM\n  let m = s.match(/^(\\d{4})(\\d{2})(\\d{2})T(\\d{1,2})(\\d{1,2})(\\d{1,2})?$/);\n  if (m) {\n    const [_, Y, M, D, h, min, sec] = m;\n    const hh = Number(h);\n    const mm = Number(min);\n    const ss = sec ? Number(sec) : 0;\n    if (!Number.isFinite(hh) || !Number.isFinite(mm) || !Number.isFinite(ss)) return null;\n    if (hh < 0 || hh > 23 || mm < 0 || mm > 59 || ss < 0 || ss > 59) return null;\n    return { Y: +Y, M: +M, D: +D, h: hh, min: mm, s: ss };\n  }\n\n  // 1) YYYY-MM-DD HH:mm(:ss)\n  m = s.match(/^(\\d{4})-(\\d{2})-(\\d{2})[ T](\\d{1,2}):(\\d{1,2})(?::(\\d{1,2}))?$/);\n  if (m) {\n    const [_, Y, M, D, h, min, sec] = m;\n    const hh = Number(h);\n    const mm = Number(min);\n    const ss = sec ? Number(sec) : 0;\n    if (!Number.isFinite(hh) || !Number.isFinite(mm) || !Number.isFinite(ss)) return null;\n    if (hh < 0 || hh > 23 || mm < 0 || mm > 59 || ss < 0 || ss > 59) return null;\n    return { Y: +Y, M: +M, D: +D, h: hh, min: mm, s: ss };\n  }\n\n  // 2) DD.MM.YYYY HH:mm(:ss)\n  m = s.match(/^(\\d{2})\\.(\\d{2})\\.(\\d{4})[ T](\\d{1,2}):(\\d{1,2})(?::(\\d{1,2}))?$/);\n  if (m) {\n    const [_, D, M, Y, h, min, sec] = m;\n    const hh = Number(h);\n    const mm = Number(min);\n    const ss = sec ? Number(sec) : 0;\n    if (!Number.isFinite(hh) || !Number.isFinite(mm) || !Number.isFinite(ss)) return null;\n    if (hh < 0 || hh > 23 || mm < 0 || mm > 59 || ss < 0 || ss > 59) return null;\n    return { Y: +Y, M: +M, D: +D, h: hh, min: mm, s: ss };\n  }\n\n  return null;\n}\n\nfunction isIsoLike(value) {\n  const s = cleanLine(value);\n  return /T/.test(s) || /Z$/.test(s) || /[+-]\\d{2}:\\d{2}$/.test(s);\n}\n\nfunction tzOffsetMinutesAt(utcDate, timeZone) {\n  const dtf = new Intl.DateTimeFormat('en-US', {\n    timeZone,\n    hour12: false,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n  });\n\n  const parts = dtf.formatToParts(utcDate);\n  const map = {};\n  for (const p of parts) if (p.type !== 'literal') map[p.type] = p.value;\n\n  const asIfUtc = Date.UTC(\n    Number(map.year),\n    Number(map.month) - 1,\n    Number(map.day),\n    Number(map.hour),\n    Number(map.minute),\n    Number(map.second),\n  );\n\n  const offsetMs = asIfUtc - utcDate.getTime();\n  return Math.round(offsetMs / 60000);\n}\n\nfunction dateFromLocalInTz(local, timeZone) {\n  const approxUtc = new Date(Date.UTC(local.Y, local.M - 1, local.D, local.h, local.min, local.s, 0));\n\n  const offsetMin1 = tzOffsetMinutesAt(approxUtc, timeZone);\n\n  let utcMs = approxUtc.getTime() - offsetMin1 * 60000;\n  let utcDate = new Date(utcMs);\n\n  const offsetMin2 = tzOffsetMinutesAt(utcDate, timeZone);\n  if (offsetMin2 !== offsetMin1) {\n    utcMs = approxUtc.getTime() - offsetMin2 * 60000;\n    utcDate = new Date(utcMs);\n  }\n\n  return utcDate;\n}\n\nfunction parseDateTimeByTz(value, timeZone) {\n  const v = cleanLine(value);\n  if (!v) return null;\n\n  // ISO со смещением/UTC — парсим напрямую\n  if (isIsoLike(v)) {\n    const iso = Date.parse(v);\n    return Number.isNaN(iso) ? null : new Date(iso);\n  }\n\n  // Иначе — локальное время TZ\n  const local = parseLocal(v);\n  if (!local) return null;\n\n  return dateFromLocalInTz(local, timeZone);\n}\n\nfunction parseDateTimeByRegion(value, region) {\n  const tz = regionToTz(region);\n  return parseDateTimeByTz(value, tz);\n}\n\n// ---------------- schedule mini DSL ----------------\n\n/**\n * IMPORTANT FIX:\n * Раньше мы \"расщепляли\" весь schedule по ';', из-за чего RRULE разваливался,\n * и BYDAY часто терялся (становился null).\n *\n * Теперь:\n * - НИКОГДА не делим весь текст по ';'\n * - Ищем строки DTSTART / RRULE / TZ / UNTIL по всему тексту\n * - ';' используем только внутри rruleRaw (rruleRaw.split(';'))\n */\nfunction parseSchedule(scheduleText) {\n  const raw0 = (scheduleText ?? '').toString();\n  const raw = raw0.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n  if (!cleanLine(raw)) return { ok: false, error: 'schedule empty' };\n\n  const findVal = (key) => {\n    const re = new RegExp(`(?:^|\\\\n)\\\\s*${key}(?:;[^:=]*)?\\\\s*[:=]\\\\s*(.+?)\\\\s*(?=\\\\n|$)`, 'i');\n    const m = raw.match(re);\n    return m ? cleanLine(m[1]) : null;\n  };\n\n  const tz = findVal('TZ');\n  const dtstartRaw = findVal('DTSTART');\n  const rruleRaw = findVal('RRULE');\n  const untilRaw = findVal('UNTIL');\n\n  if (!dtstartRaw) return { ok: false, error: 'DTSTART missing' };\n  if (!rruleRaw) return { ok: false, error: 'RRULE missing' };\n\n  const props = {};\n  for (const part0 of rruleRaw.split(';')) {\n    const part = cleanLine(part0);\n    if (!part) continue;\n\n    const eq = part.indexOf('=');\n    if (eq <= 0) continue;\n\n    const k = cleanLine(part.slice(0, eq)).toUpperCase();\n    const v = cleanLine(part.slice(eq + 1));\n    if (!k || v == null) continue;\n\n    props[k] = v;\n  }\n\n  const freq = (props.FREQ || '').toUpperCase();\n  if (!['DAILY', 'WEEKLY', 'MONTHLY'].includes(freq)) {\n    return { ok: false, error: `Unsupported FREQ=${props.FREQ || ''}` };\n  }\n\n  const interval = props.INTERVAL ? Math.max(1, Number(props.INTERVAL)) : 1;\n  const count = props.COUNT ? Math.max(1, Number(props.COUNT)) : null;\n  const untilStr = props.UNTIL || untilRaw || null;\n\n  const byday = props.BYDAY\n    ? props.BYDAY.split(',').map(s => cleanLine(s).toUpperCase()).filter(Boolean)\n    : null;\n\n  const byhour = props.BYHOUR != null\n    ? props.BYHOUR.split(',').map(x => Number(cleanLine(x)))\n    : null;\n\n  const byminute = props.BYMINUTE != null\n    ? props.BYMINUTE.split(',').map(x => Number(cleanLine(x)))\n    : null;\n\n  return { ok: true, tz, dtstartRaw, freq, interval, count, untilStr, byday, byhour, byminute, raw: { rruleRaw, scheduleRaw: raw } };\n}\n\nfunction formatPartsYMDInTz(utcDate, tz) {\n  const parts = new Intl.DateTimeFormat('en-US', {\n    timeZone: tz,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n  }).formatToParts(utcDate);\n\n  const map = {};\n  for (const p of parts) if (p.type !== 'literal') map[p.type] = p.value;\n\n  return { y: Number(map.year), m: Number(map.month), d: Number(map.day) };\n}\n\nfunction localYmdHmsToUtc(y, m, d, hh, mm, ss, tz) {\n  return dateFromLocalInTz({ Y: y, M: m, D: d, h: hh, min: mm, s: ss }, tz);\n}\n\nfunction addDaysUtc(date, days) {\n  return new Date(date.getTime() + days * 86400000);\n}\n\nfunction addWeeksUtc(date, weeks) {\n  return addDaysUtc(date, weeks * 7);\n}\n\nfunction addMonthsUtc(date, months) {\n  const y = date.getUTCFullYear();\n  const m = date.getUTCMonth();\n  const d = date.getUTCDate();\n  const hh = date.getUTCHours();\n  const mm = date.getUTCMinutes();\n  const ss = date.getUTCSeconds();\n\n  const targetMonthIndex = m + months;\n  const targetY = y + Math.floor(targetMonthIndex / 12);\n  const targetM = ((targetMonthIndex % 12) + 12) % 12;\n\n  const lastDay = new Date(Date.UTC(targetY, targetM + 1, 0)).getUTCDate();\n  const clampedD = Math.min(d, lastDay);\n\n  return new Date(Date.UTC(targetY, targetM, clampedD, hh, mm, ss));\n}\n\nfunction makeRunKeyLocal(postId, tz, occurrenceUtc) {\n  const id = (postId ?? 'unknown').toString();\n  const local = new Intl.DateTimeFormat('en-CA', {\n    timeZone: tz,\n    hour12: false,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n  }).format(occurrenceUtc).replace(', ', ' ');\n  return `post:${id}|${tz}|${local}`;\n}\n\n/**\n * Stable weekday for a LOCAL date (y,m,d) in timezone tz.\n * We convert local noon to UTC and then format weekday in tz.\n * Noon avoids boundary issues around midnight and DST.\n * Returns two-letter codes: MO,TU,WE,TH,FR,SA,SU.\n */\nfunction weekdayFromLocalYmd(y, m, d, tz) {\n  const probeUtc = localYmdHmsToUtc(y, m, d, 12, 0, 0, tz);\n  const w = new Intl.DateTimeFormat('en-US', { timeZone: tz, weekday: 'short' })\n    .format(probeUtc)\n    .slice(0, 2)\n    .toUpperCase();\n  return w;\n}\n\nfunction findLastOccurrenceUtc({ tz, dtstartUtc, dtstartLocalParts, rule, untilUtc, nowUtc }) {\n  let windowStartUtc;\n  if (rule.freq === 'DAILY') windowStartUtc = new Date(nowUtc.getTime() - 40 * 86400000);\n  else if (rule.freq === 'WEEKLY') windowStartUtc = new Date(nowUtc.getTime() - 26 * 7 * 86400000);\n  else windowStartUtc = new Date(nowUtc.getTime() - 24 * 31 * 86400000);\n\n  if (windowStartUtc < dtstartUtc) windowStartUtc = dtstartUtc;\n  const windowEndUtc = nowUtc;\n\n  const defaultH = dtstartLocalParts.h;\n  const defaultM = dtstartLocalParts.min;\n  const defaultS = dtstartLocalParts.s;\n\n  const hours = rule.byhour && rule.byhour.length ? rule.byhour : [defaultH];\n  const minutes = rule.byminute && rule.byminute.length ? rule.byminute : [defaultM];\n\n  let last = null;\n  let produced = 0;\n  const maxProduced = 5000;\n\n  if (rule.freq === 'DAILY') {\n    let cursor = new Date(Date.UTC(\n      windowStartUtc.getUTCFullYear(),\n      windowStartUtc.getUTCMonth(),\n      windowStartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    const dt0 = new Date(Date.UTC(\n      dtstartUtc.getUTCFullYear(),\n      dtstartUtc.getUTCMonth(),\n      dtstartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    let diffDays = Math.floor((cursor.getTime() - dt0.getTime()) / 86400000);\n    if (diffDays < 0) diffDays = 0;\n    const mod = diffDays % rule.interval;\n    if (mod !== 0) cursor = addDaysUtc(cursor, rule.interval - mod);\n\n    while (cursor <= windowEndUtc && produced < maxProduced) {\n      const ymd = formatPartsYMDInTz(cursor, tz);\n\n      if (rule.byday && rule.byday.length) {\n        const localWday = weekdayFromLocalYmd(ymd.y, ymd.m, ymd.d, tz);\n        if (!rule.byday.includes(localWday)) {\n          cursor = addDaysUtc(cursor, rule.interval);\n          continue;\n        }\n      }\n\n      for (const hh of hours) {\n        for (const mm of minutes) {\n          const occUtc = localYmdHmsToUtc(ymd.y, ymd.m, ymd.d, hh, mm, defaultS, tz);\n          if (occUtc < dtstartUtc) continue;\n          if (untilUtc && occUtc > untilUtc) continue;\n          if (occUtc < windowStartUtc || occUtc > windowEndUtc) continue;\n\n          produced++;\n          if (rule.count && produced > rule.count) return last;\n\n          if (!last || occUtc > last) last = occUtc;\n          if (produced >= maxProduced) break;\n        }\n        if (produced >= maxProduced) break;\n      }\n\n      cursor = addDaysUtc(cursor, rule.interval);\n    }\n  }\n\n  if (rule.freq === 'WEEKLY') {\n    const dtLocalWday = weekdayFromLocalYmd(dtstartLocalParts.Y, dtstartLocalParts.M, dtstartLocalParts.D, tz);\n    const days = (rule.byday && rule.byday.length) ? rule.byday : [dtLocalWday];\n\n    let cursorWeekStart = new Date(Date.UTC(\n      windowStartUtc.getUTCFullYear(),\n      windowStartUtc.getUTCMonth(),\n      windowStartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    const dt0 = new Date(Date.UTC(\n      dtstartUtc.getUTCFullYear(),\n      dtstartUtc.getUTCMonth(),\n      dtstartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    let diffDays = Math.floor((cursorWeekStart.getTime() - dt0.getTime()) / 86400000);\n    if (diffDays < 0) diffDays = 0;\n    const diffWeeks = Math.floor(diffDays / 7);\n    const mod = diffWeeks % rule.interval;\n    if (mod !== 0) cursorWeekStart = addWeeksUtc(cursorWeekStart, rule.interval - mod);\n\n    while (cursorWeekStart <= windowEndUtc && produced < maxProduced) {\n      for (let i = 0; i < 7; i++) {\n        const dayUtc = addDaysUtc(cursorWeekStart, i);\n        const ymd = formatPartsYMDInTz(dayUtc, tz);\n        const localWday = weekdayFromLocalYmd(ymd.y, ymd.m, ymd.d, tz);\n\n        if (!days.includes(localWday)) continue;\n\n        for (const hh of hours) {\n          for (const mm of minutes) {\n            const occUtc = localYmdHmsToUtc(ymd.y, ymd.m, ymd.d, hh, mm, defaultS, tz);\n            if (occUtc < dtstartUtc) continue;\n            if (untilUtc && occUtc > untilUtc) continue;\n            if (occUtc < windowStartUtc || occUtc > windowEndUtc) continue;\n\n            produced++;\n            if (rule.count && produced > rule.count) return last;\n\n            if (!last || occUtc > last) last = occUtc;\n            if (produced >= maxProduced) break;\n          }\n          if (produced >= maxProduced) break;\n        }\n      }\n\n      cursorWeekStart = addWeeksUtc(cursorWeekStart, rule.interval);\n    }\n  }\n\n  if (rule.freq === 'MONTHLY') {\n    let cursor = dtstartUtc;\n    let iterations = 0;\n    const maxIter = 300;\n\n    while (cursor < windowStartUtc && iterations < maxIter) {\n      cursor = addMonthsUtc(cursor, rule.interval);\n      iterations++;\n    }\n\n    while (cursor <= windowEndUtc && iterations < maxIter && produced < maxProduced) {\n      const ymd = formatPartsYMDInTz(cursor, tz);\n\n      for (const hh of hours) {\n        for (const mm of minutes) {\n          const occUtc = localYmdHmsToUtc(ymd.y, ymd.m, ymd.d, hh, mm, defaultS, tz);\n          if (occUtc < dtstartUtc) continue;\n          if (untilUtc && occUtc > untilUtc) continue;\n          if (occUtc < windowStartUtc || occUtc > windowEndUtc) continue;\n\n          produced++;\n          if (rule.count && produced > rule.count) return last;\n\n          if (!last || occUtc > last) last = occUtc;\n          if (produced >= maxProduced) break;\n        }\n        if (produced >= maxProduced) break;\n      }\n\n      cursor = addMonthsUtc(cursor, rule.interval);\n      iterations++;\n    }\n  }\n\n  return last;\n}\n\n// NEW: find next occurrence strictly after nowUtc\nfunction findNextOccurrenceUtc({ tz, dtstartUtc, dtstartLocalParts, rule, untilUtc, nowUtc }) {\n  const windowStartUtc = nowUtc;\n  let windowEndUtc;\n  if (rule.freq === 'DAILY') windowEndUtc = new Date(nowUtc.getTime() + 60 * 86400000);\n  else if (rule.freq === 'WEEKLY') windowEndUtc = new Date(nowUtc.getTime() + 60 * 7 * 86400000);\n  else windowEndUtc = new Date(nowUtc.getTime() + 24 * 31 * 86400000);\n\n  if (untilUtc && untilUtc < windowEndUtc) windowEndUtc = untilUtc;\n\n  const defaultH = dtstartLocalParts.h;\n  const defaultM = dtstartLocalParts.min;\n  const defaultS = dtstartLocalParts.s;\n\n  const hours = rule.byhour && rule.byhour.length ? rule.byhour : [defaultH];\n  const minutes = rule.byminute && rule.byminute.length ? rule.byminute : [defaultM];\n\n  let best = null;\n  let produced = 0;\n  const maxProduced = 5000;\n\n  if (rule.freq === 'DAILY') {\n    let cursor = new Date(Date.UTC(\n      windowStartUtc.getUTCFullYear(),\n      windowStartUtc.getUTCMonth(),\n      windowStartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    const dt0 = new Date(Date.UTC(\n      dtstartUtc.getUTCFullYear(),\n      dtstartUtc.getUTCMonth(),\n      dtstartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    let diffDays = Math.floor((cursor.getTime() - dt0.getTime()) / 86400000);\n    if (diffDays < 0) diffDays = 0;\n    const mod = diffDays % rule.interval;\n    if (mod !== 0) cursor = addDaysUtc(cursor, rule.interval - mod);\n\n    while (cursor <= windowEndUtc && produced < maxProduced) {\n      const ymd = formatPartsYMDInTz(cursor, tz);\n\n      if (rule.byday && rule.byday.length) {\n        const localWday = weekdayFromLocalYmd(ymd.y, ymd.m, ymd.d, tz);\n        if (!rule.byday.includes(localWday)) {\n          cursor = addDaysUtc(cursor, rule.interval);\n          continue;\n        }\n      }\n\n      for (const hh of hours) {\n        for (const mm of minutes) {\n          const occUtc = localYmdHmsToUtc(ymd.y, ymd.m, ymd.d, hh, mm, defaultS, tz);\n          if (occUtc < dtstartUtc) continue;\n          if (untilUtc && occUtc > untilUtc) continue;\n          if (occUtc <= windowStartUtc) continue;\n          if (occUtc > windowEndUtc) continue;\n\n          produced++;\n          if (rule.count && produced > rule.count) return best;\n\n          if (!best || occUtc < best) best = occUtc;\n          if (best) return best;\n        }\n      }\n\n      cursor = addDaysUtc(cursor, rule.interval);\n    }\n  }\n\n  if (rule.freq === 'WEEKLY') {\n    const dtLocalWday = weekdayFromLocalYmd(dtstartLocalParts.Y, dtstartLocalParts.M, dtstartLocalParts.D, tz);\n    const days = (rule.byday && rule.byday.length) ? rule.byday : [dtLocalWday];\n\n    let cursorWeekStart = new Date(Date.UTC(\n      windowStartUtc.getUTCFullYear(),\n      windowStartUtc.getUTCMonth(),\n      windowStartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    const dt0 = new Date(Date.UTC(\n      dtstartUtc.getUTCFullYear(),\n      dtstartUtc.getUTCMonth(),\n      dtstartUtc.getUTCDate(),\n      0, 0, 0\n    ));\n\n    let diffDays = Math.floor((cursorWeekStart.getTime() - dt0.getTime()) / 86400000);\n    if (diffDays < 0) diffDays = 0;\n    const diffWeeks = Math.floor(diffDays / 7);\n    const mod = diffWeeks % rule.interval;\n    if (mod !== 0) cursorWeekStart = addWeeksUtc(cursorWeekStart, rule.interval - mod);\n\n    while (cursorWeekStart <= windowEndUtc && produced < maxProduced) {\n      for (let i = 0; i < 7; i++) {\n        const dayUtc = addDaysUtc(cursorWeekStart, i);\n        const ymd = formatPartsYMDInTz(dayUtc, tz);\n        const localWday = weekdayFromLocalYmd(ymd.y, ymd.m, ymd.d, tz);\n\n        if (!days.includes(localWday)) continue;\n\n        for (const hh of hours) {\n          for (const mm of minutes) {\n            const occUtc = localYmdHmsToUtc(ymd.y, ymd.m, ymd.d, hh, mm, defaultS, tz);\n            if (occUtc < dtstartUtc) continue;\n            if (untilUtc && occUtc > untilUtc) continue;\n            if (occUtc <= windowStartUtc) continue;\n            if (occUtc > windowEndUtc) continue;\n\n            produced++;\n            if (rule.count && produced > rule.count) return best;\n\n            if (!best || occUtc < best) best = occUtc;\n            if (best) return best;\n          }\n        }\n      }\n\n      cursorWeekStart = addWeeksUtc(cursorWeekStart, rule.interval);\n    }\n  }\n\n  if (rule.freq === 'MONTHLY') {\n    let cursor = dtstartUtc;\n    let iterations = 0;\n    const maxIter = 300;\n\n    while (cursor <= windowStartUtc && iterations < maxIter) {\n      cursor = addMonthsUtc(cursor, rule.interval);\n      iterations++;\n    }\n\n    while (cursor <= windowEndUtc && iterations < maxIter && produced < maxProduced) {\n      const ymd = formatPartsYMDInTz(cursor, tz);\n\n      for (const hh of hours) {\n        for (const mm of minutes) {\n          const occUtc = localYmdHmsToUtc(ymd.y, ymd.m, ymd.d, hh, mm, defaultS, tz);\n          if (occUtc < dtstartUtc) continue;\n          if (untilUtc && occUtc > untilUtc) continue;\n          if (occUtc <= windowStartUtc) continue;\n          if (occUtc > windowEndUtc) continue;\n\n          produced++;\n          if (rule.count && produced > rule.count) return best;\n\n          if (!best || occUtc < best) best = occUtc;\n          if (best) return best;\n        }\n      }\n\n      cursor = addMonthsUtc(cursor, rule.interval);\n      iterations++;\n    }\n  }\n\n  return best;\n}\n\n// ---------------- main ----------------\n\nconst items = $input.all();\nconst nowUtc = new Date();\n\nreturn items.map(item => {\n  const p = item.json;\n\n  const tzRegion = regionToTz(p.region);\n\n  let due = false;\n  let reason = null;\n\n  // наружные поля\n  const nowLocal = formatLocalHuman(nowUtc, tzRegion);\n\n  let publishUtc = null;\n  let publishLocal = null;\n\n  let occurrenceUtc = null;\n  let occurrenceLocal = null;\n\n  let runKey = null;\n  let scheduleParsed = null;\n\n  // NEW plan\n  let planRunUtc = null;\n  let planRunLocal = null;\n\n  if (p.post_type === 2) {\n    publishUtc = parseDateTimeByRegion(p.publish_at, p.region);\n    publishLocal = publishUtc ? formatLocalHuman(publishUtc, tzRegion) : null;\n\n    if (!publishUtc) {\n      reason = 'one-time post without valid publish_at';\n    } else {\n      // для разового поста occurrence = publish_at\n      occurrenceUtc = publishUtc;\n      occurrenceLocal = formatLocalHuman(occurrenceUtc, tzRegion);\n\n      // формируем ключ заранее (антидубль как у регулярных)\n      runKey = makeRunKeyLocal(p.id, tzRegion, occurrenceUtc);\n\n      const alreadyKey = (p.last_run_key ?? '').toString().trim();\n      if (alreadyKey === runKey) {\n        due = false;\n        reason = 'one-time: already executed (last_run_key match)';\n      } else {\n        // запасной стопор по last_run_at_utc (если ключ почему-то не писался)\n        const lastRunAtUtc = p.last_run_at_utc ? new Date(p.last_run_at_utc) : null;\n        if (lastRunAtUtc && !isNaN(lastRunAtUtc.getTime())) {\n          if (lastRunAtUtc.getTime() >= occurrenceUtc.getTime() - 30 * 1000) {\n            due = false;\n            reason = 'one-time: already executed (last_run_at_utc >= publish_at)';\n          } else if (publishUtc <= nowUtc) {\n            due = true;\n            reason = 'due now (publish_at <= now) in region tz';\n          } else {\n            due = false;\n            reason = 'not yet (publish_at in future) in region tz';\n          }\n        } else {\n          if (publishUtc <= nowUtc) {\n            due = true;\n            reason = 'due now (publish_at <= now) in region tz';\n          } else {\n            due = false;\n            reason = 'not yet (publish_at in future) in region tz';\n          }\n        }\n      }\n    }\n  } else if (p.post_type === 1) {\n    if (!p.schedule) {\n      reason = 'regular post without schedule';\n    } else {\n      const parsed = parseSchedule(p.schedule);\n      if (!parsed.ok) {\n        reason = `schedule parse error: ${parsed.error}`;\n      } else {\n        const tz = parsed.tz || tzRegion;\n\n        const dtstartLocal = parseLocal(parsed.dtstartRaw);\n        if (!dtstartLocal) {\n          reason = 'DTSTART parse error';\n        } else {\n          const dtstartUtc = dateFromLocalInTz(dtstartLocal, tz);\n\n          let untilUtc = null;\n          if (parsed.untilStr) {\n            const u = parseDateTimeByTz(parsed.untilStr, tz);\n            if (!u) reason = 'UNTIL parse error';\n            else untilUtc = u;\n          }\n\n          if (!reason) {\n            const rule = {\n              freq: parsed.freq,\n              interval: parsed.interval,\n              count: parsed.count,\n              byday: parsed.byday,\n              byhour: parsed.byhour,\n              byminute: parsed.byminute,\n            };\n\n            scheduleParsed = {\n              tz,\n              dtstart_local: parsed.dtstartRaw,\n              dtstart_utc: dtstartUtc.toISOString(),\n              rule,\n              until_utc: untilUtc ? untilUtc.toISOString() : null,\n              raw: parsed.raw, // чтобы видеть rruleRaw/scheduleRaw в дебаге\n            };\n\n            const lastOcc = findLastOccurrenceUtc({\n              tz,\n              dtstartUtc,\n              dtstartLocalParts: dtstartLocal,\n              rule,\n              untilUtc,\n              nowUtc,\n            });\n\n            const nextOcc = findNextOccurrenceUtc({\n              tz,\n              dtstartUtc,\n              dtstartLocalParts: dtstartLocal,\n              rule,\n              untilUtc,\n              nowUtc,\n            });\n\n            if (nextOcc) {\n              planRunUtc = nextOcc;\n              planRunLocal = formatLocalHuman(nextOcc, tz);\n            } else {\n              planRunUtc = null;\n              planRunLocal = null;\n            }\n\n            if (!lastOcc) {\n              // FIX: корректная причина, когда DTSTART ещё не наступил (в будущем)\n              if (dtstartUtc > nowUtc) {\n                due = false;\n                reason = 'recurring: not yet started (DTSTART in future)';\n              } else {\n                // если DTSTART уже был в прошлом, но в lookback ничего не нашли\n                due = false;\n                reason = 'recurring: no occurrence found in lookback window';\n              }\n            } else {\n              occurrenceUtc = lastOcc;\n              occurrenceLocal = formatLocalHuman(occurrenceUtc, tz);\n              runKey = makeRunKeyLocal(p.id, tz, occurrenceUtc);\n\n              const alreadyKey = (p.last_run_key ?? '').toString().trim();\n              if (alreadyKey === runKey) {\n                due = false;\n                reason = 'recurring: already executed (last_run_key match)';\n              } else {\n                // secondary: last_run_at_utc (надежно парсится)\n                const lastRunAtUtc = p.last_run_at_utc ? new Date(p.last_run_at_utc) : null;\n                if (lastRunAtUtc && !isNaN(lastRunAtUtc.getTime())) {\n                  if (lastRunAtUtc.getTime() >= occurrenceUtc.getTime() - 30 * 1000) {\n                    due = false;\n                    reason = 'recurring: already executed (last_run_at_utc >= occurrence)';\n                  } else {\n                    due = true;\n                    reason = 'recurring: occurrence <= now and not executed';\n                  }\n                } else {\n                  due = true;\n                  reason = 'recurring: occurrence <= now and not executed';\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } else {\n    reason = 'unknown post_type';\n  }\n\n  return {\n    json: {\n      ...p,\n      _due: due,\n      _due_reason: reason,\n\n      // локальное отображение\n      _now: nowLocal,\n      _publish_at_parsed: publishLocal,\n      _occurrence_local: occurrenceLocal,\n\n      // UTC техничка (для записи)\n      _now_utc: nowUtc.toISOString(),\n      _occurrence_utc: occurrenceUtc ? occurrenceUtc.toISOString() : null,\n\n      _run_key: runKey,\n      _schedule_parsed: scheduleParsed,\n\n      // NEW: next planned run (for regular posts)\n      _plan_run_at: planRunLocal,\n      _plan_run_at_utc: planRunUtc ? planRunUtc.toISOString() : null,\n    },\n  };\n});\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[3440,2064],"id":"b0866502-fda3-4797-8e5b-fd087795d23b","name":"Determine due"},{"parameters":{"rule":{"interval":[{"field":"minutes"}]}},"type":"n8n-nodes-base.scheduleTrigger","typeVersion":1.3,"position":[2480,2288],"id":"6a239b4f-2a82-43d7-9714-d03e1af4eced","name":"Schedule Trigger"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"loose","version":3},"conditions":[{"id":"d7859595-c40c-40cf-9885-a94c7a7296ba","leftValue":"={{$json.send_vk}}","rightValue":"true","operator":{"type":"boolean","operation":"true","singleValue":true}}],"combinator":"and"},"looseTypeValidation":true,"options":{}},"type":"n8n-nodes-base.filter","typeVersion":2.3,"position":[4448,1504],"id":"de0ef206-4c04-4800-b743-1b4becd581f4","name":"Filter VK"},{"parameters":{"method":"POST","url":"https://api.vk.com/method/wall.post","sendBody":true,"contentType":"form-urlencoded","bodyParameters":{"parameters":[{"name":"owner_id","value":"=-114286850"},{"name":"from_group","value":"1"},{"name":"message","value":"={{$json.vk_message}}"},{"name":"access_token","value":"vk1.a.9nMQFYamjyb6V0wTTCDK_pi4ehFyFKa5c3ZLsizknn-4Vl0blAibzoQIy04vhvKoUmbOhVu7sKox2btvhT0ltZFsd5k97BjMGmlxSqb5YZnHc-_S6HN-o2XlkZQcM5lh5jmYRLupjGqKo2KfrO0EGLxgdEJrK6OeEp4NRcN0wDqVlWuAfUCGFZnBPUNbbbDq7kWuvJ4BmoLzbP8ZRzEHYQ"},{"name":"v","value":"5.131"}]},"options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[5008,1392],"id":"fac2370e-7275-472a-840d-7bef777b2d02","name":"VK wall.post","onError":"continueRegularOutput"},{"parameters":{"jsCode":"/**\n * Collect VK results per post_id (after Merge Combine/Position)\n *\n * Supports VK API responses from HTTP Request node (wall.post), which typically return:\n *  - Success: { response: { post_id: 123, ... } }\n *  - Error:   { error: { error_code: 214, error_msg: \"...\", error_text: \"...\", request_params: [...] } }\n *\n * But n8n can wrap HTTP responses as:\n *  - { statusCode: 200, body: { response:{...} } }  (when Response Format = JSON)\n *  - { statusCode: 200, body: \"...\" }              (string)\n *  - errors in p.error / p.message / p.response / p.body\n *\n * Output: one item per post_id with aggregation + Sheets update-like fields\n * (Note: do NOT write last_run_* here if you plan to require TG+VK together;\n *        you can still output vk_ok/vk_fail counts and update_error here.)\n */\n\nconst items = $input.all();\n\nfunction safeStr(v) {\n  if (v === null || v === undefined) return '';\n  return String(v);\n}\n\nfunction toNumOrNull(v) {\n  if (v === null || v === undefined || v === '') return null;\n  const n = Number(v);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction appendLog(existing, line) {\n  const base = (existing ?? '').toString().trim();\n  if (!base) return line;\n  return base + '\\n' + line;\n}\n\nfunction tryJsonParse(s) {\n  try {\n    return JSON.parse(s);\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction unwrapBody(p) {\n  // n8n HTTP Request may expose body at top-level or nested\n  const body = p?.body ?? p?.response?.body ?? p?.responseBody ?? null;\n\n  if (body && typeof body === 'object') return body;\n\n  if (typeof body === 'string') {\n    const j = tryJsonParse(body);\n    if (j && typeof j === 'object') return j;\n  }\n\n  // Sometimes response itself is the VK json\n  if (p && typeof p === 'object') {\n    if (p.response && typeof p.response === 'object') return p.response;\n    // if p has response/error at top-level, return p itself\n    if (p.response || p.error) return p;\n  }\n\n  return null;\n}\n\nfunction detectOk(p) {\n  if (!p) return false;\n\n  // Direct VK shape\n  if (p.response && typeof p.response === 'object' && (p.response.post_id || p.response.post_id === 0)) {\n    return true;\n  }\n\n  const b = unwrapBody(p);\n  if (b) {\n    if (b.response && typeof b.response === 'object' && (b.response.post_id || b.response.post_id === 0)) {\n      return true;\n    }\n    // VK sometimes returns \"response\": 1 for some methods, but wall.post should return object\n    if (typeof b.response === 'number' && b.response > 0) return true;\n  }\n\n  // Fallback: if statusCode is 2xx but VK error not visible, treat as ok (avoid false FAIL)\n  const sc = p.statusCode ?? p.status ?? p.response?.statusCode ?? null;\n  if (typeof sc === 'number' && sc >= 200 && sc < 300) {\n    const bb = b;\n    if (bb && bb.error) return false;\n    return true;\n  }\n\n  return false;\n}\n\nfunction extractErrorText(p) {\n  if (!p) return 'unknown error';\n\n  // n8n error object\n  if (typeof p.error === 'string') return p.error;\n  if (p.error?.message) return safeStr(p.error.message);\n  if (p.errorMessage) return safeStr(p.errorMessage);\n  if (p.message) return safeStr(p.message);\n  if (p.description) return safeStr(p.description);\n  if (p.cause) return safeStr(p.cause);\n\n  // VK error shape\n  const b = unwrapBody(p);\n  const errObj = b?.error ?? p?.error ?? null;\n\n  if (errObj && typeof errObj === 'object') {\n    const code = errObj.error_code ?? errObj.code ?? null;\n    const msg = errObj.error_msg ?? errObj.message ?? errObj.error_text ?? null;\n    if (code !== null || msg) {\n      return `vk_error${code !== null ? `#${safeStr(code)}` : ''}: ${safeStr(msg || 'unknown')}`.trim();\n    }\n    try {\n      return JSON.stringify(errObj);\n    } catch (e) {\n      return 'unstringifiable vk error';\n    }\n  }\n\n  // Raw body as string\n  const rawBody = p.body ?? p.response?.body ?? p.responseBody ?? null;\n  if (typeof rawBody === 'string') {\n    const s = rawBody.trim();\n    if (s) return s.slice(0, 500);\n  }\n\n  // Last resort\n  try {\n    return JSON.stringify(p).slice(0, 500);\n  } catch (e) {\n    return 'unknown error';\n  }\n}\n\nfunction extractVkPostId(p) {\n  const b = unwrapBody(p);\n  const direct = p?.response?.post_id ?? null;\n  if (direct !== null && direct !== undefined) return direct;\n\n  const pid = b?.response?.post_id ?? null;\n  if (pid !== null && pid !== undefined) return pid;\n\n  return null;\n}\n\n// group per post_id\nconst byPost = new Map();\n\nfor (const item of items) {\n  const p = item.json || {};\n\n  const postId = p.post_id ?? p.id ?? null;\n  if (!postId) continue;\n\n  if (!byPost.has(postId)) {\n    byPost.set(postId, {\n      post_id: postId,\n      row_number: toNumOrNull(p.row_number),\n\n      last_run_key: p._run_key ?? null,\n      now_utc: p._now_utc ?? new Date().toISOString(),\n      now_local: p._now ?? null,\n\n      plan_run_at: p._plan_run_at ?? null,\n      prev_error: p.error_prev ?? null,\n\n      total: 0,\n      ok: 0,\n      fail: 0,\n      fails: [],\n      vk_post_ids: [],\n    });\n  }\n\n  const agg = byPost.get(postId);\n\n  if (!agg.plan_run_at && p._plan_run_at) agg.plan_run_at = p._plan_run_at;\n\n  agg.total += 1;\n\n  const ok = detectOk(p);\n\n  if (ok) {\n    agg.ok += 1;\n    const vkPid = extractVkPostId(p);\n    if (vkPid !== null && vkPid !== undefined) agg.vk_post_ids.push(vkPid);\n  } else {\n    agg.fail += 1;\n    const desc = extractErrorText(p);\n    agg.fails.push({ desc: safeStr(desc) });\n  }\n}\n\nconst out = [];\n\nfor (const agg of byPost.values()) {\n  // success only if at least one ok and no fails\n  const allOk = agg.fail === 0 && agg.ok > 0;\n\n  let newError = agg.prev_error;\n\n  if (allOk) {\n    const vkInfo = agg.vk_post_ids.length ? ` vk_post_id=${safeStr(agg.vk_post_ids[0])}` : '';\n    newError = appendLog(\n      newError,\n      `[OK VK] ${agg.now_utc} key=${safeStr(agg.last_run_key)} sent=${agg.ok}/${agg.total}${vkInfo}`\n    );\n  } else {\n    const failLines = agg.fails\n      .slice(0, 20)\n      .map(f => `err=${safeStr(f.desc)}`)\n      .join(' | ');\n\n    newError = appendLog(\n      newError,\n      `[FAIL VK] ${agg.now_utc} key=${safeStr(agg.last_run_key)} ok=${agg.ok}/${agg.total} fails=${agg.fail}` +\n        (failLines ? ` :: ${failLines}` : '')\n    );\n  }\n\n  out.push({\n    json: {\n      post_id: agg.post_id,\n      row_number: agg.row_number,\n\n      _vk_all_ok: allOk,\n      _vk_sent_ok: agg.ok,\n      _vk_sent_fail: agg.fail,\n      _vk_sent_total: agg.total,\n\n      // Keep these in case you want final aggregator to decide.\n      update_last_run_at_utc: allOk ? agg.now_utc : null,\n      update_last_run_at: allOk ? agg.now_local : null,\n      update_last_run_key: allOk ? agg.last_run_key : null,\n\n      // write plan_run_at only on success\n      update_plan_run_at: allOk ? (agg.plan_run_at ?? null) : null,\n\n      update_error: newError,\n\n      // optional: useful for debugging\n      vk_post_ids: agg.vk_post_ids,\n    },\n  });\n}\n\nreturn out;\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[5712,1584],"id":"6d384305-38b6-48ab-a6c6-61b9ab718da3","name":"Collect VK results"},{"parameters":{"assignments":{"assignments":[{"id":"40cb9769-3d4e-4419-ba2d-1f2a143fc134","name":"row_number","value":"={{$json.row_number}}","type":"number"},{"id":"4a693b1b-a451-4be0-804e-dcea42cce4f1","name":"_run_key","value":"={{$json._run_key}}","type":"string"},{"id":"263354fa-7b27-48e5-b64f-e9782fe9f1c1","name":"_now","value":"{{$json._now}}","type":"string"},{"id":"800fee7f-bd57-43da-a970-c201ffd9f0d8","name":"error_prev","value":"={{$json.error}}","type":"string"},{"id":"d11608cf-910a-411d-86a7-b8de74c810b0","name":"vk_message","value":"={{$json.text}}","type":"string"},{"id":"a07aa251-a83a-4292-a9f6-c2791dcb2e72","name":"vk_owner_id","value":-114286850,"type":"number"},{"id":"c1320c28-2609-4d0a-81aa-a8913fd7433e","name":"_now_utc","value":"={{$json._now_utc}}","type":"string"},{"id":"e0226193-b507-45ff-8837-b96011bef7fb","name":"send_vk","value":"={{$json.send_vk}}","type":"boolean"},{"id":"6d495acc-0a1d-46cc-ba04-7a4b2f9b0cc6","name":"post_id","value":"={{$json.id}}","type":"number"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[4672,1360],"id":"28ca75fb-4f29-47c3-afea-73b5b6a4d9d6","name":"VK Edit Fields","onError":"continueRegularOutput"},{"parameters":{"mode":"combine","options":{}},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[5216,1568],"id":"0799731d-3ee8-499d-a563-5e807d812f20","name":"Merge VK"},{"parameters":{"jsCode":"// Loop over input items and add a new field called 'myNewField' to the JSON of each one\nfor (const item of $input.all()) {\n  item.json.myNewField = 1;\n}\n\nreturn $input.all();"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[5920,1584],"id":"2e21625b-4712-4e03-9577-245f919f8ade","name":"Code in JavaScript1"},{"parameters":{},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[6144,1872],"id":"63f69832-5f73-4200-8cfa-1e9fd1647dba","name":"Merge6"},{"parameters":{"jsCode":"/**\n * Final Collect (TG + VK) per post_id\n *\n * Input: mixed items from:\n *  - Collect TG results (your existing code)\n *  - Collect VK results (code we added)\n *\n * Goal:\n *  - decide final _all_ok ONLY when all enabled channels succeeded\n *  - build one aggregated update_error log per post\n *  - output ONE item per post_id with fields for Google Sheets update:\n *      - update_last_run_at_utc / update_last_run_at / update_last_run_key / update_plan_run_at (ONLY if _all_ok)\n *      - update_error (always)\n *\n * IMPORTANT:\n *  - This node expects send_tg / send_vk to be present on at least one of incoming items.\n *    If they are missing, it will infer requirements from presence of TG/VK collector items.\n *    (Recommended: add send_tg and send_vk to both TG Edit Fields and VK Edit Fields so they survive to collectors.)\n */\n\nconst items = $input.all();\n\nfunction safeStr(v) {\n  if (v === null || v === undefined) return '';\n  return String(v);\n}\n\nfunction toBoolOrNull(v) {\n  if (v === null || v === undefined) return null;\n  if (typeof v === 'boolean') return v;\n  if (typeof v === 'number') return v !== 0;\n  const s = String(v).trim().toLowerCase();\n  if (s === '') return null;\n  if (s === '1' || s === 'true' || s === 'yes' || s === 'y') return true;\n  if (s === '0' || s === 'false' || s === 'no' || s === 'n') return false;\n  return null;\n}\n\nfunction toNumOrNull(v) {\n  if (v === null || v === undefined || v === '') return null;\n  const n = Number(v);\n  return Number.isFinite(n) ? n : null;\n}\n\nfunction appendLog(existing, line) {\n  const base = (existing ?? '').toString().trim();\n  if (!base) return line;\n  return base + '\\n' + line;\n}\n\nfunction isTgCollectorItem(p) {\n  // Your TG collector outputs: _sent_ok/_sent_fail/_sent_total and _all_ok\n  return p && (p._sent_total !== undefined || p._sent_ok !== undefined || p._sent_fail !== undefined);\n}\n\nfunction isVkCollectorItem(p) {\n  // VK collector outputs: _vk_sent_total/_vk_sent_ok/_vk_sent_fail and _vk_all_ok\n  return p && (p._vk_sent_total !== undefined || p._vk_sent_ok !== undefined || p._vk_sent_fail !== undefined);\n}\n\nfunction pickFirstNonEmpty(...vals) {\n  for (const v of vals) {\n    if (v === null || v === undefined) continue;\n    if (typeof v === 'string' && v.trim() === '') continue;\n    return v;\n  }\n  return null;\n}\n\n// Group per post_id\nconst byPost = new Map();\n\nfor (const item of items) {\n  const p = item.json || {};\n  const postId = p.post_id ?? p.id ?? null;\n  if (!postId) continue;\n\n  if (!byPost.has(postId)) {\n    byPost.set(postId, {\n      post_id: postId,\n\n      // common context\n      row_number: toNumOrNull(p.row_number),\n      now_utc: p.update_last_run_at_utc ?? p._now_utc ?? null,\n      now_local: p.update_last_run_at ?? p._now ?? null,\n      last_run_key: p.update_last_run_key ?? p._run_key ?? null,\n      plan_run_at: p.update_plan_run_at ?? p._plan_run_at ?? null,\n\n      // flags\n      send_tg: toBoolOrNull(p.send_tg),\n      send_vk: toBoolOrNull(p.send_vk),\n\n      // collector results\n      tg_seen: false,\n      tg_ok: null,\n      tg_ok_count: null,\n      tg_fail_count: null,\n      tg_total: null,\n\n      vk_seen: false,\n      vk_ok: null,\n      vk_ok_count: null,\n      vk_fail_count: null,\n      vk_total: null,\n\n      // logs\n      prev_error: p.error_prev ?? null,\n      tg_update_error: null,\n      vk_update_error: null,\n\n      // final error assembled later\n      final_error: null,\n    });\n  }\n\n  const agg = byPost.get(postId);\n\n  // keep row_number if missing\n  if (agg.row_number === null || agg.row_number === undefined) {\n    agg.row_number = toNumOrNull(p.row_number);\n  }\n\n  // keep best timestamps/keys/plan\n  agg.now_utc = pickFirstNonEmpty(agg.now_utc, p.update_last_run_at_utc, p._now_utc);\n  agg.now_local = pickFirstNonEmpty(agg.now_local, p.update_last_run_at, p._now);\n  agg.last_run_key = pickFirstNonEmpty(agg.last_run_key, p.update_last_run_key, p._run_key);\n  agg.plan_run_at = pickFirstNonEmpty(agg.plan_run_at, p.update_plan_run_at, p._plan_run_at);\n\n  // capture send flags if present anywhere\n  const st = toBoolOrNull(p.send_tg);\n  const sv = toBoolOrNull(p.send_vk);\n  if (st !== null) agg.send_tg = st;\n  if (sv !== null) agg.send_vk = sv;\n\n  // capture prev_error if present\n  if (p.error_prev !== undefined && p.error_prev !== null) agg.prev_error = p.error_prev;\n\n  // Determine if this is TG or VK collector item\n  if (isTgCollectorItem(p) || p._all_ok !== undefined) {\n    agg.tg_seen = true;\n    if (typeof p._all_ok === 'boolean') agg.tg_ok = p._all_ok;\n    agg.tg_ok_count = toNumOrNull(p._sent_ok);\n    agg.tg_fail_count = toNumOrNull(p._sent_fail);\n    agg.tg_total = toNumOrNull(p._sent_total);\n\n    // Collect TG log line from update_error (it includes prev + appended line)\n    // We'll extract the *new* TG line by taking the last line, but safest is to just keep update_error and\n    // later build final by appending BOTH TG and VK last lines if we can.\n    if (p.update_error) agg.tg_update_error = safeStr(p.update_error);\n  }\n\n  if (isVkCollectorItem(p) || p._vk_all_ok !== undefined) {\n    agg.vk_seen = true;\n    if (typeof p._vk_all_ok === 'boolean') agg.vk_ok = p._vk_all_ok;\n    agg.vk_ok_count = toNumOrNull(p._vk_sent_ok);\n    agg.vk_fail_count = toNumOrNull(p._vk_sent_fail);\n    agg.vk_total = toNumOrNull(p._vk_sent_total);\n\n    if (p.update_error) agg.vk_update_error = safeStr(p.update_error);\n  }\n\n  // If item isn't clearly TG/VK collector, but has update_error, still keep it as prev_error fallback\n  if (!agg.tg_update_error && !agg.vk_update_error && p.update_error) {\n    // Could be a prior step; treat as base log\n    agg.prev_error = p.update_error;\n  }\n}\n\n// Helper to get last line of a log string\nfunction lastLine(s) {\n  if (!s) return '';\n  const lines = String(s).split('\\n').map(x => x.trim()).filter(Boolean);\n  return lines.length ? lines[lines.length - 1] : '';\n}\n\nconst out = [];\n\nfor (const agg of byPost.values()) {\n  // Decide requirements:\n  // If send_tg/send_vk are unknown, infer from presence of collector items.\n  const reqTg = (agg.send_tg === null || agg.send_tg === undefined) ? agg.tg_seen : agg.send_tg;\n  const reqVk = (agg.send_vk === null || agg.send_vk === undefined) ? agg.vk_seen : agg.send_vk;\n\n  // Determine per-channel ok:\n  // If required but no collector result -> fail.\n  const tgOk = reqTg ? (agg.tg_ok === true) : true;\n  const vkOk = reqVk ? (agg.vk_ok === true) : true;\n\n  const allOk = tgOk && vkOk;\n\n  // Build final error:\n  // Start with prev_error, then append last TG line and last VK line if present.\n  // We use lastLine(...) because collector update_error already includes previous history.\n  let newError = agg.prev_error;\n\n  const tgLine = lastLine(agg.tg_update_error);\n  const vkLine = lastLine(agg.vk_update_error);\n\n  if (tgLine) newError = appendLog(newError, tgLine);\n  if (vkLine) newError = appendLog(newError, vkLine);\n\n  // If no prev_error and collectors didn't provide anything, still provide a minimal diagnostic.\n  if (!newError) {\n    newError = `[INFO] ${safeStr(agg.now_utc || new Date().toISOString())} no logs from collectors`;\n  }\n\n  out.push({\n    json: {\n      post_id: agg.post_id,\n      row_number: agg.row_number,\n\n      // final success only if all required channels succeeded\n      _all_ok: allOk,\n\n      // expose channel statuses for debugging\n      _req_tg: reqTg,\n      _req_vk: reqVk,\n      _tg_ok: agg.tg_ok,\n      _vk_ok: agg.vk_ok,\n\n      // optionally counts (may be null if not present)\n      _tg_sent_ok: agg.tg_ok_count,\n      _tg_sent_fail: agg.tg_fail_count,\n      _tg_sent_total: agg.tg_total,\n      _vk_sent_ok: agg.vk_ok_count,\n      _vk_sent_fail: agg.vk_fail_count,\n      _vk_sent_total: agg.vk_total,\n\n      // Sheets update fields (write only on final success)\n      update_last_run_at_utc: allOk ? (agg.now_utc ?? null) : null,\n      update_last_run_at: allOk ? (agg.now_local ?? null) : null,\n      update_last_run_key: allOk ? (agg.last_run_key ?? null) : null,\n      update_plan_run_at: allOk ? (agg.plan_run_at ?? null) : null,\n\n      update_error: newError,\n    },\n  });\n}\n\nreturn out;\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[6336,1872],"id":"941b2725-ae09-438b-9557-900494ecf564","name":"Final Collect"}],"connections":{"When clicking ‘Execute workflow’":{"main":[[{"node":"Get row(s) in sheet","type":"main","index":0}]]},"Get row(s) in sheet":{"main":[[{"node":"Filter","type":"main","index":0}]]},"Filter":{"main":[[{"node":"Code in JavaScript","type":"main","index":0}]]},"Code in JavaScript":{"main":[[{"node":"Determine due","type":"main","index":0}]]},"Filter1":{"main":[[{"node":"Postgre_store_extract","type":"main","index":0},{"node":"Merge1","type":"main","index":0},{"node":"GS_CoopFact_GetRows","type":"main","index":0}]]},"Code in JavaScript2":{"main":[[{"node":"Edit Fields","type":"main","index":0},{"node":"Filter VK","type":"main","index":0}]]},"Postgre_store_extract":{"main":[[{"node":"Merge1","type":"main","index":1}]]},"Send a text message":{"main":[[{"node":"Merge","type":"main","index":1}]]},"Edit Fields":{"main":[[{"node":"Switch","type":"main","index":0}]]},"Collect TG results":{"main":[[{"node":"Merge6","type":"main","index":1}]]},"Merge":{"main":[[{"node":"Merge5","type":"main","index":0}]]},"If":{"main":[[{"node":"Update row in sheet","type":"main","index":0}],[{"node":"Update row in sheet1","type":"main","index":0}]]},"Merge1":{"main":[[{"node":"Merge_Facts_Barrier","type":"main","index":1}]]},"Switch":{"main":[[{"node":"Send a text message","type":"main","index":0},{"node":"Merge","type":"main","index":0}],[{"node":"Send a photo message","type":"main","index":0},{"node":"Merge2","type":"main","index":0}],[{"node":"Send a video","type":"main","index":0},{"node":"Merge3","type":"main","index":0}],[{"node":"HTTP Request","type":"main","index":0},{"node":"Merge4","type":"main","index":0}]]},"Send a photo message":{"main":[[{"node":"Merge2","type":"main","index":1}]]},"Merge2":{"main":[[{"node":"Merge5","type":"main","index":1}]]},"Send a video":{"main":[[{"node":"Merge3","type":"main","index":1}]]},"Merge3":{"main":[[{"node":"Merge5","type":"main","index":2}]]},"HTTP Request":{"main":[[{"node":"Merge4","type":"main","index":1}]]},"Merge4":{"main":[[{"node":"Merge5","type":"main","index":3}]]},"Merge5":{"main":[[{"node":"Collect TG results","type":"main","index":0}]]},"GS_CoopFact_GetRows":{"main":[[{"node":"Merge_Facts_Barrier","type":"main","index":0}]]},"Merge_Facts_Barrier":{"main":[[{"node":"Code in JavaScript2","type":"main","index":0}]]},"Determine due":{"main":[[{"node":"Filter1","type":"main","index":0}]]},"Schedule Trigger":{"main":[[{"node":"Get row(s) in sheet","type":"main","index":0}]]},"Filter VK":{"main":[[{"node":"VK Edit Fields","type":"main","index":0}]]},"VK wall.post":{"main":[[{"node":"Merge VK","type":"main","index":0}]]},"VK Edit Fields":{"main":[[{"node":"VK wall.post","type":"main","index":0},{"node":"Merge VK","type":"main","index":1}]]},"Merge VK":{"main":[[{"node":"Collect VK results","type":"main","index":0}]]},"Collect VK results":{"main":[[{"node":"Code in JavaScript1","type":"main","index":0}]]},"Code in JavaScript1":{"main":[[{"node":"Merge6","type":"main","index":0}]]},"Merge6":{"main":[[{"node":"Final Collect","type":"main","index":0}]]},"Final Collect":{"main":[[{"node":"If","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","availableInMCP":false,"timeSavedMode":"fixed","callerPolicy":"workflowsFromSameOwner"},"staticData":{"node:Schedule Trigger":{"recurrenceRules":[]}},"meta":{"templateCredsSetupCompleted":true},"pinData":{},"versionId":"886b9c6d-6e94-4d9c-b507-71243bb6e2ef","activeVersionId":null,"versionCounter":82,"triggerCount":1,"tags":[],"shared":[{"updatedAt":"2026-02-13T15:34:32.894Z","createdAt":"2026-02-13T15:34:32.894Z","role":"workflow:owner","workflowId":"pqVwIgxssVYuC3XM","projectId":"pN1dQC2QTiUB8OxN","project":{"updatedAt":"2026-01-03T09:50:23.589Z","createdAt":"2026-01-02T11:57:57.457Z","id":"pN1dQC2QTiUB8OxN","name":"Ilya Sukharev <retail.sukharev@yandex.ru>","type":"personal","icon":null,"description":null,"creatorId":"a8327288-747a-47c3-9f5f-b2070eff6d8c"}}]}]